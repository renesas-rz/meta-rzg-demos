diff --git a/omx/gstomxvideoenc.c b/omx/gstomxvideoenc.c
index cec44cb..89ca65d 100644
--- a/omx/gstomxvideoenc.c
+++ b/omx/gstomxvideoenc.c
@@ -26,6 +26,7 @@
 #include <gst/gst.h>
 #include <gst/video/gstvideometa.h>
 #include <string.h>
+#include <stdio.h>
 
 #include "gstomxvideoenc.h"
 
@@ -76,6 +77,7 @@ static void gst_omx_video_enc_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
 
 
+static GList * get_mmap_p_addr(const char * video_file);
 static GstStateChangeReturn
 gst_omx_video_enc_change_state (GstElement * element,
     GstStateChange transition);
@@ -112,6 +114,9 @@ enum
   PROP_QUANT_B_FRAMES
 };
 
+GList * p_buffers = NULL;
+GstVideoCodecFrame * pre_frame;
+
 /* FIXME: Better defaults */
 #define GST_OMX_VIDEO_ENC_CONTROL_RATE_DEFAULT (0xffffffff)
 #define GST_OMX_VIDEO_ENC_TARGET_BITRATE_DEFAULT (0xffffffff)
@@ -1266,6 +1271,13 @@ gst_omx_video_enc_set_format (GstVideoEncoder * encoder,
       port_def.format.video.xFramerate = (info->fps_n) / (info->fps_d);
   }
 
+  p_buffers = get_mmap_p_addr("/dev/video0");
+  if(p_buffers) {
+    port_def.nBufferCountActual = g_list_length (p_buffers);
+    GST_DEBUG_OBJECT (self, "get %d mmap physical addresses of /dev/video0",
+                      g_list_length (p_buffers));
+  }
+
   GST_DEBUG_OBJECT (self, "Setting inport port definition");
   if (gst_omx_port_update_port_definition (self->enc_in_port,
           &port_def) != OMX_ErrorNone)
@@ -1299,8 +1311,17 @@ gst_omx_video_enc_set_format (GstVideoEncoder * encoder,
       return FALSE;
 
     /* Need to allocate buffers to reach Idle state */
-    if (gst_omx_port_allocate_buffers (self->enc_in_port) != OMX_ErrorNone)
-      return FALSE;
+    if(p_buffers) {
+      if(gst_omx_port_use_buffers (self->enc_in_port,p_buffers) != OMX_ErrorNone){
+        GST_ERROR_OBJECT (self, "OMX_UseBuffer() Error! try OMX_AllocateBuffer()");
+        p_buffers = NULL;
+        if (gst_omx_port_allocate_buffers (self->enc_in_port) != OMX_ErrorNone)
+          return FALSE;
+      }
+    } else {
+      if (gst_omx_port_allocate_buffers (self->enc_in_port) != OMX_ErrorNone)
+        return FALSE;
+    }
 
     /* Allocate for output port */
    if (gst_omx_port_allocate_buffers (self->enc_out_port) != OMX_ErrorNone)
@@ -1397,9 +1418,12 @@ gst_omx_video_enc_fill_buffer (GstOMXVideoEnc * self, GstBuffer * inbuf,
       outbuf->omx_buf->nAllocLen - outbuf->omx_buf->nOffset) {
     outbuf->omx_buf->nFilledLen = gst_buffer_get_size (inbuf);
 
+  if(!p_buffers) {
     gst_buffer_extract (inbuf, 0,
         outbuf->omx_buf->pBuffer + outbuf->omx_buf->nOffset,
         outbuf->omx_buf->nFilledLen);
+  }
+
     ret = TRUE;
     goto done;
   }
@@ -1774,7 +1798,13 @@ gst_omx_video_enc_handle_frame (GstVideoEncoder * encoder,
     GST_DEBUG_OBJECT (self, "Passed frame to component");
   }
 
-  gst_video_codec_frame_unref (frame);
+  if(p_buffers) {
+    if(pre_frame)
+      gst_video_codec_frame_unref (pre_frame);
+    pre_frame = frame;
+  } else {
+    gst_video_codec_frame_unref (frame);
+  }
 
   return self->downstream_flow_ret;
 
@@ -1959,3 +1989,32 @@ gst_omx_video_enc_getcaps (GstVideoEncoder * encoder, GstCaps * filter)
     return gst_video_encoder_proxy_getcaps (encoder, NULL, filter);
   }
 }
+
+static GList * get_mmap_p_addr(const char * video_file) 
+{
+    FILE *fp;
+    char map_file[50];
+    char s_p_addr[50];  	
+    char tmp[200];
+    unsigned long p_addr;
+    GList *mmap_addr = NULL;
+
+    snprintf( map_file, 50,"/proc/%d/maps",getpid());
+
+    if((fp = fopen(map_file, "r")) == NULL) {
+        return(0);
+    }
+	
+    while(fgets(tmp, 200, fp) != NULL) {
+      if((strstr(tmp, video_file)) != NULL) {
+        strncpy(s_p_addr,tmp+23,8);
+        s_p_addr[8] = '\0';
+        p_addr = strtoul(s_p_addr,NULL,16);
+        GST_DEBUG ("Get physical address %lx from %s", p_addr, video_file);
+        mmap_addr = g_list_prepend (mmap_addr, (gpointer)p_addr);
+      }
+    }
+
+    fclose(fp);
+    return mmap_addr;
+}
