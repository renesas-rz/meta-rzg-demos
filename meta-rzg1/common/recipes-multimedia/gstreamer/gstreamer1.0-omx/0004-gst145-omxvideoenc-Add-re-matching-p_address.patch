From 47829f7d49db116e7a0e1f2e9e7bb31ef6ae5d9f Mon Sep 17 00:00:00 2001
From: Long Dang <long.dang.aj@rvc.renesas.com>
Date: Fri, 9 Sep 2016 10:25:53 +0700
Subject: [PATCH 4/5] gst145-omxvideoenc:Add re-matching p_address

Porting from a patch in Linux 3.10 environment

Signed-off-by: Long Dang <long.dang.aj@rvc.renesas.com>
---
 omx/gstomxvideoenc.c | 52 ++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 50 insertions(+), 2 deletions(-)

diff --git a/omx/gstomxvideoenc.c b/omx/gstomxvideoenc.c
index 90c8821..4088eff 100644
--- a/omx/gstomxvideoenc.c
+++ b/omx/gstomxvideoenc.c
@@ -105,6 +105,9 @@ enum

 GList * p_buffers = NULL;
 GstVideoCodecFrame * pre_frame;
+#define MAX_BUFFER 10
+unsigned long p_addr_lst[MAX_BUFFER];
+unsigned long v_addr_lst[MAX_BUFFER];

 /* FIXME: Better defaults */
 #define GST_OMX_VIDEO_ENC_CONTROL_RATE_DEFAULT (0xffffffff)
@@ -1602,7 +1605,36 @@ gst_omx_video_enc_handle_frame (GstVideoEncoder * encoder,
      * _loop() can't call _finish_frame() and we might block forever
      * because no input buffers are released */
     GST_VIDEO_ENCODER_STREAM_UNLOCK (self);
-    acq_ret = gst_omx_port_acquire_buffer (port, &buf);
+    if (p_buffers) {
+      int i;
+      GstMapInfo map;
+
+      gst_buffer_map (frame->input_buffer, &map, GST_MAP_READ);
+      for (i = 0; i < MAX_BUFFER ; i++) {
+        if (map.data == (guint8 *)v_addr_lst[i])
+          break;
+      }
+      gst_buffer_unmap (frame->input_buffer, &map);
+
+      if (i < MAX_BUFFER) {
+        do {
+          acq_ret = gst_omx_port_acquire_buffer (port, &buf);
+          if (buf == NULL)
+            break;
+
+          if ((guint8 *)p_addr_lst[i] != buf->omx_buf->pBuffer) {
+            g_queue_push_tail (&port->pending_buffers, buf);
+          } else {
+            break;
+          }
+        } while (1);
+      } else {
+        acq_ret = gst_omx_port_acquire_buffer (port, &buf);
+      }
+    }
+    else {
+      acq_ret = gst_omx_port_acquire_buffer (port, &buf);
+    }

     if (acq_ret == GST_OMX_ACQUIRE_BUFFER_ERROR) {
       GST_VIDEO_ENCODER_STREAM_LOCK (self);
@@ -1920,10 +1952,13 @@ static GList * get_mmap_p_addr(const char * video_file)
 {
     FILE *fp;
     char map_file[50];
+    char s_v_addr[50];
     char s_p_addr[50];
     char tmp[200];
+    unsigned long v_addr;
     unsigned long p_addr;
     GList *mmap_addr = NULL;
+    int count = 0;

     snprintf( map_file, 50,"/proc/%d/maps",getpid());

@@ -1935,9 +1970,22 @@ static GList * get_mmap_p_addr(const char * video_file)
       if((strstr(tmp, video_file)) != NULL) {
         strncpy(s_p_addr,tmp+23,8);
         s_p_addr[8] = '\0';
+        strncpy(s_v_addr,tmp+0,8);
+        s_v_addr[8] = '\0';
         p_addr = strtoul(s_p_addr,NULL,16);
-        GST_DEBUG ("Get physical address %lx from %s", p_addr, video_file);
+        v_addr = strtoul(s_v_addr,NULL,16);
+        GST_DEBUG ("Get physical address %lx mapped to %lx from %s",
+                    p_addr, v_addr, video_file);
         mmap_addr = g_list_prepend (mmap_addr, (gpointer)p_addr);
+        p_addr_lst[count] = p_addr;
+        v_addr_lst[count] = v_addr;
+        count++;
+
+        if (count > MAX_BUFFER)
+        {
+            GST_ERROR ("Exceed number of MAX_BUFFER(%d)!",MAX_BUFFER);
+            return mmap_addr;
+        }
       }
     }

--
1.9.1
