From f494808e799e8f8fcdc64231008bf5dec01c805c Mon Sep 17 00:00:00 2001
From: HungTran <hung.tran.jy@rvc.renesas.com>
Date: Fri, 11 Nov 2016 22:45:20 +0700
Subject: [PATCH] Add uio_prr module for skrzg1m into kernel

Signed-off-by: HungTran <hung.tran.jy@rvc.renesas.com>
---
 arch/arm/configs/shmobile_defconfig              |   2 +
 arch/arm/mach-shmobile/board-skrzg1e-reference.c |  36 +++++
 arch/arm/mach-shmobile/board-skrzg1m-reference.c |  34 +++++
 drivers/uio/Kconfig                              |   7 +
 drivers/uio/Makefile                             |   1 +
 drivers/uio/uio_prr.c                            | 179 +++++++++++++++++++++++
 6 files changed, 259 insertions(+)
 create mode 100644 drivers/uio/uio_prr.c

diff --git a/arch/arm/configs/shmobile_defconfig b/arch/arm/configs/shmobile_defconfig
index b280145..78526e1 100644
--- a/arch/arm/configs/shmobile_defconfig
+++ b/arch/arm/configs/shmobile_defconfig
@@ -204,6 +204,8 @@ CONFIG_DMADEVICES=y
 CONFIG_SH_DMAE=y
 CONFIG_RCAR_AUDMAC_PP=y
 CONFIG_RCAR_DMAC=y
+CONFIG_UIO=y
+CONFIG_UIO_PRR=y
 # CONFIG_IOMMU_SUPPORT is not set
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
diff --git a/arch/arm/mach-shmobile/board-skrzg1e-reference.c b/arch/arm/mach-shmobile/board-skrzg1e-reference.c
index 263e6cf..5d9ae3a 100644
--- a/arch/arm/mach-shmobile/board-skrzg1e-reference.c
+++ b/arch/arm/mach-shmobile/board-skrzg1e-reference.c
@@ -852,6 +852,41 @@ static struct of_dev_auxdata skrzg1e_auxdata_lookup[] __initdata = {
 	{},
 };
 
+/* Platform device */
+/* UIO-PRR */
+#include <linux/uio_driver.h>
+#include <linux/platform_device.h>
+
+#define RC_BASE_PRR		UL(0xff000000)
+static struct uio_info uio_prr_platform_data = {
+		.name = "uio_prr",
+		.version = "0.1",
+};
+static struct resource uio_prr_resources[] = {
+	[0] = {
+		.name = "PRR",
+		.start = RC_BASE_PRR,
+		.end  = (RC_BASE_PRR + 0x00001000 - 1),
+		.flags = IORESOURCE_MEM,
+	    },
+};
+static struct platform_device uio_prr_device = {
+	.name = "uio_prr",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(uio_prr_resources),
+	.resource  = uio_prr_resources,
+	.dev = {
+		.platform_data = & uio_prr_platform_data,
+	},
+};
+
+
+static struct platform_device *skrzg1e_uio_devices[] __initdata = {
+		&uio_prr_device,
+};
+
+
+
 static void __init skrzg1e_add_standard_devices(void)
 {
 	shmobile_clk_workaround(clk_names, ARRAY_SIZE(clk_names), false);
@@ -863,6 +898,7 @@ static void __init skrzg1e_add_standard_devices(void)
 #endif
 	of_platform_populate(NULL, of_default_bus_match_table,
 			     skrzg1e_auxdata_lookup, NULL);
+	platform_add_devices(skrzg1e_uio_devices, ARRAY_SIZE(skrzg1e_uio_devices));
 	skrzg1e_add_du_device();
 
 	platform_device_register_resndata(&platform_bus, "usb_phy_rcar_gen2",
diff --git a/arch/arm/mach-shmobile/board-skrzg1m-reference.c b/arch/arm/mach-shmobile/board-skrzg1m-reference.c
index 8f57a95..79ee9a2 100644
--- a/arch/arm/mach-shmobile/board-skrzg1m-reference.c
+++ b/arch/arm/mach-shmobile/board-skrzg1m-reference.c
@@ -835,6 +835,39 @@ static struct of_dev_auxdata skrzg1m_auxdata_lookup[] __initdata = {
 		       "spi_r8a7743_msiof.0", &msiof0_info),
 	{},
 };
+/* Platform device */
+/* UIO-PRR */
+#include <linux/uio_driver.h>
+#include <linux/platform_device.h>
+
+#define RC_BASE_PRR		UL(0xff000000)
+static struct uio_info uio_prr_platform_data = {
+		.name = "uio_prr",
+		.version = "0.1",
+};
+static struct resource uio_prr_resources[] = {
+	[0] = {
+		.name = "PRR",
+		.start = RC_BASE_PRR,
+		.end  = (RC_BASE_PRR + 0x00001000 - 1),
+		.flags = IORESOURCE_MEM,
+	    },
+};
+static struct platform_device uio_prr_device = {
+	.name = "uio_prr",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(uio_prr_resources),
+	.resource  = uio_prr_resources,
+	.dev = {
+		.platform_data = & uio_prr_platform_data,
+	},
+};
+
+
+static struct platform_device *skrzg1m_uio_devices[] __initdata = {
+		&uio_prr_device,
+};
+
 
 static void __init skrzg1m_add_standard_devices(void)
 {
@@ -848,6 +881,7 @@ static void __init skrzg1m_add_standard_devices(void)
 	of_platform_populate(NULL, of_default_bus_match_table,
 			     skrzg1m_auxdata_lookup, NULL);
 
+	platform_add_devices(skrzg1m_uio_devices, ARRAY_SIZE(skrzg1m_uio_devices));
 	skrzg1m_add_du_device();
 	skrzg1m_add_usb_devices();
 	skrzg1m_add_camera0_device();
diff --git a/drivers/uio/Kconfig b/drivers/uio/Kconfig
index 5295be0..db9f974 100644
--- a/drivers/uio/Kconfig
+++ b/drivers/uio/Kconfig
@@ -30,6 +30,13 @@ config UIO_PDRV
 
 	  If you don't know what to do here, say N.
 
+config UIO_PRR
+	tristate "Userspace I/O PRR driver"
+	help
+	  PRR driver for Userspace I/O devices.
+
+	  If you don't know what to do here, say N.
+
 config UIO_PDRV_GENIRQ
 	tristate "Userspace I/O platform driver with generic IRQ handling"
 	help
diff --git a/drivers/uio/Makefile b/drivers/uio/Makefile
index b354c53..d10c87a 100644
--- a/drivers/uio/Makefile
+++ b/drivers/uio/Makefile
@@ -1,6 +1,7 @@
 obj-$(CONFIG_UIO)	+= uio.o
 obj-$(CONFIG_UIO_CIF)	+= uio_cif.o
 obj-$(CONFIG_UIO_PDRV)	+= uio_pdrv.o
+obj-$(CONFIG_UIO_PRR)	+= uio_prr.o
 obj-$(CONFIG_UIO_PDRV_GENIRQ)	+= uio_pdrv_genirq.o
 obj-$(CONFIG_UIO_DMEM_GENIRQ)	+= uio_dmem_genirq.o
 obj-$(CONFIG_UIO_AEC)	+= uio_aec.o
diff --git a/drivers/uio/uio_prr.c b/drivers/uio/uio_prr.c
new file mode 100644
index 0000000..fbb6950
--- /dev/null
+++ b/drivers/uio/uio_prr.c
@@ -0,0 +1,179 @@
+/*
+ * drivers/uio/uio_prr.c
+ *
+ * Userspace I/O driver for PRR
+ *
+ * Based on uio_pdrv.c
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/uio_driver.h>
+#include <linux/bitops.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/module.h>
+
+#define DRIVER_NAME "uio_prr"
+
+struct uio_platdata {
+	struct uio_info *uioinfo;
+	unsigned long flags;
+	struct platform_device *pdev;
+        void __iomem *base_reg;		/* CHn PRR Register Address */
+};
+
+
+#include <asm/io.h>
+
+static int uio_prr_open(struct uio_info *info, struct inode *inode)
+{
+	printk(KERN_INFO "uio_prr_open enter\n");
+
+	return 0;
+}
+
+static int uio_prr_release(struct uio_info *info, struct inode *inode)
+{
+	return 0;
+}
+
+static int uio_prr_probe(struct platform_device *pdev)
+{
+	struct uio_info *uioinfo = pdev->dev.platform_data;
+	struct uio_platdata *priv;
+	struct uio_mem *uiomem;
+	int ret = -EINVAL;
+	int i;
+	struct resource *res;
+
+	printk(KERN_INFO "uio_prr_probe enter id = %d\n", pdev->id);
+
+	if (!uioinfo || !uioinfo->name || !uioinfo->version) {
+		dev_err(&pdev->dev, "missing platform_data\n");
+		goto bad0;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if ( ! res ) {
+		dev_err(&pdev->dev, "Not enouch PRR platform resources.\n");
+		goto bad0;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		ret = -ENOMEM;
+		dev_err(&pdev->dev, "unable to kmalloc\n");
+		goto bad0;
+	}
+
+	priv->uioinfo = uioinfo;
+	priv->flags = 0;
+	priv->pdev = pdev;
+
+	uiomem = &uioinfo->mem[0];
+
+	for (i = 0; i < pdev->num_resources; ++i) {
+		struct resource *r = &pdev->resource[i];
+
+		if (r->flags != IORESOURCE_MEM)
+			continue;
+
+		if (uiomem >= &uioinfo->mem[MAX_UIO_MAPS]) {
+			dev_warn(&pdev->dev, "device has more than "
+					__stringify(MAX_UIO_MAPS)
+					" I/O memory resources.\n");
+			break;
+		}
+
+		uiomem->memtype = UIO_MEM_PHYS;
+		uiomem->addr = r->start;
+		uiomem->size = r->end - r->start + 1;
+		++uiomem;
+	}
+
+	while (uiomem < &uioinfo->mem[MAX_UIO_MAPS]) {
+		uiomem->size = 0;
+		++uiomem;
+	}
+
+	uioinfo->irq_flags |= IRQF_DISABLED;
+	uioinfo->handler = NULL;
+	uioinfo->irqcontrol = NULL;
+	uioinfo->open = uio_prr_open;
+	uioinfo->release = uio_prr_release;
+	uioinfo->priv = priv;
+
+	ret = uio_register_device(&pdev->dev, priv->uioinfo);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to register uio device\n");
+		goto bad1;
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	/* PRR register Adderss */
+        priv->base_reg = ioremap_nocache(res->start, resource_size(res));
+	if ( ! (priv->base_reg)) {
+		dev_err(&pdev->dev, "unable to remap PRR register\n");
+		goto bad1;
+	}
+
+	return 0;
+ bad1:
+	if (priv->base_reg) {
+		iounmap(priv->base_reg);
+	}
+
+	kfree(priv);
+ bad0:
+	return ret;
+}
+
+static int uio_prr_remove(struct platform_device *pdev)
+{
+	struct uio_platdata *priv = platform_get_drvdata(pdev);
+
+	printk(KERN_INFO "uio_prr_remove enter\n");
+
+	uio_unregister_device(priv->uioinfo);
+
+	if (priv->base_reg) {
+		iounmap(priv->base_reg);
+	}
+
+	kfree(priv);
+	return 0;
+}
+
+static struct platform_driver uio_prr_platform_driver = {
+	.probe = uio_prr_probe,
+	.remove = uio_prr_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init uio_prr_init(void)
+{
+	printk(KERN_INFO "uio_prr_init enter\n" );
+	return platform_driver_register( & uio_prr_platform_driver);
+}
+
+static void __exit uio_prr_exit(void)
+{
+	platform_driver_unregister( & uio_prr_platform_driver);
+}
+
+module_init(uio_prr_init);
+module_exit(uio_prr_exit);
+
+MODULE_AUTHOR("RenesasElectronicsCorp.");
+MODULE_DESCRIPTION("Userspace I/O driver for PRR");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRIVER_NAME);
-- 
1.9.1

