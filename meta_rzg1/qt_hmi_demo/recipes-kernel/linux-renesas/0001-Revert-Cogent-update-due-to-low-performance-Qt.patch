From d9f48cbff5bff1089ac49d010ede85548e7a8c1f Mon Sep 17 00:00:00 2001
From: TungDang <tung.dang.jy@rvc.renesas.com>
Date: Wed, 12 Oct 2016 16:35:37 +0700
Subject: [PATCH] Revert-Cogent-update-due-to-low-performance-Qt

This issue due to LVDS refresh rate is setting for HDMI screen (~52fps)
lead to Qt app using screen refresh rate not correct and low performance.
More than that, when apply Cogent patch we cannot boot kernel due to lack of vsp1
due to setting in meta-rzg-demos/common of linux-kernel.
Therefore remove Cogent update as work around to solve this issue.

Signed-off-by: TungDang <tung.dang.jy@rvc.renesas.com>
---
 .../devicetree/bindings/display/renesas,du.txt     |  16 +-
 .../devicetree/bindings/media/renesas,vsp1.txt     |  34 +-
 arch/arm/boot/dts/r8a7743-skrzg1m.dts              |  44 +-
 arch/arm/boot/dts/r8a7743.dtsi                     |  27 +-
 arch/arm/boot/dts/r8a7745.dtsi                     |  16 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_display.c        |   4 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h           |   2 +-
 drivers/gpu/drm/amd/amdgpu/dce_v10_0.c             |  14 +-
 drivers/gpu/drm/amd/amdgpu/dce_v11_0.c             |  14 +-
 drivers/gpu/drm/amd/amdgpu/dce_v8_0.c              |  14 +-
 drivers/gpu/drm/armada/armada_crtc.c               |   4 +-
 drivers/gpu/drm/armada/armada_fb.c                 |   4 +-
 drivers/gpu/drm/armada/armada_fb.h                 |   2 +-
 drivers/gpu/drm/armada/armada_overlay.c            |   2 +-
 drivers/gpu/drm/ast/ast_drv.h                      |   2 +-
 drivers/gpu/drm/ast/ast_fb.c                       |   2 +-
 drivers/gpu/drm/ast/ast_main.c                     |   4 +-
 drivers/gpu/drm/ast/ast_mode.c                     |   2 +-
 drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_crtc.c     |   2 +-
 drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_dc.c       |   2 +-
 drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_output.c   |   2 +-
 drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c    |   2 +-
 drivers/gpu/drm/bochs/bochs.h                      |   2 +-
 drivers/gpu/drm/bochs/bochs_fbdev.c                |   2 +-
 drivers/gpu/drm/bochs/bochs_kms.c                  |   2 +-
 drivers/gpu/drm/bochs/bochs_mm.c                   |   4 +-
 drivers/gpu/drm/cirrus/cirrus_drv.h                |   2 +-
 drivers/gpu/drm/cirrus/cirrus_fbdev.c              |   2 +-
 drivers/gpu/drm/cirrus/cirrus_main.c               |   4 +-
 drivers/gpu/drm/cirrus/cirrus_mode.c               |   2 +-
 drivers/gpu/drm/drm_crtc.c                         |  17 +-
 drivers/gpu/drm/drm_crtc_helper.c                  |   2 +-
 drivers/gpu/drm/drm_encoder_slave.c                |   2 +-
 drivers/gpu/drm/drm_fb_cma_helper.c                |   4 +-
 drivers/gpu/drm/drm_plane_helper.c                 |   5 +-
 drivers/gpu/drm/exynos/exynos_dp_core.c            |   2 +-
 drivers/gpu/drm/exynos/exynos_drm_crtc.c           |   2 +-
 drivers/gpu/drm/exynos/exynos_drm_dpi.c            |   2 +-
 drivers/gpu/drm/exynos/exynos_drm_dsi.c            |   2 +-
 drivers/gpu/drm/exynos/exynos_drm_fb.c             |   4 +-
 drivers/gpu/drm/exynos/exynos_drm_fb.h             |   2 +-
 drivers/gpu/drm/exynos/exynos_drm_plane.c          |   2 +-
 drivers/gpu/drm/exynos/exynos_drm_vidi.c           |   2 +-
 drivers/gpu/drm/exynos/exynos_hdmi.c               |   2 +-
 drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_crtc.c         |   2 +-
 drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_plane.c        |   2 +-
 drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_rgb.c          |   2 +-
 drivers/gpu/drm/gma500/cdv_intel_crt.c             |   2 +-
 drivers/gpu/drm/gma500/cdv_intel_dp.c              |   3 +-
 drivers/gpu/drm/gma500/cdv_intel_hdmi.c            |   2 +-
 drivers/gpu/drm/gma500/cdv_intel_lvds.c            |   2 +-
 drivers/gpu/drm/gma500/framebuffer.c               |   6 +-
 drivers/gpu/drm/gma500/mdfld_dsi_dpi.c             |   2 +-
 drivers/gpu/drm/gma500/oaktrail_hdmi.c             |   2 +-
 drivers/gpu/drm/gma500/oaktrail_lvds.c             |   2 +-
 drivers/gpu/drm/gma500/psb_intel_lvds.c            |   2 +-
 drivers/gpu/drm/gma500/psb_intel_sdvo.c            |   3 +-
 drivers/gpu/drm/i2c/tda998x_drv.c                  |   2 +-
 drivers/gpu/drm/i915/intel_crt.c                   |   2 +-
 drivers/gpu/drm/i915/intel_ddi.c                   |   2 +-
 drivers/gpu/drm/i915/intel_display.c               |   8 +-
 drivers/gpu/drm/i915/intel_dp.c                    |   2 +-
 drivers/gpu/drm/i915/intel_dp_mst.c                |   2 +-
 drivers/gpu/drm/i915/intel_dsi.c                   |   3 +-
 drivers/gpu/drm/i915/intel_dvo.c                   |   2 +-
 drivers/gpu/drm/i915/intel_hdmi.c                  |   2 +-
 drivers/gpu/drm/i915/intel_lvds.c                  |   2 +-
 drivers/gpu/drm/i915/intel_sdvo.c                  |   3 +-
 drivers/gpu/drm/i915/intel_sprite.c                |   2 +-
 drivers/gpu/drm/i915/intel_tv.c                    |   2 +-
 drivers/gpu/drm/imx/dw_hdmi-imx.c                  |   2 +-
 drivers/gpu/drm/imx/imx-drm-core.c                 |   2 +-
 drivers/gpu/drm/imx/imx-ldb.c                      |   2 +-
 drivers/gpu/drm/imx/imx-tve.c                      |   2 +-
 drivers/gpu/drm/imx/ipuv3-plane.c                  |   3 +-
 drivers/gpu/drm/imx/parallel-display.c             |   2 +-
 drivers/gpu/drm/mgag200/mgag200_drv.h              |   2 +-
 drivers/gpu/drm/mgag200/mgag200_fb.c               |   2 +-
 drivers/gpu/drm/mgag200/mgag200_main.c             |   4 +-
 drivers/gpu/drm/mgag200/mgag200_mode.c             |   2 +-
 drivers/gpu/drm/msm/mdp/mdp4/mdp4_crtc.c           |   3 +-
 drivers/gpu/drm/msm/mdp/mdp4/mdp4_dtv_encoder.c    |   2 +-
 drivers/gpu/drm/msm/mdp/mdp4/mdp4_lcdc_encoder.c   |   2 +-
 drivers/gpu/drm/msm/mdp/mdp4/mdp4_plane.c          |   3 +-
 drivers/gpu/drm/msm/mdp/mdp5/mdp5_cmd_encoder.c    |   2 +-
 drivers/gpu/drm/msm/mdp/mdp5/mdp5_crtc.c           |   3 +-
 drivers/gpu/drm/msm/mdp/mdp5/mdp5_encoder.c        |   2 +-
 drivers/gpu/drm/msm/mdp/mdp5/mdp5_plane.c          |   2 +-
 drivers/gpu/drm/msm/msm_drv.h                      |   4 +-
 drivers/gpu/drm/msm/msm_fb.c                       |   4 +-
 drivers/gpu/drm/nouveau/dispnv04/dac.c             |   3 +-
 drivers/gpu/drm/nouveau/dispnv04/dfp.c             |   2 +-
 drivers/gpu/drm/nouveau/dispnv04/tvnv17.c          |   3 +-
 drivers/gpu/drm/nouveau/nouveau_display.c          |   4 +-
 drivers/gpu/drm/nouveau/nouveau_display.h          |   2 +-
 drivers/gpu/drm/nouveau/nouveau_encoder.h          |   2 +-
 drivers/gpu/drm/nouveau/nv50_display.c             |   6 +-
 drivers/gpu/drm/omapdrm/omap_crtc.c                |   2 +-
 drivers/gpu/drm/omapdrm/omap_drv.h                 |   6 +-
 drivers/gpu/drm/omapdrm/omap_encoder.c             |   2 +-
 drivers/gpu/drm/omapdrm/omap_fb.c                  |   4 +-
 drivers/gpu/drm/omapdrm/omap_plane.c               |   2 +-
 drivers/gpu/drm/panel/panel-simple.c               |   4 +-
 drivers/gpu/drm/qxl/qxl_display.c                  |   6 +-
 drivers/gpu/drm/qxl/qxl_drv.h                      |   2 +-
 drivers/gpu/drm/qxl/qxl_fb.c                       |   2 +-
 drivers/gpu/drm/radeon/atombios_encoders.c         |  30 +-
 drivers/gpu/drm/radeon/radeon_display.c            |   4 +-
 drivers/gpu/drm/radeon/radeon_dp_mst.c             |   2 +-
 drivers/gpu/drm/radeon/radeon_legacy_encoders.c    |  15 +-
 drivers/gpu/drm/radeon/radeon_mode.h               |   2 +-
 drivers/gpu/drm/rcar-du/Kconfig                    |  16 +-
 drivers/gpu/drm/rcar-du/Makefile                   |   2 -
 drivers/gpu/drm/rcar-du/rcar_du_crtc.c             |  74 +--
 drivers/gpu/drm/rcar-du/rcar_du_crtc.h             |   2 -
 drivers/gpu/drm/rcar-du/rcar_du_drv.c              | 226 +++-----
 drivers/gpu/drm/rcar-du/rcar_du_drv.h              |  14 +-
 drivers/gpu/drm/rcar-du/rcar_du_encoder.c          |   8 +-
 drivers/gpu/drm/rcar-du/rcar_du_group.c            |  62 +--
 drivers/gpu/drm/rcar-du/rcar_du_group.h            |   4 -
 drivers/gpu/drm/rcar-du/rcar_du_hdmicon.c          |  17 +-
 drivers/gpu/drm/rcar-du/rcar_du_hdmienc.c          |  26 +-
 drivers/gpu/drm/rcar-du/rcar_du_kms.c              | 279 ++++++++--
 drivers/gpu/drm/rcar-du/rcar_du_lvdscon.c          |  53 +-
 drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.c          | 142 ++---
 drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.h          |   6 -
 drivers/gpu/drm/rcar-du/rcar_du_plane.c            | 468 +++-------------
 drivers/gpu/drm/rcar-du/rcar_du_plane.h            |  21 +-
 drivers/gpu/drm/rcar-du/rcar_du_regs.h             |  19 +-
 drivers/gpu/drm/rcar-du/rcar_du_vgacon.c           |  13 +-
 drivers/gpu/drm/rcar-du/rcar_du_vsp.c              | 401 --------------
 drivers/gpu/drm/rcar-du/rcar_du_vsp.h              |  78 ---
 drivers/gpu/drm/rcar-du/rcar_lvds_regs.h           |  26 +-
 drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c        |   2 +-
 drivers/gpu/drm/rockchip/rockchip_drm_fb.c         |   6 +-
 drivers/gpu/drm/rockchip/rockchip_drm_fb.h         |   2 +-
 drivers/gpu/drm/rockchip/rockchip_drm_vop.c        |   6 +-
 drivers/gpu/drm/shmobile/shmob_drm_crtc.c          |   2 +-
 drivers/gpu/drm/shmobile/shmob_drm_kms.c           |   2 +-
 drivers/gpu/drm/sti/sti_crtc.c                     |   2 +-
 drivers/gpu/drm/sti/sti_cursor.c                   |   2 +-
 drivers/gpu/drm/sti/sti_gdp.c                      |   2 +-
 drivers/gpu/drm/sti/sti_hqvdp.c                    |   2 +-
 drivers/gpu/drm/sti/sti_tvout.c                    |   7 +-
 drivers/gpu/drm/tegra/dc.c                         |  11 +-
 drivers/gpu/drm/tegra/drm.h                        |   2 +-
 drivers/gpu/drm/tegra/dsi.c                        |   2 +-
 drivers/gpu/drm/tegra/fb.c                         |   4 +-
 drivers/gpu/drm/tegra/hdmi.c                       |   2 +-
 drivers/gpu/drm/tegra/rgb.c                        |   2 +-
 drivers/gpu/drm/tegra/sor.c                        |   2 +-
 drivers/gpu/drm/tilcdc/tilcdc_drv.c                |   2 +-
 drivers/gpu/drm/tilcdc/tilcdc_panel.c              |   2 +-
 drivers/gpu/drm/tilcdc/tilcdc_tfp410.c             |   2 +-
 drivers/gpu/drm/udl/udl_drv.h                      |   2 +-
 drivers/gpu/drm/udl/udl_encoder.c                  |   3 +-
 drivers/gpu/drm/udl/udl_fb.c                       |   4 +-
 drivers/gpu/drm/vc4/vc4_crtc.c                     |   2 +-
 drivers/gpu/drm/vc4/vc4_hdmi.c                     |   2 +-
 drivers/gpu/drm/vc4/vc4_plane.c                    |   2 +-
 drivers/gpu/drm/virtio/virtgpu_display.c           |   8 +-
 drivers/gpu/drm/virtio/virtgpu_drv.h               |   2 +-
 drivers/gpu/drm/virtio/virtgpu_plane.c             |   2 +-
 drivers/gpu/drm/vmwgfx/vmwgfx_kms.c                |   2 +-
 drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c                |   2 +-
 drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c               |   2 +-
 drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c               |   2 +-
 drivers/media/platform/vsp1/Makefile               |   3 +-
 drivers/media/platform/vsp1/vsp1.h                 |  29 +-
 drivers/media/platform/vsp1/vsp1_bru.c             |  33 +-
 drivers/media/platform/vsp1/vsp1_bru.h             |   3 +-
 drivers/media/platform/vsp1/vsp1_dl.c              | 304 -----------
 drivers/media/platform/vsp1/vsp1_dl.h              |  42 --
 drivers/media/platform/vsp1/vsp1_drm.c             | 597 ---------------------
 drivers/media/platform/vsp1/vsp1_drm.h             |  38 --
 drivers/media/platform/vsp1/vsp1_drv.c             | 389 ++++----------
 drivers/media/platform/vsp1/vsp1_entity.c          |  31 +-
 drivers/media/platform/vsp1/vsp1_entity.h          |  14 +-
 drivers/media/platform/vsp1/vsp1_hsit.c            |   2 +-
 drivers/media/platform/vsp1/vsp1_lif.c             |  11 +-
 drivers/media/platform/vsp1/vsp1_lut.c             |   7 +-
 drivers/media/platform/vsp1/vsp1_pipe.c            | 405 --------------
 drivers/media/platform/vsp1/vsp1_pipe.h            | 134 -----
 drivers/media/platform/vsp1/vsp1_regs.h            |  32 +-
 drivers/media/platform/vsp1/vsp1_rpf.c             |  77 +--
 drivers/media/platform/vsp1/vsp1_rwpf.h            |  24 +-
 drivers/media/platform/vsp1/vsp1_sru.c             |   9 +-
 drivers/media/platform/vsp1/vsp1_uds.c             |   8 +-
 drivers/media/platform/vsp1/vsp1_video.c           | 516 ++++++++++++++----
 drivers/media/platform/vsp1/vsp1_video.h           | 111 +++-
 drivers/media/platform/vsp1/vsp1_wpf.c             |  88 +--
 include/drm/drm_crtc.h                             |  39 +-
 include/drm/drm_crtc_helper.h                      |   2 +-
 include/drm/drm_encoder_slave.h                    |   2 +-
 include/drm/drm_fb_cma_helper.h                    |   2 +-
 include/media/vsp1.h                               |  33 --
 198 files changed, 1630 insertions(+), 3990 deletions(-)
 delete mode 100644 drivers/gpu/drm/rcar-du/rcar_du_vsp.c
 delete mode 100644 drivers/gpu/drm/rcar-du/rcar_du_vsp.h
 delete mode 100644 drivers/media/platform/vsp1/vsp1_dl.c
 delete mode 100644 drivers/media/platform/vsp1/vsp1_dl.h
 delete mode 100644 drivers/media/platform/vsp1/vsp1_drm.c
 delete mode 100644 drivers/media/platform/vsp1/vsp1_drm.h
 delete mode 100644 drivers/media/platform/vsp1/vsp1_pipe.c
 delete mode 100644 drivers/media/platform/vsp1/vsp1_pipe.h
 delete mode 100644 include/media/vsp1.h

diff --git a/Documentation/devicetree/bindings/display/renesas,du.txt b/Documentation/devicetree/bindings/display/renesas,du.txt
index 0d30e42..eccd4f4 100644
--- a/Documentation/devicetree/bindings/display/renesas,du.txt
+++ b/Documentation/devicetree/bindings/display/renesas,du.txt
@@ -8,7 +8,6 @@ Required Properties:
     - "renesas,du-r8a7791" for R8A7791 (R-Car M2-W) compatible DU
     - "renesas,du-r8a7793" for R8A7793 (R-Car M2-N) compatible DU
     - "renesas,du-r8a7794" for R8A7794 (R-Car E2) compatible DU
-    - "renesas,du-r8a7795" for R8A7795 (R-Car H3) compatible DU

   - reg: A list of base address and length of each memory resource, one for
     each entry in the reg-names property.
@@ -25,7 +24,7 @@ Required Properties:
   - clock-names: Name of the clocks. This property is model-dependent.
     - R8A7779 uses a single functional clock. The clock doesn't need to be
       named.
-    - R8A779[01345] use one functional clock per channel and one clock per LVDS
+    - R8A779[0134] use one functional clock per channel and one clock per LVDS
       encoder (if available). The functional clocks must be named "du.x" with
       "x" being the channel numerical index. The LVDS clocks must be named
       "lvds.x" with "x" being the LVDS encoder numerical index.
@@ -42,14 +41,13 @@ bindings specified in Documentation/devicetree/bindings/graph.txt.
 The following table lists for each supported model the port number
 corresponding to each DU output.

-		Port 0		Port1		Port2		Port3
+		Port 0		Port1		Port2
 -----------------------------------------------------------------------------
- R8A7779 (H1)	DPAD 0		DPAD 1		-		-
- R8A7790 (H2)	DPAD		LVDS 0		LVDS 1		-
- R8A7791 (M2-W)	DPAD		LVDS 0		-		-
- R8A7793 (M2-N)	DPAD		LVDS 0		-		-
- R8A7794 (E2)	DPAD 0		DPAD 1		-		-
- R8A7795 (H3)	DPAD		HDMI 0		HDMI 1		LVDS
+ R8A7779 (H1)	DPAD 0		DPAD 1		-
+ R8A7790 (H2)	DPAD		LVDS 0		LVDS 1
+ R8A7791 (M2-W)	DPAD		LVDS 0		-
+ R8A7793 (M2-N)	DPAD		LVDS 0		-
+ R8A7794 (E2)	DPAD 0		DPAD 1		-


 Example: R8A7790 (R-Car H2) DU
diff --git a/Documentation/devicetree/bindings/media/renesas,vsp1.txt b/Documentation/devicetree/bindings/media/renesas,vsp1.txt
index 627405ab..87fe08a 100644
--- a/Documentation/devicetree/bindings/media/renesas,vsp1.txt
+++ b/Documentation/devicetree/bindings/media/renesas,vsp1.txt
@@ -1,18 +1,30 @@
-* Renesas VSP Video Processing Engine
+* Renesas VSP1 Video Processing Engine

-The VSP is a video processing engine that supports up-/down-scaling, alpha
+The VSP1 is a video processing engine that supports up-/down-scaling, alpha
 blending, color space conversion and various other image processing features.
 It can be found in the Renesas R-Car second generation SoCs.

 Required properties:

-  - compatible: Must contain one of the following values
-    - "renesas,vsp1" for the R-Car Gen2 VSP1
-    - "renesas,vsp2" for the R-Car Gen3 VSP2
+  - compatible: Must contain "renesas,vsp1"

-  - reg: Base address and length of the registers block for the VSP.
-  - interrupts: VSP interrupt specifier.
-  - clocks: A phandle + clock-specifier pair for the VSP functional clock.
+  - reg: Base address and length of the registers block for the VSP1.
+  - interrupts: VSP1 interrupt specifier.
+  - clocks: A phandle + clock-specifier pair for the VSP1 functional clock.
+
+  - renesas,#rpf: Number of Read Pixel Formatter (RPF) modules in the VSP1.
+  - renesas,#uds: Number of Up Down Scaler (UDS) modules in the VSP1.
+  - renesas,#wpf: Number of Write Pixel Formatter (WPF) modules in the VSP1.
+
+
+Optional properties:
+
+  - renesas,has-lif: Boolean, indicates that the LCD Interface (LIF) module is
+    available.
+  - renesas,has-lut: Boolean, indicates that the Look Up Table (LUT) module is
+    available.
+  - renesas,has-sru: Boolean, indicates that the Super Resolution Unit (SRU)
+    module is available.


 Example: R8A7790 (R-Car H2) VSP1-S node
@@ -22,4 +34,10 @@ Example: R8A7790 (R-Car H2) VSP1-S node
		reg = <0 0xfe928000 0 0x8000>;
		interrupts = <0 267 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&mstp1_clks R8A7790_CLK_VSP1_S>;
+
+		renesas,has-lut;
+		renesas,has-sru;
+		renesas,#rpf = <5>;
+		renesas,#uds = <3>;
+		renesas,#wpf = <4>;
	};
diff --git a/arch/arm/boot/dts/r8a7743-skrzg1m.dts b/arch/arm/boot/dts/r8a7743-skrzg1m.dts
index 1168cc2..70c2509 100644
--- a/arch/arm/boot/dts/r8a7743-skrzg1m.dts
+++ b/arch/arm/boot/dts/r8a7743-skrzg1m.dts
@@ -143,15 +143,6 @@
			  1800000 0>;
	};

-	vcc_lvds: regulator@4 {
-		compatible = "regulator-fixed";
-
-		regulator-name = "panel vcc";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		regulator-always-on;
-	};
-
	hdmi-out {
		compatible = "hdmi-connector";
		type = "a";
@@ -163,30 +154,18 @@
		};
	};

-	panel_hannstar: panel@0 {
-		compatible = "hannstar,hsd070pww1", "simple-panel";
-		power-supply = <&vcc_lvds>;
-
-		ports {
-			#address-cells = <1>;
-			#size-cells = <0>;
-
-			port@0 {
-				reg = <0>;
-				panel_input: endpoint {
-					reg = <0>;
-					remote-endpoint = <&du_out_lvds0>;
-				};
-			};
-		};
-	};
-
	x3_clk: x3-clock {
		compatible = "fixed-clock";
		#clock-cells = <0>;
		clock-frequency = <148500000>;
	};

+	x16_clk: x16-clock {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <74250000>;
+	};
+
	x14_clk: x14-clock {
		compatible = "fixed-clock";
		#clock-cells = <0>;
@@ -563,19 +542,14 @@
	clocks = <&mstp7_clks R8A7743_CLK_DU0>,
		 <&mstp7_clks R8A7743_CLK_DU1>,
		 <&mstp7_clks R8A7743_CLK_LVDS0>,
-		 <&x3_clk>;
+		 <&x3_clk>, <&x16_clk>;
	clock-names = "du.0", "du.1", "lvds.0",
-		      "dclkin.0";
+		      "dclkin.0", "dclkin.1";

	ports {
-		port@0 {
-			endpoint {
-				remote-endpoint = <&adv7511_in>;
-			};
-		};
		port@1 {
			endpoint {
-				remote-endpoint = <&panel_input>;
+				remote-endpoint = <&adv7511_in>;
			};
		};
	};
diff --git a/arch/arm/boot/dts/r8a7743.dtsi b/arch/arm/boot/dts/r8a7743.dtsi
index 1e5e0f6..b2ec2ba 100644
--- a/arch/arm/boot/dts/r8a7743.dtsi
+++ b/arch/arm/boot/dts/r8a7743.dtsi
@@ -936,7 +936,7 @@
		power-domains = <&sysc R8A7743_PD_ALWAYS_ON>;
	};

-	vspm@fe928000 {
+	vsps@fe928000 {
		compatible = "renesas,vspm-vsps","renesas-vspm";
		reg = <0 0xfe928000 0 0x7404>;
		interrupts = <0 267 IRQ_TYPE_LEVEL_HIGH>;
@@ -944,32 +944,16 @@
		power-domains = <&sysc R8A7743_PD_ALWAYS_ON>;
	};

-        vspm@fe930000 {
-                compatible = "renesas,vspm-vspdu0","renesas-vspm";
-                reg = <0 0xfe930000 0 0x7404>;
-                interrupts = <0 246 IRQ_TYPE_LEVEL_HIGH>;
-                clocks = <&mstp1_clks R8A7743_CLK_VSP1_DU0>;
-                power-domains = <&sysc R8A7743_PD_ALWAYS_ON>;
-        };
-
-        vspm@fe938000 {
-                compatible = "renesas,vspdu1","renesas-vspm";
-                reg = <0 0xfe938000 0 0x7404>;
-                interrupts = <0 247 IRQ_TYPE_LEVEL_HIGH>;
-                clocks = <&mstp1_clks R8A7743_CLK_VSP1_DU1>;
-                power-domains = <&sysc R8A7743_PD_ALWAYS_ON>;
-        };
-
-	vspd0: vspd0@fe930000 {
-		compatible = "renesas,vsp2";
+	vspd0@fe930000 {
+		compatible = "renesas,vspm-vspd0","renesas-vspm";
		reg = <0 0xfe930000 0 0x7404>;
		interrupts = <0 246 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&mstp1_clks R8A7743_CLK_VSP1_DU0>;
		power-domains = <&sysc R8A7743_PD_ALWAYS_ON>;
	};

-	vspd1: vspd1@fe938000 {
-		compatible = "renesas,vsp2";
+	vspd1@fe938000 {
+		compatible = "renesas,vspm-vspd1","renesas-vspm";
		reg = <0 0xfe938000 0 0x7404>;
		interrupts = <0 247 IRQ_TYPE_LEVEL_HIGH>;
		clocks = <&mstp1_clks R8A7743_CLK_VSP1_DU1>;
@@ -1005,7 +989,6 @@
		clock-names = "du.0", "du.1", "lvds.0";
		status = "disabled";

-		vsps = <&vspd0 &vspd1>;
		ports {
			#address-cells = <1>;
			#size-cells = <0>;
diff --git a/arch/arm/boot/dts/r8a7745.dtsi b/arch/arm/boot/dts/r8a7745.dtsi
index 90bd4f0..58d1157 100644
--- a/arch/arm/boot/dts/r8a7745.dtsi
+++ b/arch/arm/boot/dts/r8a7745.dtsi
@@ -901,7 +901,7 @@
		};
	};

-	vspm@fea00000 {
+	tddmac@fea00000 {
		compatible = "renesas,vspm-tddmac", "renesas-vspm";
		reg = <0 0xfea00000 0 0x0200>;
		interrupts = <0 285 IRQ_TYPE_LEVEL_HIGH>;
@@ -909,7 +909,7 @@
		power-domains = <&sysc R8A7745_PD_ALWAYS_ON>;
	};

-	vspm@fe928000 {
+	vsps@fe928000 {
		compatible = "renesas,vspm-vsps", "renesas-vspm";
		reg = <0 0xfe928000 0 0x7404>;
		interrupts = <0 267 IRQ_TYPE_LEVEL_HIGH>;
@@ -917,7 +917,7 @@
		power-domains = <&sysc R8A7745_PD_ALWAYS_ON>;
	};

-	vspm@fe930000 {
+	vspd0@fe930000 {
		compatible = "renesas,vspm-vspd0", "renesas-vspm";
		reg = <0 0xfe930000 0 0x7404>;
		interrupts = <0 246 IRQ_TYPE_LEVEL_HIGH>;
@@ -925,14 +925,6 @@
		power-domains = <&sysc R8A7745_PD_ALWAYS_ON>;
	};

-	vspdu0: vspdu0@fe930000 {
-		compatible = "renesas,vsp2";
-		reg = <0 0xfe930000 0 0x7404>;
-		interrupts = <0 246 IRQ_TYPE_LEVEL_HIGH>;
-		clocks = <&mstp1_clks R8A7745_CLK_VSP1_DU0>;
-		power-domains = <&sysc R8A7745_PD_ALWAYS_ON>;
-	};
-
	fdp0: fdpm@fe940000 {
		compatible = "renesas,fdp1";
		reg = <0 0xfe940000 0 0x2400>;
@@ -952,8 +944,6 @@
		clock-names = "du.0", "du.1";
		status = "disabled";

-		vsps = <&vspdu0>;
-
		ports {
			#address-cells = <1>;
			#size-cells = <0>;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_display.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_display.c
index 1846d65..82903ca 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_display.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_display.c
@@ -530,7 +530,7 @@ static const struct drm_framebuffer_funcs amdgpu_fb_funcs = {
 int
 amdgpu_framebuffer_init(struct drm_device *dev,
			struct amdgpu_framebuffer *rfb,
-			const struct drm_mode_fb_cmd2 *mode_cmd,
+			struct drm_mode_fb_cmd2 *mode_cmd,
			struct drm_gem_object *obj)
 {
	int ret;
@@ -547,7 +547,7 @@ amdgpu_framebuffer_init(struct drm_device *dev,
 static struct drm_framebuffer *
 amdgpu_user_framebuffer_create(struct drm_device *dev,
			       struct drm_file *file_priv,
-			       const struct drm_mode_fb_cmd2 *mode_cmd)
+			       struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_gem_object *obj;
	struct amdgpu_framebuffer *amdgpu_fb;
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
index a53d756..064ebb3 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_mode.h
@@ -556,7 +556,7 @@ int amdgpu_get_crtc_scanoutpos(struct drm_device *dev, unsigned int pipe,

 int amdgpu_framebuffer_init(struct drm_device *dev,
			     struct amdgpu_framebuffer *rfb,
-			     const struct drm_mode_fb_cmd2 *mode_cmd,
+			     struct drm_mode_fb_cmd2 *mode_cmd,
			     struct drm_gem_object *obj);

 int amdgpufb_remove(struct drm_device *dev, struct drm_framebuffer *fb);
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
index 093599a..4dcc8fb 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c
@@ -3729,7 +3729,7 @@ static void dce_v10_0_encoder_add(struct amdgpu_device *adev,
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
		drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-				 DRM_MODE_ENCODER_DAC, NULL);
+				 DRM_MODE_ENCODER_DAC);
		drm_encoder_helper_add(encoder, &dce_v10_0_dac_helper_funcs);
		break;
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
@@ -3740,15 +3740,15 @@ static void dce_v10_0_encoder_add(struct amdgpu_device *adev,
		if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
			amdgpu_encoder->rmx_type = RMX_FULL;
			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+					 DRM_MODE_ENCODER_LVDS);
			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_lcd_info(amdgpu_encoder);
		} else if (amdgpu_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT)) {
			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+					 DRM_MODE_ENCODER_DAC);
			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_dig_info(amdgpu_encoder);
		} else {
			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+					 DRM_MODE_ENCODER_TMDS);
			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_dig_info(amdgpu_encoder);
		}
		drm_encoder_helper_add(encoder, &dce_v10_0_dig_helper_funcs);
@@ -3766,13 +3766,13 @@ static void dce_v10_0_encoder_add(struct amdgpu_device *adev,
		amdgpu_encoder->is_ext_encoder = true;
		if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+					 DRM_MODE_ENCODER_LVDS);
		else if (amdgpu_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT))
			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+					 DRM_MODE_ENCODER_DAC);
		else
			drm_encoder_init(dev, encoder, &dce_v10_0_encoder_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+					 DRM_MODE_ENCODER_TMDS);
		drm_encoder_helper_add(encoder, &dce_v10_0_ext_helper_funcs);
		break;
	}
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
index 8701661..8f1e511 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c
@@ -3722,7 +3722,7 @@ static void dce_v11_0_encoder_add(struct amdgpu_device *adev,
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
		drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-				 DRM_MODE_ENCODER_DAC, NULL);
+				 DRM_MODE_ENCODER_DAC);
		drm_encoder_helper_add(encoder, &dce_v11_0_dac_helper_funcs);
		break;
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
@@ -3733,15 +3733,15 @@ static void dce_v11_0_encoder_add(struct amdgpu_device *adev,
		if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
			amdgpu_encoder->rmx_type = RMX_FULL;
			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+					 DRM_MODE_ENCODER_LVDS);
			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_lcd_info(amdgpu_encoder);
		} else if (amdgpu_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT)) {
			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+					 DRM_MODE_ENCODER_DAC);
			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_dig_info(amdgpu_encoder);
		} else {
			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+					 DRM_MODE_ENCODER_TMDS);
			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_dig_info(amdgpu_encoder);
		}
		drm_encoder_helper_add(encoder, &dce_v11_0_dig_helper_funcs);
@@ -3759,13 +3759,13 @@ static void dce_v11_0_encoder_add(struct amdgpu_device *adev,
		amdgpu_encoder->is_ext_encoder = true;
		if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+					 DRM_MODE_ENCODER_LVDS);
		else if (amdgpu_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT))
			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+					 DRM_MODE_ENCODER_DAC);
		else
			drm_encoder_init(dev, encoder, &dce_v11_0_encoder_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+					 DRM_MODE_ENCODER_TMDS);
		drm_encoder_helper_add(encoder, &dce_v11_0_ext_helper_funcs);
		break;
	}
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
index d0e128c..42d954d 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
@@ -3659,7 +3659,7 @@ static void dce_v8_0_encoder_add(struct amdgpu_device *adev,
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
		drm_encoder_init(dev, encoder, &dce_v8_0_encoder_funcs,
-				 DRM_MODE_ENCODER_DAC, NULL);
+				 DRM_MODE_ENCODER_DAC);
		drm_encoder_helper_add(encoder, &dce_v8_0_dac_helper_funcs);
		break;
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
@@ -3670,15 +3670,15 @@ static void dce_v8_0_encoder_add(struct amdgpu_device *adev,
		if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
			amdgpu_encoder->rmx_type = RMX_FULL;
			drm_encoder_init(dev, encoder, &dce_v8_0_encoder_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+					 DRM_MODE_ENCODER_LVDS);
			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_lcd_info(amdgpu_encoder);
		} else if (amdgpu_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT)) {
			drm_encoder_init(dev, encoder, &dce_v8_0_encoder_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+					 DRM_MODE_ENCODER_DAC);
			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_dig_info(amdgpu_encoder);
		} else {
			drm_encoder_init(dev, encoder, &dce_v8_0_encoder_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+					 DRM_MODE_ENCODER_TMDS);
			amdgpu_encoder->enc_priv = amdgpu_atombios_encoder_get_dig_info(amdgpu_encoder);
		}
		drm_encoder_helper_add(encoder, &dce_v8_0_dig_helper_funcs);
@@ -3696,13 +3696,13 @@ static void dce_v8_0_encoder_add(struct amdgpu_device *adev,
		amdgpu_encoder->is_ext_encoder = true;
		if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
			drm_encoder_init(dev, encoder, &dce_v8_0_encoder_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+					 DRM_MODE_ENCODER_LVDS);
		else if (amdgpu_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT))
			drm_encoder_init(dev, encoder, &dce_v8_0_encoder_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+					 DRM_MODE_ENCODER_DAC);
		else
			drm_encoder_init(dev, encoder, &dce_v8_0_encoder_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+					 DRM_MODE_ENCODER_TMDS);
		drm_encoder_helper_add(encoder, &dce_v8_0_ext_helper_funcs);
		break;
	}
diff --git a/drivers/gpu/drm/armada/armada_crtc.c b/drivers/gpu/drm/armada/armada_crtc.c
index 9bdc28c..cebcab5 100644
--- a/drivers/gpu/drm/armada/armada_crtc.c
+++ b/drivers/gpu/drm/armada/armada_crtc.c
@@ -1216,14 +1216,14 @@ static int armada_drm_crtc_create(struct drm_device *drm, struct device *dev,
				       &armada_primary_plane_funcs,
				       armada_primary_formats,
				       ARRAY_SIZE(armada_primary_formats),
-				       DRM_PLANE_TYPE_PRIMARY, NULL);
+				       DRM_PLANE_TYPE_PRIMARY);
	if (ret) {
		kfree(primary);
		return ret;
	}

	ret = drm_crtc_init_with_planes(drm, &dcrtc->crtc, &primary->base, NULL,
-					&armada_crtc_funcs, NULL);
+					&armada_crtc_funcs);
	if (ret)
		goto err_crtc_init;

diff --git a/drivers/gpu/drm/armada/armada_fb.c b/drivers/gpu/drm/armada/armada_fb.c
index 5fa4bf2..1c90969 100644
--- a/drivers/gpu/drm/armada/armada_fb.c
+++ b/drivers/gpu/drm/armada/armada_fb.c
@@ -35,7 +35,7 @@ static const struct drm_framebuffer_funcs armada_fb_funcs = {
 };

 struct armada_framebuffer *armada_framebuffer_create(struct drm_device *dev,
-	const struct drm_mode_fb_cmd2 *mode, struct armada_gem_object *obj)
+	struct drm_mode_fb_cmd2 *mode, struct armada_gem_object *obj)
 {
	struct armada_framebuffer *dfb;
	uint8_t format, config;
@@ -101,7 +101,7 @@ struct armada_framebuffer *armada_framebuffer_create(struct drm_device *dev,
 }

 static struct drm_framebuffer *armada_fb_create(struct drm_device *dev,
-	struct drm_file *dfile, const struct drm_mode_fb_cmd2 *mode)
+	struct drm_file *dfile, struct drm_mode_fb_cmd2 *mode)
 {
	struct armada_gem_object *obj;
	struct armada_framebuffer *dfb;
diff --git a/drivers/gpu/drm/armada/armada_fb.h b/drivers/gpu/drm/armada/armada_fb.h
index 48073c4..ce3f12e 100644
--- a/drivers/gpu/drm/armada/armada_fb.h
+++ b/drivers/gpu/drm/armada/armada_fb.h
@@ -19,6 +19,6 @@ struct armada_framebuffer {
 #define drm_fb_obj(fb) drm_fb_to_armada_fb(fb)->obj

 struct armada_framebuffer *armada_framebuffer_create(struct drm_device *,
-	const struct drm_mode_fb_cmd2 *, struct armada_gem_object *);
+	struct drm_mode_fb_cmd2 *, struct armada_gem_object *);

 #endif
diff --git a/drivers/gpu/drm/armada/armada_overlay.c b/drivers/gpu/drm/armada/armada_overlay.c
index 148e8a4..5c22b38 100644
--- a/drivers/gpu/drm/armada/armada_overlay.c
+++ b/drivers/gpu/drm/armada/armada_overlay.c
@@ -460,7 +460,7 @@ int armada_overlay_plane_create(struct drm_device *dev, unsigned long crtcs)
				       &armada_ovl_plane_funcs,
				       armada_ovl_formats,
				       ARRAY_SIZE(armada_ovl_formats),
-				       DRM_PLANE_TYPE_OVERLAY, NULL);
+				       DRM_PLANE_TYPE_OVERLAY);
	if (ret) {
		kfree(dplane);
		return ret;
diff --git a/drivers/gpu/drm/ast/ast_drv.h b/drivers/gpu/drm/ast/ast_drv.h
index e227f8a..05f6522 100644
--- a/drivers/gpu/drm/ast/ast_drv.h
+++ b/drivers/gpu/drm/ast/ast_drv.h
@@ -309,7 +309,7 @@ extern void ast_mode_fini(struct drm_device *dev);

 int ast_framebuffer_init(struct drm_device *dev,
			 struct ast_framebuffer *ast_fb,
-			 const struct drm_mode_fb_cmd2 *mode_cmd,
+			 struct drm_mode_fb_cmd2 *mode_cmd,
			 struct drm_gem_object *obj);

 int ast_fbdev_init(struct drm_device *dev);
diff --git a/drivers/gpu/drm/ast/ast_fb.c b/drivers/gpu/drm/ast/ast_fb.c
index 5320f8c..a37e7ea 100644
--- a/drivers/gpu/drm/ast/ast_fb.c
+++ b/drivers/gpu/drm/ast/ast_fb.c
@@ -163,7 +163,7 @@ static struct fb_ops astfb_ops = {
 };

 static int astfb_create_object(struct ast_fbdev *afbdev,
-			       const struct drm_mode_fb_cmd2 *mode_cmd,
+			       struct drm_mode_fb_cmd2 *mode_cmd,
			       struct drm_gem_object **gobj_p)
 {
	struct drm_device *dev = afbdev->helper.dev;
diff --git a/drivers/gpu/drm/ast/ast_main.c b/drivers/gpu/drm/ast/ast_main.c
index b1480ac..e0b4586 100644
--- a/drivers/gpu/drm/ast/ast_main.c
+++ b/drivers/gpu/drm/ast/ast_main.c
@@ -309,7 +309,7 @@ static const struct drm_framebuffer_funcs ast_fb_funcs = {

 int ast_framebuffer_init(struct drm_device *dev,
			 struct ast_framebuffer *ast_fb,
-			 const struct drm_mode_fb_cmd2 *mode_cmd,
+			 struct drm_mode_fb_cmd2 *mode_cmd,
			 struct drm_gem_object *obj)
 {
	int ret;
@@ -327,7 +327,7 @@ int ast_framebuffer_init(struct drm_device *dev,
 static struct drm_framebuffer *
 ast_user_framebuffer_create(struct drm_device *dev,
	       struct drm_file *filp,
-	       const struct drm_mode_fb_cmd2 *mode_cmd)
+	       struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_gem_object *obj;
	struct ast_framebuffer *ast_fb;
diff --git a/drivers/gpu/drm/ast/ast_mode.c b/drivers/gpu/drm/ast/ast_mode.c
index 0123458..69d19f3 100644
--- a/drivers/gpu/drm/ast/ast_mode.c
+++ b/drivers/gpu/drm/ast/ast_mode.c
@@ -751,7 +751,7 @@ static int ast_encoder_init(struct drm_device *dev)
		return -ENOMEM;

	drm_encoder_init(dev, &ast_encoder->base, &ast_enc_funcs,
-			 DRM_MODE_ENCODER_DAC, NULL);
+			 DRM_MODE_ENCODER_DAC);
	drm_encoder_helper_add(&ast_encoder->base, &ast_enc_helper_funcs);

	ast_encoder->base.possible_crtcs = 1;
diff --git a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_crtc.c b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_crtc.c
index 468a14f..9f6e234 100644
--- a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_crtc.c
+++ b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_crtc.c
@@ -344,7 +344,7 @@ int atmel_hlcdc_crtc_create(struct drm_device *dev)
	ret = drm_crtc_init_with_planes(dev, &crtc->base,
				&planes->primary->base,
				planes->cursor ? &planes->cursor->base : NULL,
-				&atmel_hlcdc_crtc_funcs, NULL);
+				&atmel_hlcdc_crtc_funcs);
	if (ret < 0)
		goto fail;

diff --git a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_dc.c b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_dc.c
index 8168954..244df0a 100644
--- a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_dc.c
+++ b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_dc.c
@@ -402,7 +402,7 @@ static irqreturn_t atmel_hlcdc_dc_irq_handler(int irq, void *data)
 }

 static struct drm_framebuffer *atmel_hlcdc_fb_create(struct drm_device *dev,
-		struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd)
+		struct drm_file *file_priv, struct drm_mode_fb_cmd2 *mode_cmd)
 {
	return drm_fb_cma_create(dev, file_priv, mode_cmd);
 }
diff --git a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_output.c b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_output.c
index d112900..067e4c1 100644
--- a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_output.c
+++ b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_output.c
@@ -256,7 +256,7 @@ static int atmel_hlcdc_create_panel_output(struct drm_device *dev,
			       &atmel_hlcdc_panel_encoder_helper_funcs);
	ret = drm_encoder_init(dev, &panel->base.encoder,
			       &atmel_hlcdc_panel_encoder_funcs,
-			       DRM_MODE_ENCODER_LVDS, NULL);
+			       DRM_MODE_ENCODER_LVDS);
	if (ret)
		return ret;

diff --git a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c
index 1ffe9c3..d0299ae 100644
--- a/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c
+++ b/drivers/gpu/drm/atmel-hlcdc/atmel_hlcdc_plane.c
@@ -941,7 +941,7 @@ atmel_hlcdc_plane_create(struct drm_device *dev,
	ret = drm_universal_plane_init(dev, &plane->base, 0,
				       &layer_plane_funcs,
				       desc->formats->formats,
-				       desc->formats->nformats, type, NULL);
+				       desc->formats->nformats, type);
	if (ret)
		return ERR_PTR(ret);

diff --git a/drivers/gpu/drm/bochs/bochs.h b/drivers/gpu/drm/bochs/bochs.h
index 19b5ada..71f2687 100644
--- a/drivers/gpu/drm/bochs/bochs.h
+++ b/drivers/gpu/drm/bochs/bochs.h
@@ -149,7 +149,7 @@ int bochs_dumb_mmap_offset(struct drm_file *file, struct drm_device *dev,

 int bochs_framebuffer_init(struct drm_device *dev,
			   struct bochs_framebuffer *gfb,
-			   const struct drm_mode_fb_cmd2 *mode_cmd,
+			   struct drm_mode_fb_cmd2 *mode_cmd,
			   struct drm_gem_object *obj);
 int bochs_bo_pin(struct bochs_bo *bo, u32 pl_flag, u64 *gpu_addr);
 int bochs_bo_unpin(struct bochs_bo *bo);
diff --git a/drivers/gpu/drm/bochs/bochs_fbdev.c b/drivers/gpu/drm/bochs/bochs_fbdev.c
index 7520bf8..09a0637 100644
--- a/drivers/gpu/drm/bochs/bochs_fbdev.c
+++ b/drivers/gpu/drm/bochs/bochs_fbdev.c
@@ -34,7 +34,7 @@ static struct fb_ops bochsfb_ops = {
 };

 static int bochsfb_create_object(struct bochs_device *bochs,
-				 const struct drm_mode_fb_cmd2 *mode_cmd,
+				 struct drm_mode_fb_cmd2 *mode_cmd,
				 struct drm_gem_object **gobj_p)
 {
	struct drm_device *dev = bochs->dev;
diff --git a/drivers/gpu/drm/bochs/bochs_kms.c b/drivers/gpu/drm/bochs/bochs_kms.c
index a88be6d..26bcd03 100644
--- a/drivers/gpu/drm/bochs/bochs_kms.c
+++ b/drivers/gpu/drm/bochs/bochs_kms.c
@@ -196,7 +196,7 @@ static void bochs_encoder_init(struct drm_device *dev)

	encoder->possible_crtcs = 0x1;
	drm_encoder_init(dev, encoder, &bochs_encoder_encoder_funcs,
-			 DRM_MODE_ENCODER_DAC, NULL);
+			 DRM_MODE_ENCODER_DAC);
	drm_encoder_helper_add(encoder, &bochs_encoder_helper_funcs);
 }

diff --git a/drivers/gpu/drm/bochs/bochs_mm.c b/drivers/gpu/drm/bochs/bochs_mm.c
index d812ad0..f69e6bf 100644
--- a/drivers/gpu/drm/bochs/bochs_mm.c
+++ b/drivers/gpu/drm/bochs/bochs_mm.c
@@ -484,7 +484,7 @@ static const struct drm_framebuffer_funcs bochs_fb_funcs = {

 int bochs_framebuffer_init(struct drm_device *dev,
			   struct bochs_framebuffer *gfb,
-			   const struct drm_mode_fb_cmd2 *mode_cmd,
+			   struct drm_mode_fb_cmd2 *mode_cmd,
			   struct drm_gem_object *obj)
 {
	int ret;
@@ -502,7 +502,7 @@ int bochs_framebuffer_init(struct drm_device *dev,
 static struct drm_framebuffer *
 bochs_user_framebuffer_create(struct drm_device *dev,
			      struct drm_file *filp,
-			      const struct drm_mode_fb_cmd2 *mode_cmd)
+			      struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_gem_object *obj;
	struct bochs_framebuffer *bochs_fb;
diff --git a/drivers/gpu/drm/cirrus/cirrus_drv.h b/drivers/gpu/drm/cirrus/cirrus_drv.h
index 1370a51..7050615 100644
--- a/drivers/gpu/drm/cirrus/cirrus_drv.h
+++ b/drivers/gpu/drm/cirrus/cirrus_drv.h
@@ -207,7 +207,7 @@ int cirrus_dumb_create(struct drm_file *file,

 int cirrus_framebuffer_init(struct drm_device *dev,
			   struct cirrus_framebuffer *gfb,
-			    const struct drm_mode_fb_cmd2 *mode_cmd,
+			    struct drm_mode_fb_cmd2 *mode_cmd,
			    struct drm_gem_object *obj);

 bool cirrus_check_framebuffer(struct cirrus_device *cdev, int width, int height,
diff --git a/drivers/gpu/drm/cirrus/cirrus_fbdev.c b/drivers/gpu/drm/cirrus/cirrus_fbdev.c
index 3b5be72..589103b 100644
--- a/drivers/gpu/drm/cirrus/cirrus_fbdev.c
+++ b/drivers/gpu/drm/cirrus/cirrus_fbdev.c
@@ -135,7 +135,7 @@ static struct fb_ops cirrusfb_ops = {
 };

 static int cirrusfb_create_object(struct cirrus_fbdev *afbdev,
-			       const struct drm_mode_fb_cmd2 *mode_cmd,
+			       struct drm_mode_fb_cmd2 *mode_cmd,
			       struct drm_gem_object **gobj_p)
 {
	struct drm_device *dev = afbdev->helper.dev;
diff --git a/drivers/gpu/drm/cirrus/cirrus_main.c b/drivers/gpu/drm/cirrus/cirrus_main.c
index 0907715..055fd86 100644
--- a/drivers/gpu/drm/cirrus/cirrus_main.c
+++ b/drivers/gpu/drm/cirrus/cirrus_main.c
@@ -29,7 +29,7 @@ static const struct drm_framebuffer_funcs cirrus_fb_funcs = {

 int cirrus_framebuffer_init(struct drm_device *dev,
			    struct cirrus_framebuffer *gfb,
-			    const struct drm_mode_fb_cmd2 *mode_cmd,
+			    struct drm_mode_fb_cmd2 *mode_cmd,
			    struct drm_gem_object *obj)
 {
	int ret;
@@ -47,7 +47,7 @@ int cirrus_framebuffer_init(struct drm_device *dev,
 static struct drm_framebuffer *
 cirrus_user_framebuffer_create(struct drm_device *dev,
			       struct drm_file *filp,
-			       const struct drm_mode_fb_cmd2 *mode_cmd)
+			       struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct cirrus_device *cdev = dev->dev_private;
	struct drm_gem_object *obj;
diff --git a/drivers/gpu/drm/cirrus/cirrus_mode.c b/drivers/gpu/drm/cirrus/cirrus_mode.c
index 276719e..61385f2 100644
--- a/drivers/gpu/drm/cirrus/cirrus_mode.c
+++ b/drivers/gpu/drm/cirrus/cirrus_mode.c
@@ -489,7 +489,7 @@ static struct drm_encoder *cirrus_encoder_init(struct drm_device *dev)
	encoder->possible_crtcs = 0x1;

	drm_encoder_init(dev, encoder, &cirrus_encoder_encoder_funcs,
-			 DRM_MODE_ENCODER_DAC, NULL);
+			 DRM_MODE_ENCODER_DAC);
	drm_encoder_helper_add(encoder, &cirrus_encoder_helper_funcs);

	return encoder;
diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c
index 1887c42..24c5434 100644
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@ -45,7 +45,7 @@

 static struct drm_framebuffer *
 internal_framebuffer_create(struct drm_device *dev,
-			    const struct drm_mode_fb_cmd2 *r,
+			    struct drm_mode_fb_cmd2 *r,
			    struct drm_file *file_priv);

 /* Avoid boilerplate.  I'm tired of typing. */
@@ -657,7 +657,6 @@ DEFINE_WW_CLASS(crtc_ww_class);
  * @primary: Primary plane for CRTC
  * @cursor: Cursor plane for CRTC
  * @funcs: callbacks for the new CRTC
- * @name: printf style format string for the CRTC name, or NULL for default name
  *
  * Inits a new object created as base part of a driver crtc object.
  *
@@ -667,8 +666,7 @@ DEFINE_WW_CLASS(crtc_ww_class);
 int drm_crtc_init_with_planes(struct drm_device *dev, struct drm_crtc *crtc,
			      struct drm_plane *primary,
			      struct drm_plane *cursor,
-			      const struct drm_crtc_funcs *funcs,
-			      const char *name, ...)
+			      const struct drm_crtc_funcs *funcs)
 {
	struct drm_mode_config *config = &dev->mode_config;
	int ret;
@@ -1077,7 +1075,6 @@ EXPORT_SYMBOL(drm_connector_unplug_all);
  * @encoder: the encoder to init
  * @funcs: callbacks for this encoder
  * @encoder_type: user visible type of the encoder
- * @name: printf style format string for the encoder name, or NULL for default name
  *
  * Initialises a preallocated encoder. Encoder should be
  * subclassed as part of driver encoder objects.
@@ -1088,7 +1085,7 @@ EXPORT_SYMBOL(drm_connector_unplug_all);
 int drm_encoder_init(struct drm_device *dev,
		      struct drm_encoder *encoder,
		      const struct drm_encoder_funcs *funcs,
-		      int encoder_type, const char *name, ...)
+		      int encoder_type)
 {
	int ret;

@@ -1153,7 +1150,6 @@ EXPORT_SYMBOL(drm_encoder_cleanup);
  * @formats: array of supported formats (%DRM_FORMAT_*)
  * @format_count: number of elements in @formats
  * @type: type of plane (overlay, primary, cursor)
- * @name: printf style format string for the plane name, or NULL for default name
  *
  * Initializes a plane object of type @type.
  *
@@ -1164,8 +1160,7 @@ int drm_universal_plane_init(struct drm_device *dev, struct drm_plane *plane,
			     unsigned long possible_crtcs,
			     const struct drm_plane_funcs *funcs,
			     const uint32_t *formats, unsigned int format_count,
-			     enum drm_plane_type type,
-			     const char *name, ...)
+			     enum drm_plane_type type)
 {
	struct drm_mode_config *config = &dev->mode_config;
	int ret;
@@ -1245,7 +1240,7 @@ int drm_plane_init(struct drm_device *dev, struct drm_plane *plane,

	type = is_primary ? DRM_PLANE_TYPE_PRIMARY : DRM_PLANE_TYPE_OVERLAY;
	return drm_universal_plane_init(dev, plane, possible_crtcs, funcs,
-					formats, format_count, type, NULL);
+					formats, format_count, type);
 }
 EXPORT_SYMBOL(drm_plane_init);

@@ -3240,7 +3235,7 @@ static int framebuffer_check(const struct drm_mode_fb_cmd2 *r)

 static struct drm_framebuffer *
 internal_framebuffer_create(struct drm_device *dev,
-			    const struct drm_mode_fb_cmd2 *r,
+			    struct drm_mode_fb_cmd2 *r,
			    struct drm_file *file_priv)
 {
	struct drm_mode_config *config = &dev->mode_config;
diff --git a/drivers/gpu/drm/drm_crtc_helper.c b/drivers/gpu/drm/drm_crtc_helper.c
index 6b4cf25..ef53475 100644
--- a/drivers/gpu/drm/drm_crtc_helper.c
+++ b/drivers/gpu/drm/drm_crtc_helper.c
@@ -818,7 +818,7 @@ EXPORT_SYMBOL(drm_helper_connector_dpms);
  * metadata fields.
  */
 void drm_helper_mode_fill_fb_struct(struct drm_framebuffer *fb,
-				    const struct drm_mode_fb_cmd2 *mode_cmd)
+				    struct drm_mode_fb_cmd2 *mode_cmd)
 {
	int i;

diff --git a/drivers/gpu/drm/drm_encoder_slave.c b/drivers/gpu/drm/drm_encoder_slave.c
index e862907..d18b88b 100644
--- a/drivers/gpu/drm/drm_encoder_slave.c
+++ b/drivers/gpu/drm/drm_encoder_slave.c
@@ -124,7 +124,7 @@ EXPORT_SYMBOL(drm_i2c_encoder_destroy);
  * Wrapper fxns which can be plugged in to drm_encoder_helper_funcs:
  */

-static inline const struct drm_encoder_slave_funcs *
+static inline struct drm_encoder_slave_funcs *
 get_slave_funcs(struct drm_encoder *enc)
 {
	return to_encoder_slave(enc)->slave_funcs;
diff --git a/drivers/gpu/drm/drm_fb_cma_helper.c b/drivers/gpu/drm/drm_fb_cma_helper.c
index b7d5b84..c19a625 100644
--- a/drivers/gpu/drm/drm_fb_cma_helper.c
+++ b/drivers/gpu/drm/drm_fb_cma_helper.c
@@ -74,7 +74,7 @@ static struct drm_framebuffer_funcs drm_fb_cma_funcs = {
 };

 static struct drm_fb_cma *drm_fb_cma_alloc(struct drm_device *dev,
-	const const struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_cma_object **obj,
+	struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_cma_object **obj,
	unsigned int num_planes)
 {
	struct drm_fb_cma *fb_cma;
@@ -107,7 +107,7 @@ static struct drm_fb_cma *drm_fb_cma_alloc(struct drm_device *dev,
  * checked before calling this function.
  */
 struct drm_framebuffer *drm_fb_cma_create(struct drm_device *dev,
-	struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd)
+	struct drm_file *file_priv, struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_fb_cma *fb_cma;
	struct drm_gem_cma_object *objs[4];
diff --git a/drivers/gpu/drm/drm_plane_helper.c b/drivers/gpu/drm/drm_plane_helper.c
index 4e50c7a..d384ebc 100644
--- a/drivers/gpu/drm/drm_plane_helper.c
+++ b/drivers/gpu/drm/drm_plane_helper.c
@@ -367,7 +367,7 @@ static struct drm_plane *create_primary_plane(struct drm_device *dev)
				       &drm_primary_helper_funcs,
				       safe_modeset_formats,
				       ARRAY_SIZE(safe_modeset_formats),
-				       DRM_PLANE_TYPE_PRIMARY, NULL);
+				       DRM_PLANE_TYPE_PRIMARY);
	if (ret) {
		kfree(primary);
		primary = NULL;
@@ -394,8 +394,7 @@ int drm_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
	struct drm_plane *primary;

	primary = create_primary_plane(dev);
-	return drm_crtc_init_with_planes(dev, crtc, primary, NULL, funcs,
-					 NULL);
+	return drm_crtc_init_with_planes(dev, crtc, primary, NULL, funcs);
 }
 EXPORT_SYMBOL(drm_crtc_init);

diff --git a/drivers/gpu/drm/exynos/exynos_dp_core.c b/drivers/gpu/drm/exynos/exynos_dp_core.c
index cf17713..124fb9a 100644
--- a/drivers/gpu/drm/exynos/exynos_dp_core.c
+++ b/drivers/gpu/drm/exynos/exynos_dp_core.c
@@ -1313,7 +1313,7 @@ static int exynos_dp_bind(struct device *dev, struct device *master, void *data)
	DRM_DEBUG_KMS("possible_crtcs = 0x%x\n", encoder->possible_crtcs);

	drm_encoder_init(drm_dev, encoder, &exynos_dp_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	drm_encoder_helper_add(encoder, &exynos_dp_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/exynos/exynos_drm_crtc.c b/drivers/gpu/drm/exynos/exynos_drm_crtc.c
index d06119b..e693571 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_crtc.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_crtc.c
@@ -153,7 +153,7 @@ struct exynos_drm_crtc *exynos_drm_crtc_create(struct drm_device *drm_dev,
	private->crtc[pipe] = crtc;

	ret = drm_crtc_init_with_planes(drm_dev, crtc, plane, NULL,
-					&exynos_crtc_funcs, NULL);
+					&exynos_crtc_funcs);
	if (ret < 0)
		goto err_crtc;

diff --git a/drivers/gpu/drm/exynos/exynos_drm_dpi.c b/drivers/gpu/drm/exynos/exynos_drm_dpi.c
index 1dbf8dc..c748b87 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_dpi.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_dpi.c
@@ -309,7 +309,7 @@ int exynos_dpi_bind(struct drm_device *dev, struct drm_encoder *encoder)
	DRM_DEBUG_KMS("possible_crtcs = 0x%x\n", encoder->possible_crtcs);

	drm_encoder_init(dev, encoder, &exynos_dpi_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	drm_encoder_helper_add(encoder, &exynos_dpi_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/exynos/exynos_drm_dsi.c b/drivers/gpu/drm/exynos/exynos_drm_dsi.c
index 0a99160..12b03b3 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_dsi.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_dsi.c
@@ -1831,7 +1831,7 @@ static int exynos_dsi_bind(struct device *dev, struct device *master,
	DRM_DEBUG_KMS("possible_crtcs = 0x%x\n", encoder->possible_crtcs);

	drm_encoder_init(drm_dev, encoder, &exynos_dsi_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	drm_encoder_helper_add(encoder, &exynos_dsi_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/exynos/exynos_drm_fb.c b/drivers/gpu/drm/exynos/exynos_drm_fb.c
index 49b9bc3..fcea28b 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_fb.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_fb.c
@@ -117,7 +117,7 @@ static struct drm_framebuffer_funcs exynos_drm_fb_funcs = {

 struct drm_framebuffer *
 exynos_drm_framebuffer_init(struct drm_device *dev,
-			    const struct drm_mode_fb_cmd2 *mode_cmd,
+			    struct drm_mode_fb_cmd2 *mode_cmd,
			    struct exynos_drm_gem **exynos_gem,
			    int count)
 {
@@ -154,7 +154,7 @@ err:

 static struct drm_framebuffer *
 exynos_user_fb_create(struct drm_device *dev, struct drm_file *file_priv,
-		      const struct drm_mode_fb_cmd2 *mode_cmd)
+		      struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct exynos_drm_gem *exynos_gem[MAX_FB_BUFFER];
	struct drm_gem_object *obj;
diff --git a/drivers/gpu/drm/exynos/exynos_drm_fb.h b/drivers/gpu/drm/exynos/exynos_drm_fb.h
index a8a75ac..726a2d4 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_fb.h
+++ b/drivers/gpu/drm/exynos/exynos_drm_fb.h
@@ -18,7 +18,7 @@

 struct drm_framebuffer *
 exynos_drm_framebuffer_init(struct drm_device *dev,
-			    const struct drm_mode_fb_cmd2 *mode_cmd,
+			    struct drm_mode_fb_cmd2 *mode_cmd,
			    struct exynos_drm_gem **exynos_gem,
			    int count);

diff --git a/drivers/gpu/drm/exynos/exynos_drm_plane.c b/drivers/gpu/drm/exynos/exynos_drm_plane.c
index 383ee1e..1793117 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_plane.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_plane.c
@@ -228,7 +228,7 @@ int exynos_plane_init(struct drm_device *dev,

	err = drm_universal_plane_init(dev, &exynos_plane->base, possible_crtcs,
				       &exynos_plane_funcs, formats, fcount,
-				       type, NULL);
+				       type);
	if (err) {
		DRM_ERROR("failed to initialize plane\n");
		return err;
diff --git a/drivers/gpu/drm/exynos/exynos_drm_vidi.c b/drivers/gpu/drm/exynos/exynos_drm_vidi.c
index c34d49a..669362c 100644
--- a/drivers/gpu/drm/exynos/exynos_drm_vidi.c
+++ b/drivers/gpu/drm/exynos/exynos_drm_vidi.c
@@ -473,7 +473,7 @@ static int vidi_bind(struct device *dev, struct device *master, void *data)
	DRM_DEBUG_KMS("possible_crtcs = 0x%x\n", encoder->possible_crtcs);

	drm_encoder_init(drm_dev, encoder, &exynos_vidi_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	drm_encoder_helper_add(encoder, &exynos_vidi_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/exynos/exynos_hdmi.c b/drivers/gpu/drm/exynos/exynos_hdmi.c
index ba3543e..57b6755 100644
--- a/drivers/gpu/drm/exynos/exynos_hdmi.c
+++ b/drivers/gpu/drm/exynos/exynos_hdmi.c
@@ -1793,7 +1793,7 @@ static int hdmi_bind(struct device *dev, struct device *master, void *data)
	DRM_DEBUG_KMS("possible_crtcs = 0x%x\n", encoder->possible_crtcs);

	drm_encoder_init(drm_dev, encoder, &exynos_hdmi_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	drm_encoder_helper_add(encoder, &exynos_hdmi_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_crtc.c b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_crtc.c
index d8ab8f0..82a3d31 100644
--- a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_crtc.c
+++ b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_crtc.c
@@ -175,7 +175,7 @@ int fsl_dcu_drm_crtc_create(struct fsl_dcu_drm_device *fsl_dev)

	primary = fsl_dcu_drm_primary_create_plane(fsl_dev->drm);
	ret = drm_crtc_init_with_planes(fsl_dev->drm, crtc, primary, NULL,
-					&fsl_dcu_drm_crtc_funcs, NULL);
+					&fsl_dcu_drm_crtc_funcs);
	if (ret < 0)
		return ret;

diff --git a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_plane.c b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_plane.c
index 4b13cf9..51daaea 100644
--- a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_plane.c
+++ b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_plane.c
@@ -249,7 +249,7 @@ struct drm_plane *fsl_dcu_drm_primary_create_plane(struct drm_device *dev)
				       &fsl_dcu_drm_plane_funcs,
				       fsl_dcu_drm_plane_formats,
				       ARRAY_SIZE(fsl_dcu_drm_plane_formats),
-				       DRM_PLANE_TYPE_PRIMARY, NULL);
+				       DRM_PLANE_TYPE_PRIMARY);
	if (ret) {
		kfree(primary);
		primary = NULL;
diff --git a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_rgb.c b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_rgb.c
index 8780deb..fe8ab5d 100644
--- a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_rgb.c
+++ b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_rgb.c
@@ -57,7 +57,7 @@ int fsl_dcu_drm_encoder_create(struct fsl_dcu_drm_device *fsl_dev,

	encoder->possible_crtcs = 1;
	ret = drm_encoder_init(fsl_dev->drm, encoder, &encoder_funcs,
-			       DRM_MODE_ENCODER_LVDS, NULL);
+			       DRM_MODE_ENCODER_LVDS);
	if (ret < 0)
		return ret;

diff --git a/drivers/gpu/drm/gma500/cdv_intel_crt.c b/drivers/gpu/drm/gma500/cdv_intel_crt.c
index d0717a8..248c33a 100644
--- a/drivers/gpu/drm/gma500/cdv_intel_crt.c
+++ b/drivers/gpu/drm/gma500/cdv_intel_crt.c
@@ -273,7 +273,7 @@ void cdv_intel_crt_init(struct drm_device *dev,

	encoder = &gma_encoder->base;
	drm_encoder_init(dev, encoder,
-		&cdv_intel_crt_enc_funcs, DRM_MODE_ENCODER_DAC, NULL);
+		&cdv_intel_crt_enc_funcs, DRM_MODE_ENCODER_DAC);

	gma_connector_attach_encoder(gma_connector, gma_encoder);

diff --git a/drivers/gpu/drm/gma500/cdv_intel_dp.c b/drivers/gpu/drm/gma500/cdv_intel_dp.c
index 7bb1f1af..17cea40 100644
--- a/drivers/gpu/drm/gma500/cdv_intel_dp.c
+++ b/drivers/gpu/drm/gma500/cdv_intel_dp.c
@@ -2020,8 +2020,7 @@ cdv_intel_dp_init(struct drm_device *dev, struct psb_intel_mode_device *mode_dev
	encoder = &gma_encoder->base;

	drm_connector_init(dev, connector, &cdv_intel_dp_connector_funcs, type);
-	drm_encoder_init(dev, encoder, &cdv_intel_dp_enc_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+	drm_encoder_init(dev, encoder, &cdv_intel_dp_enc_funcs, DRM_MODE_ENCODER_TMDS);

	gma_connector_attach_encoder(gma_connector, gma_encoder);

diff --git a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c b/drivers/gpu/drm/gma500/cdv_intel_hdmi.c
index 8930153..6b1d334 100644
--- a/drivers/gpu/drm/gma500/cdv_intel_hdmi.c
+++ b/drivers/gpu/drm/gma500/cdv_intel_hdmi.c
@@ -312,7 +312,7 @@ void cdv_hdmi_init(struct drm_device *dev,
			   DRM_MODE_CONNECTOR_DVID);

	drm_encoder_init(dev, encoder, &psb_intel_lvds_enc_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	gma_connector_attach_encoder(gma_connector, gma_encoder);
	gma_encoder->type = INTEL_OUTPUT_HDMI;
diff --git a/drivers/gpu/drm/gma500/cdv_intel_lvds.c b/drivers/gpu/drm/gma500/cdv_intel_lvds.c
index fa90515..211069b 100644
--- a/drivers/gpu/drm/gma500/cdv_intel_lvds.c
+++ b/drivers/gpu/drm/gma500/cdv_intel_lvds.c
@@ -652,7 +652,7 @@ void cdv_intel_lvds_init(struct drm_device *dev,

	drm_encoder_init(dev, encoder,
			 &cdv_intel_lvds_enc_funcs,
-			 DRM_MODE_ENCODER_LVDS, NULL);
+			 DRM_MODE_ENCODER_LVDS);


	gma_connector_attach_encoder(gma_connector, gma_encoder);
diff --git a/drivers/gpu/drm/gma500/framebuffer.c b/drivers/gpu/drm/gma500/framebuffer.c
index dc0508d..2eaf1b3 100644
--- a/drivers/gpu/drm/gma500/framebuffer.c
+++ b/drivers/gpu/drm/gma500/framebuffer.c
@@ -241,7 +241,7 @@ static struct fb_ops psbfb_unaccel_ops = {
  */
 static int psb_framebuffer_init(struct drm_device *dev,
					struct psb_framebuffer *fb,
-					const struct drm_mode_fb_cmd2 *mode_cmd,
+					struct drm_mode_fb_cmd2 *mode_cmd,
					struct gtt_range *gt)
 {
	u32 bpp, depth;
@@ -284,7 +284,7 @@ static int psb_framebuffer_init(struct drm_device *dev,

 static struct drm_framebuffer *psb_framebuffer_create
			(struct drm_device *dev,
-			 const struct drm_mode_fb_cmd2 *mode_cmd,
+			 struct drm_mode_fb_cmd2 *mode_cmd,
			 struct gtt_range *gt)
 {
	struct psb_framebuffer *fb;
@@ -488,7 +488,7 @@ out_err1:
  */
 static struct drm_framebuffer *psb_user_framebuffer_create
			(struct drm_device *dev, struct drm_file *filp,
-			 const struct drm_mode_fb_cmd2 *cmd)
+			 struct drm_mode_fb_cmd2 *cmd)
 {
	struct gtt_range *r;
	struct drm_gem_object *obj;
diff --git a/drivers/gpu/drm/gma500/mdfld_dsi_dpi.c b/drivers/gpu/drm/gma500/mdfld_dsi_dpi.c
index 1a1acd3..d4813e0 100644
--- a/drivers/gpu/drm/gma500/mdfld_dsi_dpi.c
+++ b/drivers/gpu/drm/gma500/mdfld_dsi_dpi.c
@@ -994,7 +994,7 @@ struct mdfld_dsi_encoder *mdfld_dsi_dpi_init(struct drm_device *dev,
	drm_encoder_init(dev,
			encoder,
			p_funcs->encoder_funcs,
-			DRM_MODE_ENCODER_LVDS, NULL);
+			DRM_MODE_ENCODER_LVDS);
	drm_encoder_helper_add(encoder,
				p_funcs->encoder_helper_funcs);

diff --git a/drivers/gpu/drm/gma500/oaktrail_hdmi.c b/drivers/gpu/drm/gma500/oaktrail_hdmi.c
index 2d18499..2310d87 100644
--- a/drivers/gpu/drm/gma500/oaktrail_hdmi.c
+++ b/drivers/gpu/drm/gma500/oaktrail_hdmi.c
@@ -654,7 +654,7 @@ void oaktrail_hdmi_init(struct drm_device *dev,

	drm_encoder_init(dev, encoder,
			 &oaktrail_hdmi_enc_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	gma_connector_attach_encoder(gma_connector, gma_encoder);

diff --git a/drivers/gpu/drm/gma500/oaktrail_lvds.c b/drivers/gpu/drm/gma500/oaktrail_lvds.c
index f7038f1..83bbc27 100644
--- a/drivers/gpu/drm/gma500/oaktrail_lvds.c
+++ b/drivers/gpu/drm/gma500/oaktrail_lvds.c
@@ -323,7 +323,7 @@ void oaktrail_lvds_init(struct drm_device *dev,
			   DRM_MODE_CONNECTOR_LVDS);

	drm_encoder_init(dev, encoder, &psb_intel_lvds_enc_funcs,
-			 DRM_MODE_ENCODER_LVDS, NULL);
+			 DRM_MODE_ENCODER_LVDS);

	gma_connector_attach_encoder(gma_connector, gma_encoder);
	gma_encoder->type = INTEL_OUTPUT_LVDS;
diff --git a/drivers/gpu/drm/gma500/psb_intel_lvds.c b/drivers/gpu/drm/gma500/psb_intel_lvds.c
index f6ca149..ce0645d 100644
--- a/drivers/gpu/drm/gma500/psb_intel_lvds.c
+++ b/drivers/gpu/drm/gma500/psb_intel_lvds.c
@@ -722,7 +722,7 @@ void psb_intel_lvds_init(struct drm_device *dev,

	drm_encoder_init(dev, encoder,
			 &psb_intel_lvds_enc_funcs,
-			 DRM_MODE_ENCODER_LVDS, NULL);
+			 DRM_MODE_ENCODER_LVDS);

	gma_connector_attach_encoder(gma_connector, gma_encoder);
	gma_encoder->type = INTEL_OUTPUT_LVDS;
diff --git a/drivers/gpu/drm/gma500/psb_intel_sdvo.c b/drivers/gpu/drm/gma500/psb_intel_sdvo.c
index 53f427e..58529ce 100644
--- a/drivers/gpu/drm/gma500/psb_intel_sdvo.c
+++ b/drivers/gpu/drm/gma500/psb_intel_sdvo.c
@@ -2525,8 +2525,7 @@ bool psb_intel_sdvo_init(struct drm_device *dev, int sdvo_reg)
	/* encoder type will be decided later */
	gma_encoder = &psb_intel_sdvo->base;
	gma_encoder->type = INTEL_OUTPUT_SDVO;
-	drm_encoder_init(dev, &gma_encoder->base, &psb_intel_sdvo_enc_funcs,
-			 0, NULL);
+	drm_encoder_init(dev, &gma_encoder->base, &psb_intel_sdvo_enc_funcs, 0);

	/* Read the regs to test if we can talk to the device */
	for (i = 0; i < 0x40; i++) {
diff --git a/drivers/gpu/drm/i2c/tda998x_drv.c b/drivers/gpu/drm/i2c/tda998x_drv.c
index de8c5a0..896b6aa 100644
--- a/drivers/gpu/drm/i2c/tda998x_drv.c
+++ b/drivers/gpu/drm/i2c/tda998x_drv.c
@@ -1437,7 +1437,7 @@ static int tda998x_bind(struct device *dev, struct device *master, void *data)

	drm_encoder_helper_add(&priv->encoder, &tda998x_encoder_helper_funcs);
	ret = drm_encoder_init(drm, &priv->encoder, &tda998x_encoder_funcs,
-			       DRM_MODE_ENCODER_TMDS, NULL);
+			       DRM_MODE_ENCODER_TMDS);
	if (ret)
		goto err_encoder;

diff --git a/drivers/gpu/drm/i915/intel_crt.c b/drivers/gpu/drm/i915/intel_crt.c
index 92f9fa1..6a2c76e 100644
--- a/drivers/gpu/drm/i915/intel_crt.c
+++ b/drivers/gpu/drm/i915/intel_crt.c
@@ -802,7 +802,7 @@ void intel_crt_init(struct drm_device *dev)
			   &intel_crt_connector_funcs, DRM_MODE_CONNECTOR_VGA);

	drm_encoder_init(dev, &crt->base.base, &intel_crt_enc_funcs,
-			 DRM_MODE_ENCODER_DAC, NULL);
+			 DRM_MODE_ENCODER_DAC);

	intel_connector_attach_encoder(intel_connector, &crt->base);

diff --git a/drivers/gpu/drm/i915/intel_ddi.c b/drivers/gpu/drm/i915/intel_ddi.c
index c5d518d..7e6158b 100644
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@ -3275,7 +3275,7 @@ void intel_ddi_init(struct drm_device *dev, enum port port)
	encoder = &intel_encoder->base;

	drm_encoder_init(dev, encoder, &intel_ddi_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	intel_encoder->compute_config = intel_ddi_compute_config;
	intel_encoder->enable = intel_enable_ddi;
diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 3c8d1ec..f859a5b 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -13707,7 +13707,7 @@ static struct drm_plane *intel_primary_plane_create(struct drm_device *dev,
	drm_universal_plane_init(dev, &primary->base, 0,
				 &intel_plane_funcs,
				 intel_primary_formats, num_formats,
-				 DRM_PLANE_TYPE_PRIMARY, NULL);
+				 DRM_PLANE_TYPE_PRIMARY);

	if (INTEL_INFO(dev)->gen >= 4)
		intel_create_rotation_property(dev, primary);
@@ -13859,7 +13859,7 @@ static struct drm_plane *intel_cursor_plane_create(struct drm_device *dev,
				 &intel_plane_funcs,
				 intel_cursor_formats,
				 ARRAY_SIZE(intel_cursor_formats),
-				 DRM_PLANE_TYPE_CURSOR, NULL);
+				 DRM_PLANE_TYPE_CURSOR);

	if (INTEL_INFO(dev)->gen >= 4) {
		if (!dev->mode_config.rotation_property)
@@ -13936,7 +13936,7 @@ static void intel_crtc_init(struct drm_device *dev, int pipe)
		goto fail;

	ret = drm_crtc_init_with_planes(dev, &intel_crtc->base, primary,
-					cursor, &intel_crtc_funcs, NULL);
+					cursor, &intel_crtc_funcs);
	if (ret)
		goto fail;

@@ -14465,7 +14465,7 @@ static int intel_framebuffer_init(struct drm_device *dev,
 static struct drm_framebuffer *
 intel_user_framebuffer_create(struct drm_device *dev,
			      struct drm_file *filp,
-			      const struct drm_mode_fb_cmd2 *user_mode_cmd)
+			      struct drm_mode_fb_cmd2 *user_mode_cmd)
 {
	struct drm_i915_gem_object *obj;
	struct drm_mode_fb_cmd2 mode_cmd = *user_mode_cmd;
diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c
index a35aca2..78b8ec8 100644
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@ -6156,7 +6156,7 @@ intel_dp_init(struct drm_device *dev, int output_reg, enum port port)
	encoder = &intel_encoder->base;

	drm_encoder_init(dev, &intel_encoder->base, &intel_dp_enc_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	intel_encoder->compute_config = intel_dp_compute_config;
	intel_encoder->disable = intel_disable_dp;
diff --git a/drivers/gpu/drm/i915/intel_dp_mst.c b/drivers/gpu/drm/i915/intel_dp_mst.c
index 6c11aa3..0639275 100644
--- a/drivers/gpu/drm/i915/intel_dp_mst.c
+++ b/drivers/gpu/drm/i915/intel_dp_mst.c
@@ -536,7 +536,7 @@ intel_dp_create_fake_mst_encoder(struct intel_digital_port *intel_dig_port, enum
	intel_mst->primary = intel_dig_port;

	drm_encoder_init(dev, &intel_encoder->base, &intel_dp_mst_enc_funcs,
-			 DRM_MODE_ENCODER_DPMST, NULL);
+			 DRM_MODE_ENCODER_DPMST);

	intel_encoder->type = INTEL_OUTPUT_DP_MST;
	intel_encoder->crtc_mask = 0x7;
diff --git a/drivers/gpu/drm/i915/intel_dsi.c b/drivers/gpu/drm/i915/intel_dsi.c
index 920ed62..170ae6f 100644
--- a/drivers/gpu/drm/i915/intel_dsi.c
+++ b/drivers/gpu/drm/i915/intel_dsi.c
@@ -1151,8 +1151,7 @@ void intel_dsi_init(struct drm_device *dev)

	connector = &intel_connector->base;

-	drm_encoder_init(dev, encoder, &intel_dsi_funcs, DRM_MODE_ENCODER_DSI,
-			 NULL);
+	drm_encoder_init(dev, encoder, &intel_dsi_funcs, DRM_MODE_ENCODER_DSI);

	/* XXX: very likely not all of these are needed */
	intel_encoder->compute_config = intel_dsi_compute_config;
diff --git a/drivers/gpu/drm/i915/intel_dvo.c b/drivers/gpu/drm/i915/intel_dvo.c
index 8df7e7d..8492053 100644
--- a/drivers/gpu/drm/i915/intel_dvo.c
+++ b/drivers/gpu/drm/i915/intel_dvo.c
@@ -434,7 +434,7 @@ void intel_dvo_init(struct drm_device *dev)

	intel_encoder = &intel_dvo->base;
	drm_encoder_init(dev, &intel_encoder->base,
-			 &intel_dvo_enc_funcs, encoder_type, NULL);
+			 &intel_dvo_enc_funcs, encoder_type);

	intel_encoder->disable = intel_disable_dvo;
	intel_encoder->enable = intel_enable_dvo;
diff --git a/drivers/gpu/drm/i915/intel_hdmi.c b/drivers/gpu/drm/i915/intel_hdmi.c
index a92f31f..e6c035b 100644
--- a/drivers/gpu/drm/i915/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/intel_hdmi.c
@@ -2151,7 +2151,7 @@ void intel_hdmi_init(struct drm_device *dev, int hdmi_reg, enum port port)
	intel_encoder = &intel_dig_port->base;

	drm_encoder_init(dev, &intel_encoder->base, &intel_hdmi_enc_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	intel_encoder->compute_config = intel_hdmi_compute_config;
	if (HAS_PCH_SPLIT(dev)) {
diff --git a/drivers/gpu/drm/i915/intel_lvds.c b/drivers/gpu/drm/i915/intel_lvds.c
index 5722a39..7f39b8a 100644
--- a/drivers/gpu/drm/i915/intel_lvds.c
+++ b/drivers/gpu/drm/i915/intel_lvds.c
@@ -1025,7 +1025,7 @@ void intel_lvds_init(struct drm_device *dev)
			   DRM_MODE_CONNECTOR_LVDS);

	drm_encoder_init(dev, &intel_encoder->base, &intel_lvds_enc_funcs,
-			 DRM_MODE_ENCODER_LVDS, NULL);
+			 DRM_MODE_ENCODER_LVDS);

	intel_encoder->enable = intel_enable_lvds;
	intel_encoder->pre_enable = intel_pre_enable_lvds;
diff --git a/drivers/gpu/drm/i915/intel_sdvo.c b/drivers/gpu/drm/i915/intel_sdvo.c
index c011cf7..c42b636 100644
--- a/drivers/gpu/drm/i915/intel_sdvo.c
+++ b/drivers/gpu/drm/i915/intel_sdvo.c
@@ -2959,8 +2959,7 @@ bool intel_sdvo_init(struct drm_device *dev, uint32_t sdvo_reg, bool is_sdvob)
	/* encoder type will be decided later */
	intel_encoder = &intel_sdvo->base;
	intel_encoder->type = INTEL_OUTPUT_SDVO;
-	drm_encoder_init(dev, &intel_encoder->base, &intel_sdvo_enc_funcs, 0,
-			 NULL);
+	drm_encoder_init(dev, &intel_encoder->base, &intel_sdvo_enc_funcs, 0);

	/* Read the regs to test if we can talk to the device */
	for (i = 0; i < 0x40; i++) {
diff --git a/drivers/gpu/drm/i915/intel_sprite.c b/drivers/gpu/drm/i915/intel_sprite.c
index 9e9795d..56dc132 100644
--- a/drivers/gpu/drm/i915/intel_sprite.c
+++ b/drivers/gpu/drm/i915/intel_sprite.c
@@ -1141,7 +1141,7 @@ intel_plane_init(struct drm_device *dev, enum pipe pipe, int plane)
	ret = drm_universal_plane_init(dev, &intel_plane->base, possible_crtcs,
				       &intel_plane_funcs,
				       plane_formats, num_plane_formats,
-				       DRM_PLANE_TYPE_OVERLAY, NULL);
+				       DRM_PLANE_TYPE_OVERLAY);
	if (ret) {
		kfree(intel_plane);
		goto out;
diff --git a/drivers/gpu/drm/i915/intel_tv.c b/drivers/gpu/drm/i915/intel_tv.c
index 948cbff..6bea789 100644
--- a/drivers/gpu/drm/i915/intel_tv.c
+++ b/drivers/gpu/drm/i915/intel_tv.c
@@ -1645,7 +1645,7 @@ intel_tv_init(struct drm_device *dev)
			   DRM_MODE_CONNECTOR_SVIDEO);

	drm_encoder_init(dev, &intel_encoder->base, &intel_tv_enc_funcs,
-			 DRM_MODE_ENCODER_TVDAC, NULL);
+			 DRM_MODE_ENCODER_TVDAC);

	intel_encoder->compute_config = intel_tv_compute_config;
	intel_encoder->get_config = intel_tv_get_config;
diff --git a/drivers/gpu/drm/imx/dw_hdmi-imx.c b/drivers/gpu/drm/imx/dw_hdmi-imx.c
index 35fcf6b..98605ea 100644
--- a/drivers/gpu/drm/imx/dw_hdmi-imx.c
+++ b/drivers/gpu/drm/imx/dw_hdmi-imx.c
@@ -251,7 +251,7 @@ static int dw_hdmi_imx_bind(struct device *dev, struct device *master,

	drm_encoder_helper_add(encoder, &dw_hdmi_imx_encoder_helper_funcs);
	drm_encoder_init(drm, encoder, &dw_hdmi_imx_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	return dw_hdmi_bind(dev, master, data, encoder, iores, irq, plat_data);
 }
diff --git a/drivers/gpu/drm/imx/imx-drm-core.c b/drivers/gpu/drm/imx/imx-drm-core.c
index e9eb8bb..7b990b4 100644
--- a/drivers/gpu/drm/imx/imx-drm-core.c
+++ b/drivers/gpu/drm/imx/imx-drm-core.c
@@ -379,7 +379,7 @@ int imx_drm_add_crtc(struct drm_device *drm, struct drm_crtc *crtc,
			imx_drm_crtc->imx_drm_helper_funcs.crtc_helper_funcs);

	drm_crtc_init_with_planes(drm, crtc, primary_plane, NULL,
-			imx_drm_crtc->imx_drm_helper_funcs.crtc_funcs, NULL);
+			imx_drm_crtc->imx_drm_helper_funcs.crtc_funcs);

	return 0;

diff --git a/drivers/gpu/drm/imx/imx-ldb.c b/drivers/gpu/drm/imx/imx-ldb.c
index c79a61b..abacc8f 100644
--- a/drivers/gpu/drm/imx/imx-ldb.c
+++ b/drivers/gpu/drm/imx/imx-ldb.c
@@ -422,7 +422,7 @@ static int imx_ldb_register(struct drm_device *drm,
	drm_encoder_helper_add(&imx_ldb_ch->encoder,
			&imx_ldb_encoder_helper_funcs);
	drm_encoder_init(drm, &imx_ldb_ch->encoder, &imx_ldb_encoder_funcs,
-			 DRM_MODE_ENCODER_LVDS, NULL);
+			 DRM_MODE_ENCODER_LVDS);

	drm_connector_helper_add(&imx_ldb_ch->connector,
			&imx_ldb_connector_helper_funcs);
diff --git a/drivers/gpu/drm/imx/imx-tve.c b/drivers/gpu/drm/imx/imx-tve.c
index e61a8fc..f959714 100644
--- a/drivers/gpu/drm/imx/imx-tve.c
+++ b/drivers/gpu/drm/imx/imx-tve.c
@@ -508,7 +508,7 @@ static int imx_tve_register(struct drm_device *drm, struct imx_tve *tve)

	drm_encoder_helper_add(&tve->encoder, &imx_tve_encoder_helper_funcs);
	drm_encoder_init(drm, &tve->encoder, &imx_tve_encoder_funcs,
-			 encoder_type, NULL);
+			 encoder_type);

	drm_connector_helper_add(&tve->connector,
			&imx_tve_connector_helper_funcs);
diff --git a/drivers/gpu/drm/imx/ipuv3-plane.c b/drivers/gpu/drm/imx/ipuv3-plane.c
index 591ba2f..e2ff410 100644
--- a/drivers/gpu/drm/imx/ipuv3-plane.c
+++ b/drivers/gpu/drm/imx/ipuv3-plane.c
@@ -401,8 +401,7 @@ struct ipu_plane *ipu_plane_init(struct drm_device *dev, struct ipu_soc *ipu,

	ret = drm_universal_plane_init(dev, &ipu_plane->base, possible_crtcs,
				       &ipu_plane_funcs, ipu_plane_formats,
-				       ARRAY_SIZE(ipu_plane_formats), type,
-				       NULL);
+				       ARRAY_SIZE(ipu_plane_formats), type);
	if (ret) {
		DRM_ERROR("failed to initialize plane\n");
		kfree(ipu_plane);
diff --git a/drivers/gpu/drm/imx/parallel-display.c b/drivers/gpu/drm/imx/parallel-display.c
index fcbe4d2..2e9b9f1 100644
--- a/drivers/gpu/drm/imx/parallel-display.c
+++ b/drivers/gpu/drm/imx/parallel-display.c
@@ -192,7 +192,7 @@ static int imx_pd_register(struct drm_device *drm,

	drm_encoder_helper_add(&imxpd->encoder, &imx_pd_encoder_helper_funcs);
	drm_encoder_init(drm, &imxpd->encoder, &imx_pd_encoder_funcs,
-			 DRM_MODE_ENCODER_NONE, NULL);
+			 DRM_MODE_ENCODER_NONE);

	drm_connector_helper_add(&imxpd->connector,
			&imx_pd_connector_helper_funcs);
diff --git a/drivers/gpu/drm/mgag200/mgag200_drv.h b/drivers/gpu/drm/mgag200/mgag200_drv.h
index 205b280..912151c 100644
--- a/drivers/gpu/drm/mgag200/mgag200_drv.h
+++ b/drivers/gpu/drm/mgag200/mgag200_drv.h
@@ -252,7 +252,7 @@ void mgag200_fbdev_fini(struct mga_device *mdev);
				/* mgag200_main.c */
 int mgag200_framebuffer_init(struct drm_device *dev,
			     struct mga_framebuffer *mfb,
-			     const struct drm_mode_fb_cmd2 *mode_cmd,
+			     struct drm_mode_fb_cmd2 *mode_cmd,
			     struct drm_gem_object *obj);


diff --git a/drivers/gpu/drm/mgag200/mgag200_fb.c b/drivers/gpu/drm/mgag200/mgag200_fb.c
index d9b04b0..b35b5b2 100644
--- a/drivers/gpu/drm/mgag200/mgag200_fb.c
+++ b/drivers/gpu/drm/mgag200/mgag200_fb.c
@@ -138,7 +138,7 @@ static struct fb_ops mgag200fb_ops = {
 };

 static int mgag200fb_create_object(struct mga_fbdev *afbdev,
-				   const struct drm_mode_fb_cmd2 *mode_cmd,
+				   struct drm_mode_fb_cmd2 *mode_cmd,
				   struct drm_gem_object **gobj_p)
 {
	struct drm_device *dev = afbdev->helper.dev;
diff --git a/drivers/gpu/drm/mgag200/mgag200_main.c b/drivers/gpu/drm/mgag200/mgag200_main.c
index 9147444..b1a0f56 100644
--- a/drivers/gpu/drm/mgag200/mgag200_main.c
+++ b/drivers/gpu/drm/mgag200/mgag200_main.c
@@ -29,7 +29,7 @@ static const struct drm_framebuffer_funcs mga_fb_funcs = {

 int mgag200_framebuffer_init(struct drm_device *dev,
			     struct mga_framebuffer *gfb,
-			     const struct drm_mode_fb_cmd2 *mode_cmd,
+			     struct drm_mode_fb_cmd2 *mode_cmd,
			     struct drm_gem_object *obj)
 {
	int ret;
@@ -47,7 +47,7 @@ int mgag200_framebuffer_init(struct drm_device *dev,
 static struct drm_framebuffer *
 mgag200_user_framebuffer_create(struct drm_device *dev,
				struct drm_file *filp,
-				const struct drm_mode_fb_cmd2 *mode_cmd)
+				struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_gem_object *obj;
	struct mga_framebuffer *mga_fb;
diff --git a/drivers/gpu/drm/mgag200/mgag200_mode.c b/drivers/gpu/drm/mgag200/mgag200_mode.c
index 3180212..c99d3fe 100644
--- a/drivers/gpu/drm/mgag200/mgag200_mode.c
+++ b/drivers/gpu/drm/mgag200/mgag200_mode.c
@@ -1538,7 +1538,7 @@ static struct drm_encoder *mga_encoder_init(struct drm_device *dev)
	encoder->possible_crtcs = 0x1;

	drm_encoder_init(dev, encoder, &mga_encoder_encoder_funcs,
-			 DRM_MODE_ENCODER_DAC, NULL);
+			 DRM_MODE_ENCODER_DAC);
	drm_encoder_helper_add(encoder, &mga_encoder_helper_funcs);

	return encoder;
diff --git a/drivers/gpu/drm/msm/mdp/mdp4/mdp4_crtc.c b/drivers/gpu/drm/msm/mdp/mdp4/mdp4_crtc.c
index 28df397..6ac9aa1 100644
--- a/drivers/gpu/drm/msm/mdp/mdp4/mdp4_crtc.c
+++ b/drivers/gpu/drm/msm/mdp/mdp4/mdp4_crtc.c
@@ -678,8 +678,7 @@ struct drm_crtc *mdp4_crtc_init(struct drm_device *dev,
	drm_flip_work_init(&mdp4_crtc->unref_cursor_work,
			"unref cursor", unref_cursor_worker);

-	drm_crtc_init_with_planes(dev, crtc, plane, NULL, &mdp4_crtc_funcs,
-				  NULL);
+	drm_crtc_init_with_planes(dev, crtc, plane, NULL, &mdp4_crtc_funcs);
	drm_crtc_helper_add(crtc, &mdp4_crtc_helper_funcs);
	plane->crtc = crtc;

diff --git a/drivers/gpu/drm/msm/mdp/mdp4/mdp4_dtv_encoder.c b/drivers/gpu/drm/msm/mdp/mdp4/mdp4_dtv_encoder.c
index a21df54..89614c6 100644
--- a/drivers/gpu/drm/msm/mdp/mdp4/mdp4_dtv_encoder.c
+++ b/drivers/gpu/drm/msm/mdp/mdp4/mdp4_dtv_encoder.c
@@ -262,7 +262,7 @@ struct drm_encoder *mdp4_dtv_encoder_init(struct drm_device *dev)
	encoder = &mdp4_dtv_encoder->base;

	drm_encoder_init(dev, encoder, &mdp4_dtv_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);
	drm_encoder_helper_add(encoder, &mdp4_dtv_encoder_helper_funcs);

	mdp4_dtv_encoder->src_clk = devm_clk_get(dev->dev, "src_clk");
diff --git a/drivers/gpu/drm/msm/mdp/mdp4/mdp4_lcdc_encoder.c b/drivers/gpu/drm/msm/mdp/mdp4/mdp4_lcdc_encoder.c
index f824c64..4cd6e72 100644
--- a/drivers/gpu/drm/msm/mdp/mdp4/mdp4_lcdc_encoder.c
+++ b/drivers/gpu/drm/msm/mdp/mdp4/mdp4_lcdc_encoder.c
@@ -460,7 +460,7 @@ struct drm_encoder *mdp4_lcdc_encoder_init(struct drm_device *dev,
	encoder = &mdp4_lcdc_encoder->base;

	drm_encoder_init(dev, encoder, &mdp4_lcdc_encoder_funcs,
-			 DRM_MODE_ENCODER_LVDS, NULL);
+			 DRM_MODE_ENCODER_LVDS);
	drm_encoder_helper_add(encoder, &mdp4_lcdc_encoder_helper_funcs);

	/* TODO: do we need different pll in other cases? */
diff --git a/drivers/gpu/drm/msm/mdp/mdp4/mdp4_plane.c b/drivers/gpu/drm/msm/mdp/mdp4/mdp4_plane.c
index 9f96dfe..30d57e7 100644
--- a/drivers/gpu/drm/msm/mdp/mdp4/mdp4_plane.c
+++ b/drivers/gpu/drm/msm/mdp/mdp4/mdp4_plane.c
@@ -397,8 +397,7 @@ struct drm_plane *mdp4_plane_init(struct drm_device *dev,

	type = private_plane ? DRM_PLANE_TYPE_PRIMARY : DRM_PLANE_TYPE_OVERLAY;
	ret = drm_universal_plane_init(dev, plane, 0xff, &mdp4_plane_funcs,
-				 mdp4_plane->formats, mdp4_plane->nformats,
-				 type, NULL);
+				 mdp4_plane->formats, mdp4_plane->nformats, type);
	if (ret)
		goto fail;

diff --git a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_cmd_encoder.c b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_cmd_encoder.c
index 1aa21db..8e6c9b5 100644
--- a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_cmd_encoder.c
+++ b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_cmd_encoder.c
@@ -326,7 +326,7 @@ struct drm_encoder *mdp5_cmd_encoder_init(struct drm_device *dev,
	mdp5_cmd_enc->ctl = ctl;

	drm_encoder_init(dev, encoder, &mdp5_cmd_encoder_funcs,
-			DRM_MODE_ENCODER_DSI, NULL);
+			DRM_MODE_ENCODER_DSI);

	drm_encoder_helper_add(encoder, &mdp5_cmd_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_crtc.c b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_crtc.c
index 20cee5c..7f9f4ac 100644
--- a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_crtc.c
+++ b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_crtc.c
@@ -797,8 +797,7 @@ struct drm_crtc *mdp5_crtc_init(struct drm_device *dev,
	snprintf(mdp5_crtc->name, sizeof(mdp5_crtc->name), "%s:%d",
			pipe2name(mdp5_plane_pipe(plane)), id);

-	drm_crtc_init_with_planes(dev, crtc, plane, NULL, &mdp5_crtc_funcs,
-				  NULL);
+	drm_crtc_init_with_planes(dev, crtc, plane, NULL, &mdp5_crtc_funcs);

	drm_flip_work_init(&mdp5_crtc->unref_cursor_work,
			"unref cursor", unref_cursor_worker);
diff --git a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_encoder.c b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_encoder.c
index 278e307..c9e32b0 100644
--- a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_encoder.c
+++ b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_encoder.c
@@ -354,7 +354,7 @@ struct drm_encoder *mdp5_encoder_init(struct drm_device *dev,

	spin_lock_init(&mdp5_encoder->intf_lock);

-	drm_encoder_init(dev, encoder, &mdp5_encoder_funcs, enc_type, NULL);
+	drm_encoder_init(dev, encoder, &mdp5_encoder_funcs, enc_type);

	drm_encoder_helper_add(encoder, &mdp5_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_plane.c b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_plane.c
index 432c098..81cd490 100644
--- a/drivers/gpu/drm/msm/mdp/mdp5/mdp5_plane.c
+++ b/drivers/gpu/drm/msm/mdp/mdp5/mdp5_plane.c
@@ -904,7 +904,7 @@ struct drm_plane *mdp5_plane_init(struct drm_device *dev,
	type = private_plane ? DRM_PLANE_TYPE_PRIMARY : DRM_PLANE_TYPE_OVERLAY;
	ret = drm_universal_plane_init(dev, plane, 0xff, &mdp5_plane_funcs,
				 mdp5_plane->formats, mdp5_plane->nformats,
-				 type, NULL);
+				 type);
	if (ret)
		goto fail;

diff --git a/drivers/gpu/drm/msm/msm_drv.h b/drivers/gpu/drm/msm/msm_drv.h
index 9a713b7..3be7a56 100644
--- a/drivers/gpu/drm/msm/msm_drv.h
+++ b/drivers/gpu/drm/msm/msm_drv.h
@@ -240,9 +240,9 @@ uint32_t msm_framebuffer_iova(struct drm_framebuffer *fb, int id, int plane);
 struct drm_gem_object *msm_framebuffer_bo(struct drm_framebuffer *fb, int plane);
 const struct msm_format *msm_framebuffer_format(struct drm_framebuffer *fb);
 struct drm_framebuffer *msm_framebuffer_init(struct drm_device *dev,
-		const struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos);
+		struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos);
 struct drm_framebuffer *msm_framebuffer_create(struct drm_device *dev,
-		struct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd);
+		struct drm_file *file, struct drm_mode_fb_cmd2 *mode_cmd);

 struct drm_fb_helper *msm_fbdev_init(struct drm_device *dev);

diff --git a/drivers/gpu/drm/msm/msm_fb.c b/drivers/gpu/drm/msm/msm_fb.c
index a474d6c..12171328 100644
--- a/drivers/gpu/drm/msm/msm_fb.c
+++ b/drivers/gpu/drm/msm/msm_fb.c
@@ -138,7 +138,7 @@ const struct msm_format *msm_framebuffer_format(struct drm_framebuffer *fb)
 }

 struct drm_framebuffer *msm_framebuffer_create(struct drm_device *dev,
-		struct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd)
+		struct drm_file *file, struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_gem_object *bos[4] = {0};
	struct drm_framebuffer *fb;
@@ -168,7 +168,7 @@ out_unref:
 }

 struct drm_framebuffer *msm_framebuffer_init(struct drm_device *dev,
-		const struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)
+		struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)
 {
	struct msm_drm_private *priv = dev->dev_private;
	struct msm_kms *kms = priv->kms;
diff --git a/drivers/gpu/drm/nouveau/dispnv04/dac.c b/drivers/gpu/drm/nouveau/dispnv04/dac.c
index 0adefac..78cb033 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/dac.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/dac.c
@@ -550,8 +550,7 @@ nv04_dac_create(struct drm_connector *connector, struct dcb_output *entry)
	else
		helper = &nv04_dac_helper_funcs;

-	drm_encoder_init(dev, encoder, &nv04_dac_funcs, DRM_MODE_ENCODER_DAC,
-			 NULL);
+	drm_encoder_init(dev, encoder, &nv04_dac_funcs, DRM_MODE_ENCODER_DAC);
	drm_encoder_helper_add(encoder, helper);

	encoder->possible_crtcs = entry->heads;
diff --git a/drivers/gpu/drm/nouveau/dispnv04/dfp.c b/drivers/gpu/drm/nouveau/dispnv04/dfp.c
index 9164ffb..429ab5e 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/dfp.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/dfp.c
@@ -706,7 +706,7 @@ nv04_dfp_create(struct drm_connector *connector, struct dcb_output *entry)
	nv_encoder->dcb = entry;
	nv_encoder->or = ffs(entry->or) - 1;

-	drm_encoder_init(connector->dev, encoder, &nv04_dfp_funcs, type, NULL);
+	drm_encoder_init(connector->dev, encoder, &nv04_dfp_funcs, type);
	drm_encoder_helper_add(encoder, helper);

	encoder->possible_crtcs = entry->heads;
diff --git a/drivers/gpu/drm/nouveau/dispnv04/tvnv17.c b/drivers/gpu/drm/nouveau/dispnv04/tvnv17.c
index 72312f1..b734195 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/tvnv17.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/tvnv17.c
@@ -816,8 +816,7 @@ nv17_tv_create(struct drm_connector *connector, struct dcb_output *entry)
	tv_enc->base.dcb = entry;
	tv_enc->base.or = ffs(entry->or) - 1;

-	drm_encoder_init(dev, encoder, &nv17_tv_funcs, DRM_MODE_ENCODER_TVDAC,
-			 NULL);
+	drm_encoder_init(dev, encoder, &nv17_tv_funcs, DRM_MODE_ENCODER_TVDAC);
	drm_encoder_helper_add(encoder, &nv17_tv_helper_funcs);
	to_encoder_slave(encoder)->slave_funcs = &nv17_tv_slave_funcs;

diff --git a/drivers/gpu/drm/nouveau/nouveau_display.c b/drivers/gpu/drm/nouveau/nouveau_display.c
index 1f8e51b..58a3f7c 100644
--- a/drivers/gpu/drm/nouveau/nouveau_display.c
+++ b/drivers/gpu/drm/nouveau/nouveau_display.c
@@ -246,7 +246,7 @@ static const struct drm_framebuffer_funcs nouveau_framebuffer_funcs = {
 int
 nouveau_framebuffer_init(struct drm_device *dev,
			 struct nouveau_framebuffer *nv_fb,
-			 const struct drm_mode_fb_cmd2 *mode_cmd,
+			 struct drm_mode_fb_cmd2 *mode_cmd,
			 struct nouveau_bo *nvbo)
 {
	struct nouveau_display *disp = nouveau_display(dev);
@@ -272,7 +272,7 @@ nouveau_framebuffer_init(struct drm_device *dev,
 static struct drm_framebuffer *
 nouveau_user_framebuffer_create(struct drm_device *dev,
				struct drm_file *file_priv,
-				const struct drm_mode_fb_cmd2 *mode_cmd)
+				struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct nouveau_framebuffer *nouveau_fb;
	struct drm_gem_object *gem;
diff --git a/drivers/gpu/drm/nouveau/nouveau_display.h b/drivers/gpu/drm/nouveau/nouveau_display.h
index 5a57d8b..856abe0 100644
--- a/drivers/gpu/drm/nouveau/nouveau_display.h
+++ b/drivers/gpu/drm/nouveau/nouveau_display.h
@@ -23,7 +23,7 @@ nouveau_framebuffer(struct drm_framebuffer *fb)
 }

 int nouveau_framebuffer_init(struct drm_device *, struct nouveau_framebuffer *,
-			     const struct drm_mode_fb_cmd2 *, struct nouveau_bo *);
+			     struct drm_mode_fb_cmd2 *, struct nouveau_bo *);

 struct nouveau_page_flip_state {
	struct list_head head;
diff --git a/drivers/gpu/drm/nouveau/nouveau_encoder.h b/drivers/gpu/drm/nouveau/nouveau_encoder.h
index 07527db..b37da95 100644
--- a/drivers/gpu/drm/nouveau/nouveau_encoder.h
+++ b/drivers/gpu/drm/nouveau/nouveau_encoder.h
@@ -80,7 +80,7 @@ static inline struct drm_encoder *to_drm_encoder(struct nouveau_encoder *enc)
	return &enc->base.base;
 }

-static inline const struct drm_encoder_slave_funcs *
+static inline struct drm_encoder_slave_funcs *
 get_slave_funcs(struct drm_encoder *enc)
 {
	return to_encoder_slave(enc)->slave_funcs;
diff --git a/drivers/gpu/drm/nouveau/nv50_display.c b/drivers/gpu/drm/nouveau/nv50_display.c
index 7681838..c053c50 100644
--- a/drivers/gpu/drm/nouveau/nv50_display.c
+++ b/drivers/gpu/drm/nouveau/nv50_display.c
@@ -1717,7 +1717,7 @@ nv50_dac_create(struct drm_connector *connector, struct dcb_output *dcbe)
	encoder = to_drm_encoder(nv_encoder);
	encoder->possible_crtcs = dcbe->heads;
	encoder->possible_clones = 0;
-	drm_encoder_init(connector->dev, encoder, &nv50_dac_func, type, NULL);
+	drm_encoder_init(connector->dev, encoder, &nv50_dac_func, type);
	drm_encoder_helper_add(encoder, &nv50_dac_hfunc);

	drm_mode_connector_attach_encoder(connector, encoder);
@@ -2125,7 +2125,7 @@ nv50_sor_create(struct drm_connector *connector, struct dcb_output *dcbe)
	encoder = to_drm_encoder(nv_encoder);
	encoder->possible_crtcs = dcbe->heads;
	encoder->possible_clones = 0;
-	drm_encoder_init(connector->dev, encoder, &nv50_sor_func, type, NULL);
+	drm_encoder_init(connector->dev, encoder, &nv50_sor_func, type);
	drm_encoder_helper_add(encoder, &nv50_sor_hfunc);

	drm_mode_connector_attach_encoder(connector, encoder);
@@ -2305,7 +2305,7 @@ nv50_pior_create(struct drm_connector *connector, struct dcb_output *dcbe)
	encoder = to_drm_encoder(nv_encoder);
	encoder->possible_crtcs = dcbe->heads;
	encoder->possible_clones = 0;
-	drm_encoder_init(connector->dev, encoder, &nv50_pior_func, type, NULL);
+	drm_encoder_init(connector->dev, encoder, &nv50_pior_func, type);
	drm_encoder_helper_add(encoder, &nv50_pior_hfunc);

	drm_mode_connector_attach_encoder(connector, encoder);
diff --git a/drivers/gpu/drm/omapdrm/omap_crtc.c b/drivers/gpu/drm/omapdrm/omap_crtc.c
index 2ed0754..ad09590 100644
--- a/drivers/gpu/drm/omapdrm/omap_crtc.c
+++ b/drivers/gpu/drm/omapdrm/omap_crtc.c
@@ -524,7 +524,7 @@ struct drm_crtc *omap_crtc_init(struct drm_device *dev,
	omap_crtc->mgr = omap_dss_get_overlay_manager(channel);

	ret = drm_crtc_init_with_planes(dev, crtc, plane, NULL,
-					&omap_crtc_funcs, NULL);
+					&omap_crtc_funcs);
	if (ret < 0) {
		kfree(omap_crtc);
		return NULL;
diff --git a/drivers/gpu/drm/omapdrm/omap_drv.h b/drivers/gpu/drm/omapdrm/omap_drv.h
index 130fca7..5c367aa 100644
--- a/drivers/gpu/drm/omapdrm/omap_drv.h
+++ b/drivers/gpu/drm/omapdrm/omap_drv.h
@@ -172,9 +172,9 @@ void copy_timings_drm_to_omap(struct omap_video_timings *timings,
 uint32_t omap_framebuffer_get_formats(uint32_t *pixel_formats,
		uint32_t max_formats, enum omap_color_mode supported_modes);
 struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
-		struct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd);
+		struct drm_file *file, struct drm_mode_fb_cmd2 *mode_cmd);
 struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
-		const struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos);
+		struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos);
 struct drm_gem_object *omap_framebuffer_bo(struct drm_framebuffer *fb, int p);
 int omap_framebuffer_pin(struct drm_framebuffer *fb);
 void omap_framebuffer_unpin(struct drm_framebuffer *fb);
@@ -248,7 +248,7 @@ struct omap_dss_device *omap_encoder_get_dssdev(struct drm_encoder *encoder);

 static inline int objects_lookup(struct drm_device *dev,
		struct drm_file *filp, uint32_t pixel_format,
-		struct drm_gem_object **bos, const uint32_t *handles)
+		struct drm_gem_object **bos, uint32_t *handles)
 {
	int i, n = drm_format_num_planes(pixel_format);

diff --git a/drivers/gpu/drm/omapdrm/omap_encoder.c b/drivers/gpu/drm/omapdrm/omap_encoder.c
index 0c104ad..7d9b32a 100644
--- a/drivers/gpu/drm/omapdrm/omap_encoder.c
+++ b/drivers/gpu/drm/omapdrm/omap_encoder.c
@@ -178,7 +178,7 @@ struct drm_encoder *omap_encoder_init(struct drm_device *dev,
	encoder = &omap_encoder->base;

	drm_encoder_init(dev, encoder, &omap_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);
	drm_encoder_helper_add(encoder, &omap_encoder_helper_funcs);

	return encoder;
diff --git a/drivers/gpu/drm/omapdrm/omap_fb.c b/drivers/gpu/drm/omapdrm/omap_fb.c
index ad202df..636a1f9 100644
--- a/drivers/gpu/drm/omapdrm/omap_fb.c
+++ b/drivers/gpu/drm/omapdrm/omap_fb.c
@@ -364,7 +364,7 @@ void omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)
 #endif

 struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
-		struct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd)
+		struct drm_file *file, struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_gem_object *bos[4];
	struct drm_framebuffer *fb;
@@ -386,7 +386,7 @@ struct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,
 }

 struct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,
-		const struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)
+		struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)
 {
	struct omap_framebuffer *omap_fb = NULL;
	struct drm_framebuffer *fb = NULL;
diff --git a/drivers/gpu/drm/omapdrm/omap_plane.c b/drivers/gpu/drm/omapdrm/omap_plane.c
index d5ecabd..3054bda 100644
--- a/drivers/gpu/drm/omapdrm/omap_plane.c
+++ b/drivers/gpu/drm/omapdrm/omap_plane.c
@@ -366,7 +366,7 @@ struct drm_plane *omap_plane_init(struct drm_device *dev,

	ret = drm_universal_plane_init(dev, plane, (1 << priv->num_crtcs) - 1,
				       &omap_plane_funcs, omap_plane->formats,
-				       omap_plane->nformats, type, NULL);
+				       omap_plane->nformats, type);
	if (ret < 0)
		goto error;

diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 1db9257..f97b73e 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -721,9 +721,9 @@ static const struct display_timing hannstar_hsd070pww1_timing = {
	.hsync_len = { 58, 158, 661 },
	.vactive = { 800, 800, 800 },
	.vfront_porch = { 1, 1, 10 },
-	.vback_porch = { 2, 2, 10 },
+	.vback_porch = { 1, 1, 10 },
	.vsync_len = { 1, 21, 203 },
-	.flags = /*DISPLAY_FLAGS_DE_HIGH*/0,
+	.flags = DISPLAY_FLAGS_DE_HIGH,
 };

 static const struct panel_desc hannstar_hsd070pww1 = {
diff --git a/drivers/gpu/drm/qxl/qxl_display.c b/drivers/gpu/drm/qxl/qxl_display.c
index 57a11c7..183aea1 100644
--- a/drivers/gpu/drm/qxl/qxl_display.c
+++ b/drivers/gpu/drm/qxl/qxl_display.c
@@ -521,7 +521,7 @@ static const struct drm_framebuffer_funcs qxl_fb_funcs = {
 int
 qxl_framebuffer_init(struct drm_device *dev,
		     struct qxl_framebuffer *qfb,
-		     const struct drm_mode_fb_cmd2 *mode_cmd,
+		     struct drm_mode_fb_cmd2 *mode_cmd,
		     struct drm_gem_object *obj)
 {
	int ret;
@@ -980,7 +980,7 @@ static int qdev_output_init(struct drm_device *dev, int num_output)
			   &qxl_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);

	drm_encoder_init(dev, &qxl_output->enc, &qxl_enc_funcs,
-			 DRM_MODE_ENCODER_VIRTUAL, NULL);
+			 DRM_MODE_ENCODER_VIRTUAL);

	/* we get HPD via client monitors config */
	connector->polled = DRM_CONNECTOR_POLL_HPD;
@@ -1003,7 +1003,7 @@ static int qdev_output_init(struct drm_device *dev, int num_output)
 static struct drm_framebuffer *
 qxl_user_framebuffer_create(struct drm_device *dev,
			    struct drm_file *file_priv,
-			    const struct drm_mode_fb_cmd2 *mode_cmd)
+			    struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_gem_object *obj;
	struct qxl_framebuffer *qxl_fb;
diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h
index 6e6b9b1..01a8694 100644
--- a/drivers/gpu/drm/qxl/qxl_drv.h
+++ b/drivers/gpu/drm/qxl/qxl_drv.h
@@ -390,7 +390,7 @@ void qxl_fbdev_set_suspend(struct qxl_device *qdev, int state);
 int
 qxl_framebuffer_init(struct drm_device *dev,
		     struct qxl_framebuffer *rfb,
-		     const struct drm_mode_fb_cmd2 *mode_cmd,
+		     struct drm_mode_fb_cmd2 *mode_cmd,
		     struct drm_gem_object *obj);
 void qxl_display_read_client_monitors_config(struct qxl_device *qdev);
 void qxl_send_monitors_config(struct qxl_device *qdev);
diff --git a/drivers/gpu/drm/qxl/qxl_fb.c b/drivers/gpu/drm/qxl/qxl_fb.c
index 11f543b..c4a5526 100644
--- a/drivers/gpu/drm/qxl/qxl_fb.c
+++ b/drivers/gpu/drm/qxl/qxl_fb.c
@@ -283,7 +283,7 @@ int qxl_get_handle_for_primary_fb(struct qxl_device *qdev,
 }

 static int qxlfb_create_pinned_object(struct qxl_fbdev *qfbdev,
-				      const struct drm_mode_fb_cmd2 *mode_cmd,
+				      struct drm_mode_fb_cmd2 *mode_cmd,
				      struct drm_gem_object **gobj_p)
 {
	struct qxl_device *qdev = qfbdev->qdev;
diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c
index 01b20e1..bb29214 100644
--- a/drivers/gpu/drm/radeon/atombios_encoders.c
+++ b/drivers/gpu/drm/radeon/atombios_encoders.c
@@ -2767,27 +2767,23 @@ radeon_add_atom_encoder(struct drm_device *dev,
	case ENCODER_OBJECT_ID_INTERNAL_LVTM1:
		if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
			radeon_encoder->rmx_type = RMX_FULL;
-			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_LVDS);
			radeon_encoder->enc_priv = radeon_atombios_get_lvds_info(radeon_encoder);
		} else {
-			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_TMDS);
			radeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);
		}
		drm_encoder_helper_add(encoder, &radeon_atom_dig_helper_funcs);
		break;
	case ENCODER_OBJECT_ID_INTERNAL_DAC1:
-		drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,
-				 DRM_MODE_ENCODER_DAC, NULL);
+		drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_DAC);
		radeon_encoder->enc_priv = radeon_atombios_set_dac_info(radeon_encoder);
		drm_encoder_helper_add(encoder, &radeon_atom_dac_helper_funcs);
		break;
	case ENCODER_OBJECT_ID_INTERNAL_DAC2:
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
-		drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,
-				 DRM_MODE_ENCODER_TVDAC, NULL);
+		drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_TVDAC);
		radeon_encoder->enc_priv = radeon_atombios_set_dac_info(radeon_encoder);
		drm_encoder_helper_add(encoder, &radeon_atom_dac_helper_funcs);
		break;
@@ -2801,16 +2797,13 @@ radeon_add_atom_encoder(struct drm_device *dev,
	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:
		if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
			radeon_encoder->rmx_type = RMX_FULL;
-			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_LVDS);
			radeon_encoder->enc_priv = radeon_atombios_get_lvds_info(radeon_encoder);
		} else if (radeon_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT)) {
-			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_DAC);
			radeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);
		} else {
-			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_TMDS);
			radeon_encoder->enc_priv = radeon_atombios_set_dig_info(radeon_encoder);
		}
		drm_encoder_helper_add(encoder, &radeon_atom_dig_helper_funcs);
@@ -2827,14 +2820,11 @@ radeon_add_atom_encoder(struct drm_device *dev,
		/* these are handled by the primary encoders */
		radeon_encoder->is_ext_encoder = true;
		if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
-			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,
-					 DRM_MODE_ENCODER_LVDS, NULL);
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_LVDS);
		else if (radeon_encoder->devices & (ATOM_DEVICE_CRT_SUPPORT))
-			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,
-					 DRM_MODE_ENCODER_DAC, NULL);
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_DAC);
		else
-			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs,
-					 DRM_MODE_ENCODER_TMDS, NULL);
+			drm_encoder_init(dev, encoder, &radeon_atom_enc_funcs, DRM_MODE_ENCODER_TMDS);
		drm_encoder_helper_add(encoder, &radeon_atom_ext_helper_funcs);
		break;
	}
diff --git a/drivers/gpu/drm/radeon/radeon_display.c b/drivers/gpu/drm/radeon/radeon_display.c
index bfcef4d..3645b22 100644
--- a/drivers/gpu/drm/radeon/radeon_display.c
+++ b/drivers/gpu/drm/radeon/radeon_display.c
@@ -1344,7 +1344,7 @@ static const struct drm_framebuffer_funcs radeon_fb_funcs = {
 int
 radeon_framebuffer_init(struct drm_device *dev,
			struct radeon_framebuffer *rfb,
-			const struct drm_mode_fb_cmd2 *mode_cmd,
+			struct drm_mode_fb_cmd2 *mode_cmd,
			struct drm_gem_object *obj)
 {
	int ret;
@@ -1361,7 +1361,7 @@ radeon_framebuffer_init(struct drm_device *dev,
 static struct drm_framebuffer *
 radeon_user_framebuffer_create(struct drm_device *dev,
			       struct drm_file *file_priv,
-			       const struct drm_mode_fb_cmd2 *mode_cmd)
+			       struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_gem_object *obj;
	struct radeon_framebuffer *radeon_fb;
diff --git a/drivers/gpu/drm/radeon/radeon_dp_mst.c b/drivers/gpu/drm/radeon/radeon_dp_mst.c
index 94323f5..744f5c4 100644
--- a/drivers/gpu/drm/radeon/radeon_dp_mst.c
+++ b/drivers/gpu/drm/radeon/radeon_dp_mst.c
@@ -641,7 +641,7 @@ radeon_dp_create_fake_mst_encoder(struct radeon_connector *connector)
	}

	drm_encoder_init(dev, &radeon_encoder->base, &radeon_dp_mst_enc_funcs,
-			 DRM_MODE_ENCODER_DPMST, NULL);
+			 DRM_MODE_ENCODER_DPMST);
	drm_encoder_helper_add(encoder, &radeon_mst_helper_funcs);

	mst_enc = radeon_encoder->enc_priv;
diff --git a/drivers/gpu/drm/radeon/radeon_legacy_encoders.c b/drivers/gpu/drm/radeon/radeon_legacy_encoders.c
index 88dc973..30de433 100644
--- a/drivers/gpu/drm/radeon/radeon_legacy_encoders.c
+++ b/drivers/gpu/drm/radeon/radeon_legacy_encoders.c
@@ -1772,8 +1772,7 @@ radeon_add_legacy_encoder(struct drm_device *dev, uint32_t encoder_enum, uint32_
	switch (radeon_encoder->encoder_id) {
	case ENCODER_OBJECT_ID_INTERNAL_LVDS:
		encoder->possible_crtcs = 0x1;
-		drm_encoder_init(dev, encoder, &radeon_legacy_lvds_enc_funcs,
-				 DRM_MODE_ENCODER_LVDS, NULL);
+		drm_encoder_init(dev, encoder, &radeon_legacy_lvds_enc_funcs, DRM_MODE_ENCODER_LVDS);
		drm_encoder_helper_add(encoder, &radeon_legacy_lvds_helper_funcs);
		if (rdev->is_atom_bios)
			radeon_encoder->enc_priv = radeon_atombios_get_lvds_info(radeon_encoder);
@@ -1782,14 +1781,12 @@ radeon_add_legacy_encoder(struct drm_device *dev, uint32_t encoder_enum, uint32_
		radeon_encoder->rmx_type = RMX_FULL;
		break;
	case ENCODER_OBJECT_ID_INTERNAL_TMDS1:
-		drm_encoder_init(dev, encoder, &radeon_legacy_tmds_int_enc_funcs,
-				 DRM_MODE_ENCODER_TMDS, NULL);
+		drm_encoder_init(dev, encoder, &radeon_legacy_tmds_int_enc_funcs, DRM_MODE_ENCODER_TMDS);
		drm_encoder_helper_add(encoder, &radeon_legacy_tmds_int_helper_funcs);
		radeon_encoder->enc_priv = radeon_legacy_get_tmds_info(radeon_encoder);
		break;
	case ENCODER_OBJECT_ID_INTERNAL_DAC1:
-		drm_encoder_init(dev, encoder, &radeon_legacy_primary_dac_enc_funcs,
-				 DRM_MODE_ENCODER_DAC, NULL);
+		drm_encoder_init(dev, encoder, &radeon_legacy_primary_dac_enc_funcs, DRM_MODE_ENCODER_DAC);
		drm_encoder_helper_add(encoder, &radeon_legacy_primary_dac_helper_funcs);
		if (rdev->is_atom_bios)
			radeon_encoder->enc_priv = radeon_atombios_get_primary_dac_info(radeon_encoder);
@@ -1797,8 +1794,7 @@ radeon_add_legacy_encoder(struct drm_device *dev, uint32_t encoder_enum, uint32_
			radeon_encoder->enc_priv = radeon_combios_get_primary_dac_info(radeon_encoder);
		break;
	case ENCODER_OBJECT_ID_INTERNAL_DAC2:
-		drm_encoder_init(dev, encoder, &radeon_legacy_tv_dac_enc_funcs,
-				 DRM_MODE_ENCODER_TVDAC, NULL);
+		drm_encoder_init(dev, encoder, &radeon_legacy_tv_dac_enc_funcs, DRM_MODE_ENCODER_TVDAC);
		drm_encoder_helper_add(encoder, &radeon_legacy_tv_dac_helper_funcs);
		if (rdev->is_atom_bios)
			radeon_encoder->enc_priv = radeon_atombios_get_tv_dac_info(radeon_encoder);
@@ -1806,8 +1802,7 @@ radeon_add_legacy_encoder(struct drm_device *dev, uint32_t encoder_enum, uint32_
			radeon_encoder->enc_priv = radeon_combios_get_tv_dac_info(radeon_encoder);
		break;
	case ENCODER_OBJECT_ID_INTERNAL_DVO1:
-		drm_encoder_init(dev, encoder, &radeon_legacy_tmds_ext_enc_funcs,
-				 DRM_MODE_ENCODER_TMDS, NULL);
+		drm_encoder_init(dev, encoder, &radeon_legacy_tmds_ext_enc_funcs, DRM_MODE_ENCODER_TMDS);
		drm_encoder_helper_add(encoder, &radeon_legacy_tmds_ext_helper_funcs);
		if (!rdev->is_atom_bios)
			radeon_encoder->enc_priv = radeon_legacy_get_ext_tmds_info(radeon_encoder);
diff --git a/drivers/gpu/drm/radeon/radeon_mode.h b/drivers/gpu/drm/radeon/radeon_mode.h
index cddd41b..bba1126 100644
--- a/drivers/gpu/drm/radeon/radeon_mode.h
+++ b/drivers/gpu/drm/radeon/radeon_mode.h
@@ -934,7 +934,7 @@ extern void radeon_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green
				     u16 *blue, int regno);
 int radeon_framebuffer_init(struct drm_device *dev,
			     struct radeon_framebuffer *rfb,
-			     const struct drm_mode_fb_cmd2 *mode_cmd,
+			     struct drm_mode_fb_cmd2 *mode_cmd,
			     struct drm_gem_object *obj);

 int radeonfb_remove(struct drm_device *dev, struct drm_framebuffer *fb);
diff --git a/drivers/gpu/drm/rcar-du/Kconfig b/drivers/gpu/drm/rcar-du/Kconfig
index 2e5ea0e..ba1c43a 100644
--- a/drivers/gpu/drm/rcar-du/Kconfig
+++ b/drivers/gpu/drm/rcar-du/Kconfig
@@ -1,7 +1,6 @@
 config DRM_RCAR_DU
	tristate "DRM Support for R-Car Display Unit"
-	depends on DRM && HAVE_DMA_ATTRS && OF
-	depends on ARM || ARM64
+	depends on DRM && ARM && HAVE_DMA_ATTRS && OF
	depends on ARCH_SHMOBILE || COMPILE_TEST
	select DRM_KMS_HELPER
	select DRM_KMS_CMA_HELPER
@@ -15,19 +14,14 @@ config DRM_RCAR_DU
 config DRM_RCAR_HDMI
	bool "R-Car DU HDMI Encoder Support"
	depends on DRM_RCAR_DU
+	depends on OF
	help
	  Enable support for external HDMI encoders.

 config DRM_RCAR_LVDS
	bool "R-Car DU LVDS Encoder Support"
	depends on DRM_RCAR_DU
-	select DRM_PANEL
+	depends on ARCH_R8A7790 || ARCH_R8A7791 || ARCH_R8A7743 || COMPILE_TEST
	help
-	  Enable support for the R-Car Display Unit embedded LVDS encoders.
-
-config DRM_RCAR_VSP
-       bool "R-Car DU VSP Compositor Support"
-       depends on DRM_RCAR_DU
-       depends on VIDEO_RENESAS_VSP1
-       help
-         Enable support to expose the R-Car VSP Compositor as KMS planes.
+	  Enable support for the R-Car Display Unit embedded LVDS encoders
+	  (currently only on R8A7790, R8A7791 and R8A7743).
diff --git a/drivers/gpu/drm/rcar-du/Makefile b/drivers/gpu/drm/rcar-du/Makefile
index 827711e..05de1c4 100644
--- a/drivers/gpu/drm/rcar-du/Makefile
+++ b/drivers/gpu/drm/rcar-du/Makefile
@@ -11,6 +11,4 @@ rcar-du-drm-$(CONFIG_DRM_RCAR_HDMI)	+= rcar_du_hdmicon.o \
					   rcar_du_hdmienc.o
 rcar-du-drm-$(CONFIG_DRM_RCAR_LVDS)	+= rcar_du_lvdsenc.o

-rcar-du-drm-$(CONFIG_DRM_RCAR_VSP)	+= rcar_du_vsp.o
-
 obj-$(CONFIG_DRM_RCAR_DU)		+= rcar-du-drm.o
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
index a989e89..aac0037 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.c
@@ -1,7 +1,7 @@
 /*
  * rcar_du_crtc.c  --  R-Car Display Unit CRTCs
  *
- * Copyright (C) 2013-2015 Renesas Electronics Corporation
+ * Copyright (C) 2013-2014 Renesas Electronics Corporation
  *
  * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
  *
@@ -28,7 +28,6 @@
 #include "rcar_du_kms.h"
 #include "rcar_du_plane.h"
 #include "rcar_du_regs.h"
-#include "rcar_du_vsp.h"

 static u32 rcar_du_crtc_read(struct rcar_du_crtc *rcrtc, u32 reg)
 {
@@ -208,7 +207,6 @@ plane_format(struct rcar_du_plane *plane)
 static void rcar_du_crtc_update_planes(struct rcar_du_crtc *rcrtc)
 {
	struct rcar_du_plane *planes[RCAR_DU_NUM_HW_PLANES];
-	struct rcar_du_device *rcdu = rcrtc->group->dev;
	unsigned int num_planes = 0;
	unsigned int dptsr_planes;
	unsigned int hwplanes = 0;
@@ -252,28 +250,6 @@ static void rcar_du_crtc_update_planes(struct rcar_du_crtc *rcrtc)
		}
	}

-	/* If VSP+DU integration is enabled the plane assignment is fixed. */
-	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE)) {
-		if (rcdu->info->gen < 3) {
-			if (rcrtc->vsp->vsp) {
-				dspr = (rcrtc->index % 2) + 1;
-				hwplanes = 1 << (rcrtc->index % 2);
-			}
-			else {
-				for (i = 0; i < rcrtc->vsp->num_planes; ++i) {
-					struct rcar_du_vsp_plane * plane = &rcrtc->vsp->planes[i];
-					if (plane->plane.state->crtc != &rcrtc->crtc)
-						continue;
-					dspr |= (plane->index + 5) << 4*i;
-					hwplanes |= 1 << (plane->index + 4);
-				}
-			}
-		} else {
-			dspr = (rcrtc->index % 2) ? 3 : 1;
-			hwplanes = 1 << ((rcrtc->index % 2) ? 2 : 0);
-		}
-	}
-
	/* Update the planes to display timing and dot clock generator
	 * associations.
	 *
@@ -296,10 +272,6 @@ static void rcar_du_crtc_update_planes(struct rcar_du_crtc *rcrtc)
			rcar_du_group_restart(rcrtc->group);
	}

-	/* Restart the group if plane sources have changed. */
-	if (rcrtc->group->need_restart)
-		rcar_du_group_restart(rcrtc->group);
-
	mutex_unlock(&rcrtc->group->lock);

	rcar_du_group_write(rcrtc->group, rcrtc->index % 2 ? DS2PR : DS1PR,
@@ -413,10 +385,6 @@ static void rcar_du_crtc_start(struct rcar_du_crtc *rcrtc)

	rcar_du_group_start_stop(rcrtc->group, true);

-	/* Enable the VSP compositor. */
-	if (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))
-		rcar_du_vsp_enable(rcrtc);
-
	/* Turn vertical blanking interrupt reporting back on. */
	drm_crtc_vblank_on(crtc);

@@ -450,10 +418,6 @@ static void rcar_du_crtc_stop(struct rcar_du_crtc *rcrtc)
	rcar_du_crtc_wait_page_flip(rcrtc);
	drm_crtc_vblank_off(crtc);

-	/* Disable the VSP compositor. */
-	if (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))
-		rcar_du_vsp_disable(rcrtc);
-
	/* Select switch sync mode. This stops display operation and configures
	 * the HSYNC and VSYNC signals as inputs.
	 */
@@ -466,9 +430,6 @@ static void rcar_du_crtc_stop(struct rcar_du_crtc *rcrtc)

 void rcar_du_crtc_suspend(struct rcar_du_crtc *rcrtc)
 {
-	if (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))
-		rcar_du_vsp_disable(rcrtc);
-
	rcar_du_crtc_stop(rcrtc);
	rcar_du_crtc_put(rcrtc);
 }
@@ -484,17 +445,13 @@ void rcar_du_crtc_resume(struct rcar_du_crtc *rcrtc)
	rcar_du_crtc_start(rcrtc);

	/* Commit the planes state. */
-	if (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE)) {
-		rcar_du_vsp_enable(rcrtc);
-	} else {
-		for (i = 0; i < rcrtc->group->num_planes; ++i) {
-			struct rcar_du_plane *plane = &rcrtc->group->planes[i];
+	for (i = 0; i < rcrtc->group->num_planes; ++i) {
+		struct rcar_du_plane *plane = &rcrtc->group->planes[i];

-			if (plane->plane.state->crtc != &rcrtc->crtc)
-				continue;
+		if (plane->plane.state->crtc != &rcrtc->crtc)
+			continue;

-			rcar_du_plane_setup(plane);
-		}
+		rcar_du_plane_setup(plane);
	}

	rcar_du_crtc_update_planes(rcrtc);
@@ -554,9 +511,6 @@ static void rcar_du_crtc_atomic_begin(struct drm_crtc *crtc,
		rcrtc->event = event;
		spin_unlock_irqrestore(&dev->event_lock, flags);
	}
-
-	if (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))
-		rcar_du_vsp_atomic_begin(rcrtc);
 }

 static void rcar_du_crtc_atomic_flush(struct drm_crtc *crtc,
@@ -565,9 +519,6 @@ static void rcar_du_crtc_atomic_flush(struct drm_crtc *crtc,
	struct rcar_du_crtc *rcrtc = to_rcar_crtc(crtc);

	rcar_du_crtc_update_planes(rcrtc);
-
-	if (rcar_du_has(rcrtc->group->dev, RCAR_DU_FEATURE_VSP1_SOURCE))
-		rcar_du_vsp_atomic_flush(rcrtc);
 }

 static const struct drm_crtc_helper_funcs crtc_helper_funcs = {
@@ -616,14 +567,13 @@ static irqreturn_t rcar_du_crtc_irq(int irq, void *arg)
 int rcar_du_crtc_create(struct rcar_du_group *rgrp, unsigned int index)
 {
	static const unsigned int mmio_offsets[] = {
-		DU0_REG_OFFSET, DU1_REG_OFFSET, DU2_REG_OFFSET, DU3_REG_OFFSET
+		DU0_REG_OFFSET, DU1_REG_OFFSET, DU2_REG_OFFSET
	};

	struct rcar_du_device *rcdu = rgrp->dev;
	struct platform_device *pdev = to_platform_device(rcdu->dev);
	struct rcar_du_crtc *rcrtc = &rcdu->crtcs[index];
	struct drm_crtc *crtc = &rcrtc->crtc;
-	struct drm_plane *primary;
	unsigned int irqflags;
	struct clk *clk;
	char clk_name[9];
@@ -661,13 +611,9 @@ int rcar_du_crtc_create(struct rcar_du_group *rgrp, unsigned int index)
	rcrtc->index = index;
	rcrtc->enabled = false;

-	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE))
-		primary = &rcrtc->vsp->planes[0].plane;
-	else
-		primary = &rgrp->planes[index % 2].plane;
-
-	ret = drm_crtc_init_with_planes(rcdu->ddev, crtc, primary,
-					NULL, &crtc_funcs, NULL);
+	ret = drm_crtc_init_with_planes(rcdu->ddev, crtc,
+					&rgrp->planes[index % 2].plane,
+					NULL, &crtc_funcs);
	if (ret < 0)
		return ret;

diff --git a/drivers/gpu/drm/rcar-du/rcar_du_crtc.h b/drivers/gpu/drm/rcar-du/rcar_du_crtc.h
index c7ab467..4b95d9d 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_crtc.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_crtc.h
@@ -21,7 +21,6 @@
 #include <drm/drm_crtc.h>

 struct rcar_du_group;
-struct rcar_du_vsp;

 /**
  * struct rcar_du_crtc - the CRTC, representing a DU superposition processor
@@ -53,7 +52,6 @@ struct rcar_du_crtc {
	bool enabled;

	struct rcar_du_group *group;
-	struct rcar_du_vsp *vsp;
 };

 #define to_rcar_crtc(c)	container_of(c, struct rcar_du_crtc, crtc)
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.c b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
index a7a6506..17a0948 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.c
@@ -1,7 +1,7 @@
 /*
  * rcar_du_drv.c  --  R-Car Display Unit DRM driver
  *
- * Copyright (C) 2013-2015 Renesas Electronics Corporation
+ * Copyright (C) 2013-2014 Renesas Electronics Corporation
  *
  * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
  *
@@ -36,7 +36,6 @@
  */

 static const struct rcar_du_device_info rcar_du_r8a7779_info = {
-	.gen = 2,
	.features = 0,
	.num_crtcs = 2,
	.routes = {
@@ -58,7 +57,6 @@ static const struct rcar_du_device_info rcar_du_r8a7779_info = {
 };

 static const struct rcar_du_device_info rcar_du_r8a7790_info = {
-        .gen = 2,
	.features = RCAR_DU_FEATURE_CRTC_IRQ_CLOCK
		  | RCAR_DU_FEATURE_EXT_CTRL_REGS,
	.quirks = RCAR_DU_QUIRK_ALIGN_128B | RCAR_DU_QUIRK_LVDS_LANES,
@@ -88,7 +86,6 @@ static const struct rcar_du_device_info rcar_du_r8a7790_info = {

 /* M2-W (r8a7791) and M2-N (r8a7793) are identical */
 static const struct rcar_du_device_info rcar_du_r8a7791_info = {
-        .gen = 2,
	.features = RCAR_DU_FEATURE_CRTC_IRQ_CLOCK
		  | RCAR_DU_FEATURE_EXT_CTRL_REGS,
	.num_crtcs = 2,
@@ -112,12 +109,9 @@ static const struct rcar_du_device_info rcar_du_r8a7791_info = {


 static const struct rcar_du_device_info rcar_du_r8a7743_info = {
-        .gen = 2,
	.features = RCAR_DU_FEATURE_CRTC_IRQ_CLOCK
-		  | RCAR_DU_FEATURE_EXT_CTRL_REGS
-		  | RCAR_DU_FEATURE_VSP1_SOURCE,
+		  | RCAR_DU_FEATURE_EXT_CTRL_REGS,
	.num_crtcs = 2,
-	.vspd_crtcs = BIT(0) | BIT(1),
	.routes = {
		[RCAR_DU_OUTPUT_DPAD0] = {
			.possible_crtcs = BIT(1) | BIT(0),
@@ -134,7 +128,6 @@ static const struct rcar_du_device_info rcar_du_r8a7743_info = {
 };

 static const struct rcar_du_device_info rcar_du_r8a7794_info = {
-        .gen = 2,
	.features = RCAR_DU_FEATURE_CRTC_IRQ_CLOCK
		  | RCAR_DU_FEATURE_EXT_CTRL_REGS,
	.num_crtcs = 2,
@@ -156,11 +149,9 @@ static const struct rcar_du_device_info rcar_du_r8a7794_info = {
	.num_lvds = 0,
 };
 static const struct rcar_du_device_info rcar_du_r8a7745_info = {
-        .gen = 2,
         .features = RCAR_DU_FEATURE_CRTC_IRQ_CLOCK
                   | RCAR_DU_FEATURE_EXT_CTRL_REGS,
         .num_crtcs = 2,
-        .vspd_crtcs = BIT(0),
         .routes = {
                 /* R8A7745 has two RGB outputs and one (currently unsupported)
                  * TCON output.
@@ -179,31 +170,6 @@ static const struct rcar_du_device_info rcar_du_r8a7745_info = {
         .num_lvds = 0,
 };

-static const struct rcar_du_device_info rcar_du_r8a7795_info = {
-	.gen = 3,
-	.features = RCAR_DU_FEATURE_CRTC_IRQ_CLOCK
-		  | RCAR_DU_FEATURE_EXT_CTRL_REGS
-		  | RCAR_DU_FEATURE_VSP1_SOURCE,
-	.num_crtcs = 4,
-	.routes = {
-		/* R8A7795 has one RGB output, one LVDS output and two
-		 * (currently unsupported) HDMI outputs.
-		 */
-		[RCAR_DU_OUTPUT_DPAD0] = {
-			.possible_crtcs = BIT(3),
-			.encoder_type = DRM_MODE_ENCODER_NONE,
-			.port = 0,
-		},
-		[RCAR_DU_OUTPUT_LVDS0] = {
-			.possible_crtcs = BIT(0),
-			.encoder_type = DRM_MODE_ENCODER_LVDS,
-			.port = 3,
-		},
-
-	},
-	.num_lvds = 1,
-};
-
 static const struct of_device_id rcar_du_of_table[] = {
	{ .compatible = "renesas,du-r8a7779", .data = &rcar_du_r8a7779_info },
	{ .compatible = "renesas,du-r8a7790", .data = &rcar_du_r8a7790_info },
@@ -212,7 +178,6 @@ static const struct of_device_id rcar_du_of_table[] = {
	{ .compatible = "renesas,du-r8a7793", .data = &rcar_du_r8a7791_info },
	{ .compatible = "renesas,du-r8a7794", .data = &rcar_du_r8a7794_info },
	{ .compatible = "renesas,du-r8a7745", .data = &rcar_du_r8a7745_info },
-	{ .compatible = "renesas,du-r8a7795", .data = &rcar_du_r8a7795_info },
	{ }
 };

@@ -222,6 +187,82 @@ MODULE_DEVICE_TABLE(of, rcar_du_of_table);
  * DRM operations
  */

+static int rcar_du_unload(struct drm_device *dev)
+{
+	struct rcar_du_device *rcdu = dev->dev_private;
+
+	if (rcdu->fbdev)
+		drm_fbdev_cma_fini(rcdu->fbdev);
+
+	drm_kms_helper_poll_fini(dev);
+	drm_mode_config_cleanup(dev);
+	drm_vblank_cleanup(dev);
+
+	dev->irq_enabled = 0;
+	dev->dev_private = NULL;
+
+	return 0;
+}
+
+static int rcar_du_load(struct drm_device *dev, unsigned long flags)
+{
+	struct platform_device *pdev = dev->platformdev;
+	struct device_node *np = pdev->dev.of_node;
+	struct rcar_du_device *rcdu;
+	struct resource *mem;
+	int ret;
+
+	if (np == NULL) {
+		dev_err(dev->dev, "no platform data\n");
+		return -ENODEV;
+	}
+
+	rcdu = devm_kzalloc(&pdev->dev, sizeof(*rcdu), GFP_KERNEL);
+	if (rcdu == NULL) {
+		dev_err(dev->dev, "failed to allocate private data\n");
+		return -ENOMEM;
+	}
+
+	init_waitqueue_head(&rcdu->commit.wait);
+
+	rcdu->dev = &pdev->dev;
+	rcdu->info = of_match_device(rcar_du_of_table, rcdu->dev)->data;
+	rcdu->ddev = dev;
+	dev->dev_private = rcdu;
+
+	/* I/O resources */
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	rcdu->mmio = devm_ioremap_resource(&pdev->dev, mem);
+	if (IS_ERR(rcdu->mmio))
+		return PTR_ERR(rcdu->mmio);
+
+	/* Initialize vertical blanking interrupts handling. Start with vblank
+	 * disabled for all CRTCs.
+	 */
+	ret = drm_vblank_init(dev, (1 << rcdu->info->num_crtcs) - 1);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to initialize vblank\n");
+		goto done;
+	}
+
+	/* DRM/KMS objects */
+	ret = rcar_du_modeset_init(rcdu);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to initialize DRM/KMS (%d)\n", ret);
+		goto done;
+	}
+
+	dev->irq_enabled = 1;
+
+	platform_set_drvdata(pdev, rcdu);
+
+done:
+	if (ret)
+		rcar_du_unload(dev);
+
+	return ret;
+}
+
 static void rcar_du_preclose(struct drm_device *dev, struct drm_file *file)
 {
	struct rcar_du_device *rcdu = dev->dev_private;
@@ -271,8 +312,11 @@ static const struct file_operations rcar_du_fops = {
 static struct drm_driver rcar_du_driver = {
	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_PRIME
				| DRIVER_ATOMIC,
+	.load			= rcar_du_load,
+	.unload			= rcar_du_unload,
	.preclose		= rcar_du_preclose,
	.lastclose		= rcar_du_lastclose,
+	.set_busid		= drm_platform_set_busid,
	.get_vblank_counter	= drm_vblank_no_hw_counter,
	.enable_vblank		= rcar_du_enable_vblank,
	.disable_vblank		= rcar_du_disable_vblank,
@@ -332,116 +376,18 @@ static const struct dev_pm_ops rcar_du_pm_ops = {
  * Platform driver
  */

-static int rcar_du_remove(struct platform_device *pdev)
+static int rcar_du_probe(struct platform_device *pdev)
 {
-	struct rcar_du_device *rcdu = platform_get_drvdata(pdev);
-	struct drm_device *ddev = rcdu->ddev;
-
-	mutex_lock(&ddev->mode_config.mutex);
-	drm_connector_unplug_all(ddev);
-	mutex_unlock(&ddev->mode_config.mutex);
-
-	drm_dev_unregister(ddev);
-
-	if (rcdu->fbdev)
-		drm_fbdev_cma_fini(rcdu->fbdev);
-
-	drm_kms_helper_poll_fini(ddev);
-	drm_mode_config_cleanup(ddev);
-	drm_vblank_cleanup(ddev);
-
-	drm_dev_unref(ddev);
-
-	return 0;
+	return drm_platform_init(&rcar_du_driver, pdev);
 }

-static int rcar_du_probe(struct platform_device *pdev)
+static int rcar_du_remove(struct platform_device *pdev)
 {
-	struct device_node *np = pdev->dev.of_node;
-	struct rcar_du_device *rcdu;
-	struct drm_connector *connector;
-	struct drm_device *ddev;
-	struct resource *mem;
-	int ret;
-
-	if (np == NULL) {
-		dev_err(&pdev->dev, "no device tree node\n");
-		return -ENODEV;
-	}
-
-	/* Allocate and initialize the DRM and R-Car device structures. */
-	rcdu = devm_kzalloc(&pdev->dev, sizeof(*rcdu), GFP_KERNEL);
-	if (rcdu == NULL)
-		return -ENOMEM;
-
-	init_waitqueue_head(&rcdu->commit.wait);
-
-	rcdu->dev = &pdev->dev;
-	rcdu->info = of_match_device(rcar_du_of_table, rcdu->dev)->data;
-
-	ddev = drm_dev_alloc(&rcar_du_driver, &pdev->dev);
-	if (!ddev)
-		return -ENOMEM;
-
-	drm_dev_set_unique(ddev, dev_name(&pdev->dev));
-
-	rcdu->ddev = ddev;
-	ddev->dev_private = rcdu;
-
-	platform_set_drvdata(pdev, rcdu);
-
-	/* I/O resources */
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	rcdu->mmio = devm_ioremap_resource(&pdev->dev, mem);
-	if (IS_ERR(rcdu->mmio)) {
-		ret = PTR_ERR(rcdu->mmio);
-		goto error;
-	}
-
-	/* Initialize vertical blanking interrupts handling. Start with vblank
-	 * disabled for all CRTCs.
-	 */
-	ret = drm_vblank_init(ddev, (1 << rcdu->info->num_crtcs) - 1);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "failed to initialize vblank\n");
-		goto error;
-	}
-
-	/* DRM/KMS objects */
-	ret = rcar_du_modeset_init(rcdu);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "failed to initialize DRM/KMS (%d)\n", ret);
-		goto error;
-	}
-
-	ddev->irq_enabled = 1;
-
-	/* Register the DRM device with the core and the connectors with
-	 * sysfs.
-	 */
-	ret = drm_dev_register(ddev, 0);
-	if (ret)
-		goto error;
-
-	mutex_lock(&ddev->mode_config.mutex);
-	drm_for_each_connector(connector, ddev) {
-		ret = drm_connector_register(connector);
-		if (ret < 0)
-			break;
-	}
-	mutex_unlock(&ddev->mode_config.mutex);
-
-	if (ret < 0)
-		goto error;
+	struct rcar_du_device *rcdu = platform_get_drvdata(pdev);

-	DRM_INFO("Device %s probed\n", dev_name(&pdev->dev));
+	drm_put_dev(rcdu->ddev);

	return 0;
-
-error:
-	rcar_du_remove(pdev);
-
-	return ret;
 }

 static struct platform_driver rcar_du_platform_driver = {
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.h b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
index 5527cdf..9f34fc8 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.h
@@ -1,7 +1,7 @@
 /*
  * rcar_du_drv.h  --  R-Car Display Unit DRM driver
  *
- * Copyright (C) 2013-2015 Renesas Electronics Corporation
+ * Copyright (C) 2013-2014 Renesas Electronics Corporation
  *
  * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
  *
@@ -19,7 +19,6 @@

 #include "rcar_du_crtc.h"
 #include "rcar_du_group.h"
-#include "rcar_du_vsp.h"

 struct clk;
 struct device;
@@ -30,7 +29,6 @@ struct rcar_du_lvdsenc;

 #define RCAR_DU_FEATURE_CRTC_IRQ_CLOCK	(1 << 0)	/* Per-CRTC IRQ and clock */
 #define RCAR_DU_FEATURE_EXT_CTRL_REGS	(1 << 1)	/* Has extended control registers */
-#define RCAR_DU_FEATURE_VSP1_SOURCE	(1 << 2)	/* Has inputs from VSP1 */

 #define RCAR_DU_QUIRK_ALIGN_128B	(1 << 0)	/* Align pitches to 128 bytes */
 #define RCAR_DU_QUIRK_LVDS_LANES	(1 << 1)	/* LVDS lanes 1 and 3 inverted */
@@ -53,28 +51,23 @@ struct rcar_du_output_routing {

 /*
  * struct rcar_du_device_info - DU model-specific information
- * @gen: device generation (2 or 3)
  * @features: device features (RCAR_DU_FEATURE_*)
  * @quirks: device quirks (RCAR_DU_QUIRK_*)
  * @num_crtcs: total number of CRTCs
  * @routes: array of CRTC to output routes, indexed by output (RCAR_DU_OUTPUT_*)
  * @num_lvds: number of internal LVDS encoders
- * @vsp_crtcs : number of vspd channel
  */
 struct rcar_du_device_info {
-	unsigned int gen;
	unsigned int features;
	unsigned int quirks;
	unsigned int num_crtcs;
	struct rcar_du_output_routing routes[RCAR_DU_OUTPUT_MAX];
	unsigned int num_lvds;
-	unsigned int vspd_crtcs;
 };

-#define RCAR_DU_MAX_CRTCS		4
+#define RCAR_DU_MAX_CRTCS		3
 #define RCAR_DU_MAX_GROUPS		DIV_ROUND_UP(RCAR_DU_MAX_CRTCS, 2)
 #define RCAR_DU_MAX_LVDS		2
-#define RCAR_DU_MAX_VSPS		4

 struct rcar_du_device {
	struct device *dev;
@@ -89,7 +82,6 @@ struct rcar_du_device {
	unsigned int num_crtcs;

	struct rcar_du_group groups[RCAR_DU_MAX_GROUPS];
-	struct rcar_du_vsp vsps[RCAR_DU_MAX_VSPS];

	struct {
		struct drm_property *alpha;
@@ -98,8 +90,6 @@ struct rcar_du_device {
	} props;

	unsigned int dpad0_source;
-	unsigned int vspd1_sink;
-
	struct rcar_du_lvdsenc *lvds[RCAR_DU_MAX_LVDS];

	struct {
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_encoder.c b/drivers/gpu/drm/rcar-du/rcar_du_encoder.c
index 4e939e4..d0ae1e8 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_encoder.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_encoder.c
@@ -89,8 +89,12 @@ static int rcar_du_encoder_atomic_check(struct drm_encoder *encoder,
	/* The flat panel mode is fixed, just copy it to the adjusted mode. */
	drm_mode_copy(adjusted_mode, panel_mode);

+	/* The internal LVDS encoder has a clock frequency operating range of
+	 * 30MHz to 150MHz. Clamp the clock accordingly.
+	 */
	if (renc->lvds)
-		rcar_du_lvdsenc_atomic_check(renc->lvds, adjusted_mode);
+		adjusted_mode->clock = clamp(adjusted_mode->clock,
+					     30000, 150000);

	return 0;
 }
@@ -169,7 +173,7 @@ int rcar_du_encoder_init(struct rcar_du_device *rcdu,
			goto done;
	} else {
		ret = drm_encoder_init(rcdu->ddev, encoder, &encoder_funcs,
-				       encoder_type, NULL);
+				       encoder_type);
		if (ret < 0)
			goto done;

diff --git a/drivers/gpu/drm/rcar-du/rcar_du_group.c b/drivers/gpu/drm/rcar-du/rcar_du_group.c
index c2efcd2..8e2ffe0 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_group.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_group.c
@@ -1,7 +1,7 @@
 /*
  * rcar_du_group.c  --  R-Car Display Unit Channels Pair
  *
- * Copyright (C) 2013-2015 Renesas Electronics Corporation
+ * Copyright (C) 2013-2014 Renesas Electronics Corporation
  *
  * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
  *
@@ -46,48 +46,25 @@ void rcar_du_group_write(struct rcar_du_group *rgrp, u32 reg, u32 data)

 static void rcar_du_group_setup_defr8(struct rcar_du_group *rgrp)
 {
-	struct rcar_du_device *rcdu = rgrp->dev;
-	unsigned int possible_crtcs =
-		rcdu->info->routes[RCAR_DU_OUTPUT_DPAD0].possible_crtcs;
-	u32 defr8 = DEFR8_CODE;
+	u32 defr8 = DEFR8_CODE | DEFR8_DEFE8;

-	if (rcdu->info->gen < 3) {
-		defr8 |= DEFR8_DEFE8;
-
-		/* On Gen2 the DEFR8 register for the first group also controls
-		 * RGB output routing to DPAD0 and VSPD1 routing to DU0/1/2 for
-		 * DU instances that support it.
-		 */
-		if (rgrp->index == 0) {
-			if (possible_crtcs > 1)
-				defr8 |= DEFR8_DRGBS_DU(rcdu->dpad0_source);
-			if (rgrp->dev->vspd1_sink == 2)
-				defr8 |= DEFR8_VSCS;
-		}
-	} else {
-		/* On Gen3 VSPD routing can't be configured, but DPAD routing
-		 * needs to be set despite having a single option available.
-		 */
-		u32 crtc = ffs(possible_crtcs) - 1;
-
-		if (crtc / 2 == rgrp->index)
-			defr8 |= DEFR8_DRGBS_DU(crtc);
-	}
+	/* The DEFR8 register for the first group also controls RGB output
+	 * routing to DPAD0 for DU instances that support it.
+	 */
+	if (rgrp->dev->info->routes[RCAR_DU_OUTPUT_DPAD0].possible_crtcs > 1 &&
+	    rgrp->index == 0)
+		defr8 |= DEFR8_DRGBS_DU(rgrp->dev->dpad0_source);

	rcar_du_group_write(rgrp, DEFR8, defr8);
 }

 static void rcar_du_group_setup(struct rcar_du_group *rgrp)
 {
-	struct rcar_du_device *rcdu = rgrp->dev;
-
	/* Enable extended features */
	rcar_du_group_write(rgrp, DEFR, DEFR_CODE | DEFR_DEFE);
-	if (rcdu->info->gen < 3) {
-		rcar_du_group_write(rgrp, DEFR2, DEFR2_CODE | DEFR2_DEFE2G);
-		rcar_du_group_write(rgrp, DEFR3, DEFR3_CODE | DEFR3_DEFE3);
-		rcar_du_group_write(rgrp, DEFR4, DEFR4_CODE);
-	}
+	rcar_du_group_write(rgrp, DEFR2, DEFR2_CODE | DEFR2_DEFE2G);
+	rcar_du_group_write(rgrp, DEFR3, DEFR3_CODE | DEFR3_DEFE3);
+	rcar_du_group_write(rgrp, DEFR4, DEFR4_CODE);
	rcar_du_group_write(rgrp, DEFR5, DEFR5_CODE | DEFR5_DEFE5);

	if (rcar_du_has(rgrp->dev, RCAR_DU_FEATURE_EXT_CTRL_REGS)) {
@@ -105,9 +82,6 @@ static void rcar_du_group_setup(struct rcar_du_group *rgrp)
				    DIDSR_PDCS_CLK(0, 0));
	}

-	if (rcdu->info->gen >= 3)
-		rcar_du_group_write(rgrp, DEFR10, DEFR10_CODE | DEFR10_DEFE10);
-
	/* Use DS1PR and DS2PR to configure planes priorities and connects the
	 * superposition 0 to DU0 pins. DU1 pins will be configured dynamically.
	 */
@@ -184,23 +158,21 @@ void rcar_du_group_start_stop(struct rcar_du_group *rgrp, bool start)

 void rcar_du_group_restart(struct rcar_du_group *rgrp)
 {
-	rgrp->need_restart = false;
-
	__rcar_du_group_start_stop(rgrp, false);
	__rcar_du_group_start_stop(rgrp, true);
 }

-int rcar_du_set_dpad0_vsp1_routing(struct rcar_du_device *rcdu)
+static int rcar_du_set_dpad0_routing(struct rcar_du_device *rcdu)
 {
	int ret;

	if (!rcar_du_has(rcdu, RCAR_DU_FEATURE_EXT_CTRL_REGS))
		return 0;

-	/* RGB output routing to DPAD0 and VSP1D routing to DU0/1/2 are
-	 * configured in the DEFR8 register of the first group. As this function
-	 * can be called with the DU0 and DU1 CRTCs disabled, we need to enable
-	 * the first group clock before accessing the register.
+	/* RGB output routing to DPAD0 is configured in the DEFR8 register of
+	 * the first group. As this function can be called with the DU0 and DU1
+	 * CRTCs disabled, we need to enable the first group clock before
+	 * accessing the register.
	 */
	ret = clk_prepare_enable(rcdu->crtcs[0].clock);
	if (ret < 0)
@@ -231,5 +203,5 @@ int rcar_du_group_set_routing(struct rcar_du_group *rgrp)

	rcar_du_group_write(rgrp, DORCR, dorcr);

-	return rcar_du_set_dpad0_vsp1_routing(rgrp->dev);
+	return rcar_du_set_dpad0_routing(rgrp->dev);
 }
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_group.h b/drivers/gpu/drm/rcar-du/rcar_du_group.h
index 5e3adc6..d7318e1 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_group.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_group.h
@@ -32,7 +32,6 @@ struct rcar_du_device;
  * @dptsr_planes: bitmask of planes driven by dot-clock and timing generator 1
  * @num_planes: number of planes in the group
  * @planes: planes handled by the group
- * @need_restart: the group needs to be restarted due to a configuration change
  */
 struct rcar_du_group {
	struct rcar_du_device *dev;
@@ -48,7 +47,6 @@ struct rcar_du_group {

	unsigned int num_planes;
	struct rcar_du_plane planes[RCAR_DU_NUM_KMS_PLANES];
-	bool need_restart;
 };

 u32 rcar_du_group_read(struct rcar_du_group *rgrp, u32 reg);
@@ -60,6 +58,4 @@ void rcar_du_group_start_stop(struct rcar_du_group *rgrp, bool start);
 void rcar_du_group_restart(struct rcar_du_group *rgrp);
 int rcar_du_group_set_routing(struct rcar_du_group *rgrp);

-int rcar_du_set_dpad0_vsp1_routing(struct rcar_du_device *rcdu);
-
 #endif /* __RCAR_DU_GROUP_H__ */
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_hdmicon.c b/drivers/gpu/drm/rcar-du/rcar_du_hdmicon.c
index 6c92714..96f2eb4 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_hdmicon.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_hdmicon.c
@@ -28,7 +28,7 @@ static int rcar_du_hdmi_connector_get_modes(struct drm_connector *connector)
 {
	struct rcar_du_connector *con = to_rcar_connector(connector);
	struct drm_encoder *encoder = rcar_encoder_to_drm_encoder(con->encoder);
-	const struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);
+	struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);

	if (sfuncs->get_modes == NULL)
		return 0;
@@ -41,7 +41,7 @@ static int rcar_du_hdmi_connector_mode_valid(struct drm_connector *connector,
 {
	struct rcar_du_connector *con = to_rcar_connector(connector);
	struct drm_encoder *encoder = rcar_encoder_to_drm_encoder(con->encoder);
-	const struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);
+	struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);

	if (sfuncs->mode_valid == NULL)
		return MODE_OK;
@@ -55,12 +55,18 @@ static const struct drm_connector_helper_funcs connector_helper_funcs = {
	.best_encoder = rcar_du_connector_best_encoder,
 };

+static void rcar_du_hdmi_connector_destroy(struct drm_connector *connector)
+{
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+
 static enum drm_connector_status
 rcar_du_hdmi_connector_detect(struct drm_connector *connector, bool force)
 {
	struct rcar_du_connector *con = to_rcar_connector(connector);
	struct drm_encoder *encoder = rcar_encoder_to_drm_encoder(con->encoder);
-	const struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);
+	struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);

	if (sfuncs->detect == NULL)
		return connector_status_unknown;
@@ -73,7 +79,7 @@ static const struct drm_connector_funcs connector_funcs = {
	.reset = drm_atomic_helper_connector_reset,
	.detect = rcar_du_hdmi_connector_detect,
	.fill_modes = drm_helper_probe_single_connector_modes,
-	.destroy = drm_connector_cleanup,
+	.destroy = rcar_du_hdmi_connector_destroy,
	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
 };
@@ -102,6 +108,9 @@ int rcar_du_hdmi_connector_init(struct rcar_du_device *rcdu,
		return ret;

	drm_connector_helper_add(connector, &connector_helper_funcs);
+	ret = drm_connector_register(connector);
+	if (ret < 0)
+		return ret;

	connector->dpms = DRM_MODE_DPMS_OFF;
	drm_object_property_set_value(&connector->base,
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_hdmienc.c b/drivers/gpu/drm/rcar-du/rcar_du_hdmienc.c
index 461662d..81da841 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_hdmienc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_hdmienc.c
@@ -35,7 +35,7 @@ struct rcar_du_hdmienc {
 static void rcar_du_hdmienc_disable(struct drm_encoder *encoder)
 {
	struct rcar_du_hdmienc *hdmienc = to_rcar_hdmienc(encoder);
-	const struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);
+	struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);

	if (sfuncs->dpms)
		sfuncs->dpms(encoder, DRM_MODE_DPMS_OFF);
@@ -50,7 +50,7 @@ static void rcar_du_hdmienc_disable(struct drm_encoder *encoder)
 static void rcar_du_hdmienc_enable(struct drm_encoder *encoder)
 {
	struct rcar_du_hdmienc *hdmienc = to_rcar_hdmienc(encoder);
-	const struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);
+	struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);

	if (hdmienc->renc->lvds)
		rcar_du_lvdsenc_enable(hdmienc->renc->lvds, encoder->crtc,
@@ -67,13 +67,16 @@ static int rcar_du_hdmienc_atomic_check(struct drm_encoder *encoder,
					struct drm_connector_state *conn_state)
 {
	struct rcar_du_hdmienc *hdmienc = to_rcar_hdmienc(encoder);
-	const struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);
+	struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);
	struct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;
	const struct drm_display_mode *mode = &crtc_state->mode;

+	/* The internal LVDS encoder has a clock frequency operating range of
+	 * 30MHz to 150MHz. Clamp the clock accordingly.
+	 */
	if (hdmienc->renc->lvds)
-		rcar_du_lvdsenc_atomic_check(hdmienc->renc->lvds,
-					     adjusted_mode);
+		adjusted_mode->clock = clamp(adjusted_mode->clock,
+					     30000, 150000);

	if (sfuncs->mode_fixup == NULL)
		return 0;
@@ -86,7 +89,7 @@ static void rcar_du_hdmienc_mode_set(struct drm_encoder *encoder,
				     struct drm_display_mode *adjusted_mode)
 {
	struct rcar_du_hdmienc *hdmienc = to_rcar_hdmienc(encoder);
-	const struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);
+	struct drm_encoder_slave_funcs *sfuncs = to_slave_funcs(encoder);

	if (sfuncs->mode_set)
		sfuncs->mode_set(encoder, mode, adjusted_mode);
@@ -131,19 +134,12 @@ int rcar_du_hdmienc_init(struct rcar_du_device *rcdu,

	/* Locate the slave I2C device and driver. */
	i2c_slave = of_find_i2c_device_by_node(np);
-	if (!i2c_slave || !i2c_get_clientdata(i2c_slave)) {
-		dev_dbg(rcdu->dev,
-			"can't get I2C slave for %s, deferring probe\n",
-			of_node_full_name(np));
+	if (!i2c_slave || !i2c_get_clientdata(i2c_slave))
		return -EPROBE_DEFER;
-	}

	hdmienc->dev = &i2c_slave->dev;

	if (hdmienc->dev->driver == NULL) {
-		dev_dbg(rcdu->dev,
-			"I2C slave %s not probed yet, deferring probe\n",
-			dev_name(hdmienc->dev));
		ret = -EPROBE_DEFER;
		goto error;
	}
@@ -155,7 +151,7 @@ int rcar_du_hdmienc_init(struct rcar_du_device *rcdu,
		goto error;

	ret = drm_encoder_init(rcdu->ddev, encoder, &encoder_funcs,
-			       DRM_MODE_ENCODER_TMDS, NULL);
+			       DRM_MODE_ENCODER_TMDS);
	if (ret < 0)
		goto error;

diff --git a/drivers/gpu/drm/rcar-du/rcar_du_kms.c b/drivers/gpu/drm/rcar-du/rcar_du_kms.c
index 4f48237..ca12e8c 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_kms.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_kms.c
@@ -1,7 +1,7 @@
 /*
  * rcar_du_kms.c  --  R-Car Display Unit Mode Setting
  *
- * Copyright (C) 2013-2015 Renesas Electronics Corporation
+ * Copyright (C) 2013-2014 Renesas Electronics Corporation
  *
  * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
  *
@@ -28,7 +28,6 @@
 #include "rcar_du_kms.h"
 #include "rcar_du_lvdsenc.h"
 #include "rcar_du_regs.h"
-#include "rcar_du_vsp.h"

 /* -----------------------------------------------------------------------------
  * Format helpers
@@ -137,7 +136,7 @@ int rcar_du_dumb_create(struct drm_file *file, struct drm_device *dev,

 static struct drm_framebuffer *
 rcar_du_fb_create(struct drm_device *dev, struct drm_file *file_priv,
-		  const struct drm_mode_fb_cmd2 *mode_cmd)
+		  struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct rcar_du_device *rcdu = dev->dev_private;
	const struct rcar_du_format_info *format;
@@ -193,20 +192,252 @@ static void rcar_du_output_poll_changed(struct drm_device *dev)
  * Atomic Check and Update
  */

+/*
+ * Atomic hardware plane allocator
+ *
+ * The hardware plane allocator is solely based on the atomic plane states
+ * without keeping any external state to avoid races between .atomic_check()
+ * and .atomic_commit().
+ *
+ * The core idea is to avoid using a free planes bitmask that would need to be
+ * shared between check and commit handlers with a collective knowledge based on
+ * the allocated hardware plane(s) for each KMS plane. The allocator then loops
+ * over all plane states to compute the free planes bitmask, allocates hardware
+ * planes based on that bitmask, and stores the result back in the plane states.
+ *
+ * For this to work we need to access the current state of planes not touched by
+ * the atomic update. To ensure that it won't be modified, we need to lock all
+ * planes using drm_atomic_get_plane_state(). This effectively serializes atomic
+ * updates from .atomic_check() up to completion (when swapping the states if
+ * the check step has succeeded) or rollback (when freeing the states if the
+ * check step has failed).
+ *
+ * Allocation is performed in the .atomic_check() handler and applied
+ * automatically when the core swaps the old and new states.
+ */
+
+static bool rcar_du_plane_needs_realloc(struct rcar_du_plane *plane,
+					struct rcar_du_plane_state *state)
+{
+	const struct rcar_du_format_info *cur_format;
+
+	cur_format = to_rcar_plane_state(plane->plane.state)->format;
+
+	/* Lowering the number of planes doesn't strictly require reallocation
+	 * as the extra hardware plane will be freed when committing, but doing
+	 * so could lead to more fragmentation.
+	 */
+	return !cur_format || cur_format->planes != state->format->planes;
+}
+
+static unsigned int rcar_du_plane_hwmask(struct rcar_du_plane_state *state)
+{
+	unsigned int mask;
+
+	if (state->hwindex == -1)
+		return 0;
+
+	mask = 1 << state->hwindex;
+	if (state->format->planes == 2)
+		mask |= 1 << ((state->hwindex + 1) % 8);
+
+	return mask;
+}
+
+static int rcar_du_plane_hwalloc(unsigned int num_planes, unsigned int free)
+{
+	unsigned int i;
+
+	for (i = 0; i < RCAR_DU_NUM_HW_PLANES; ++i) {
+		if (!(free & (1 << i)))
+			continue;
+
+		if (num_planes == 1 || free & (1 << ((i + 1) % 8)))
+			break;
+	}
+
+	return i == RCAR_DU_NUM_HW_PLANES ? -EBUSY : i;
+}
+
 static int rcar_du_atomic_check(struct drm_device *dev,
				struct drm_atomic_state *state)
 {
	struct rcar_du_device *rcdu = dev->dev_private;
+	unsigned int group_freed_planes[RCAR_DU_MAX_GROUPS] = { 0, };
+	unsigned int group_free_planes[RCAR_DU_MAX_GROUPS] = { 0, };
+	bool needs_realloc = false;
+	unsigned int groups = 0;
+	unsigned int i;
	int ret;

	ret = drm_atomic_helper_check(dev, state);
	if (ret < 0)
		return ret;

-	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE))
+	/* Check if hardware planes need to be reallocated. */
+	for (i = 0; i < dev->mode_config.num_total_plane; ++i) {
+		struct rcar_du_plane_state *plane_state;
+		struct rcar_du_plane *plane;
+		unsigned int index;
+
+		if (!state->planes[i])
+			continue;
+
+		plane = to_rcar_plane(state->planes[i]);
+		plane_state = to_rcar_plane_state(state->plane_states[i]);
+
+		dev_dbg(rcdu->dev, "%s: checking plane (%u,%u)\n", __func__,
+			plane->group->index, plane - plane->group->planes);
+
+		/* If the plane is being disabled we don't need to go through
+		 * the full reallocation procedure. Just mark the hardware
+		 * plane(s) as freed.
+		 */
+		if (!plane_state->format) {
+			dev_dbg(rcdu->dev, "%s: plane is being disabled\n",
+				__func__);
+			index = plane - plane->group->planes;
+			group_freed_planes[plane->group->index] |= 1 << index;
+			plane_state->hwindex = -1;
+			continue;
+		}
+
+		/* If the plane needs to be reallocated mark it as such, and
+		 * mark the hardware plane(s) as free.
+		 */
+		if (rcar_du_plane_needs_realloc(plane, plane_state)) {
+			dev_dbg(rcdu->dev, "%s: plane needs reallocation\n",
+				__func__);
+			groups |= 1 << plane->group->index;
+			needs_realloc = true;
+
+			index = plane - plane->group->planes;
+			group_freed_planes[plane->group->index] |= 1 << index;
+			plane_state->hwindex = -1;
+		}
+	}
+
+	if (!needs_realloc)
		return 0;

-	return rcar_du_atomic_check_planes(dev, state);
+	/* Grab all plane states for the groups that need reallocation to ensure
+	 * locking and avoid racy updates. This serializes the update operation,
+	 * but there's not much we can do about it as that's the hardware
+	 * design.
+	 *
+	 * Compute the used planes mask for each group at the same time to avoid
+	 * looping over the planes separately later.
+	 */
+	while (groups) {
+		unsigned int index = ffs(groups) - 1;
+		struct rcar_du_group *group = &rcdu->groups[index];
+		unsigned int used_planes = 0;
+
+		dev_dbg(rcdu->dev, "%s: finding free planes for group %u\n",
+			__func__, index);
+
+		for (i = 0; i < group->num_planes; ++i) {
+			struct rcar_du_plane *plane = &group->planes[i];
+			struct rcar_du_plane_state *plane_state;
+			struct drm_plane_state *s;
+
+			s = drm_atomic_get_plane_state(state, &plane->plane);
+			if (IS_ERR(s))
+				return PTR_ERR(s);
+
+			/* If the plane has been freed in the above loop its
+			 * hardware planes must not be added to the used planes
+			 * bitmask. However, the current state doesn't reflect
+			 * the free state yet, as we've modified the new state
+			 * above. Use the local freed planes list to check for
+			 * that condition instead.
+			 */
+			if (group_freed_planes[index] & (1 << i)) {
+				dev_dbg(rcdu->dev,
+					"%s: plane (%u,%u) has been freed, skipping\n",
+					__func__, plane->group->index,
+					plane - plane->group->planes);
+				continue;
+			}
+
+			plane_state = to_rcar_plane_state(plane->plane.state);
+			used_planes |= rcar_du_plane_hwmask(plane_state);
+
+			dev_dbg(rcdu->dev,
+				"%s: plane (%u,%u) uses %u hwplanes (index %d)\n",
+				__func__, plane->group->index,
+				plane - plane->group->planes,
+				plane_state->format ?
+				plane_state->format->planes : 0,
+				plane_state->hwindex);
+		}
+
+		group_free_planes[index] = 0xff & ~used_planes;
+		groups &= ~(1 << index);
+
+		dev_dbg(rcdu->dev, "%s: group %u free planes mask 0x%02x\n",
+			__func__, index, group_free_planes[index]);
+	}
+
+	/* Reallocate hardware planes for each plane that needs it. */
+	for (i = 0; i < dev->mode_config.num_total_plane; ++i) {
+		struct rcar_du_plane_state *plane_state;
+		struct rcar_du_plane *plane;
+		unsigned int crtc_planes;
+		unsigned int free;
+		int idx;
+
+		if (!state->planes[i])
+			continue;
+
+		plane = to_rcar_plane(state->planes[i]);
+		plane_state = to_rcar_plane_state(state->plane_states[i]);
+
+		dev_dbg(rcdu->dev, "%s: allocating plane (%u,%u)\n", __func__,
+			plane->group->index, plane - plane->group->planes);
+
+		/* Skip planes that are being disabled or don't need to be
+		 * reallocated.
+		 */
+		if (!plane_state->format ||
+		    !rcar_du_plane_needs_realloc(plane, plane_state))
+			continue;
+
+		/* Try to allocate the plane from the free planes currently
+		 * associated with the target CRTC to avoid restarting the CRTC
+		 * group and thus minimize flicker. If it fails fall back to
+		 * allocating from all free planes.
+		 */
+		crtc_planes = to_rcar_crtc(plane_state->state.crtc)->index % 2
+			    ? plane->group->dptsr_planes
+			    : ~plane->group->dptsr_planes;
+		free = group_free_planes[plane->group->index];
+
+		idx = rcar_du_plane_hwalloc(plane_state->format->planes,
+					    free & crtc_planes);
+		if (idx < 0)
+			idx = rcar_du_plane_hwalloc(plane_state->format->planes,
+						    free);
+		if (idx < 0) {
+			dev_dbg(rcdu->dev, "%s: no available hardware plane\n",
+				__func__);
+			return idx;
+		}
+
+		dev_dbg(rcdu->dev, "%s: allocated %u hwplanes (index %u)\n",
+			__func__, plane_state->format->planes, idx);
+
+		plane_state->hwindex = idx;
+
+		group_free_planes[plane->group->index] &=
+			~rcar_du_plane_hwmask(plane_state);
+
+		dev_dbg(rcdu->dev, "%s: group %u free planes mask 0x%02x\n",
+			__func__, plane->group->index,
+			group_free_planes[plane->group->index]);
+	}
+
+	return 0;
 }

 struct rcar_du_commit {
@@ -225,7 +456,7 @@ static void rcar_du_atomic_complete(struct rcar_du_commit *commit)
	/* Apply the atomic update. */
	drm_atomic_helper_commit_modeset_disables(dev, old_state);
	drm_atomic_helper_commit_modeset_enables(dev, old_state);
-	drm_atomic_helper_commit_planes(dev, old_state, true);
+	drm_atomic_helper_commit_planes(dev, old_state, false);

	drm_atomic_helper_wait_for_vblanks(dev, old_state);

@@ -417,7 +648,7 @@ static int rcar_du_encoders_init_one(struct rcar_du_device *rcdu,
	if (ret && ret != -EPROBE_DEFER)
		dev_warn(rcdu->dev,
			 "failed to initialize encoder %s (%d), skipping\n",
-			 of_node_full_name(encoder), ret);
+			 encoder->full_name, ret);

	return ret;
 }
@@ -544,36 +775,14 @@ int rcar_du_modeset_init(struct rcar_du_device *rcdu)
		rgrp->num_crtcs = min(rcdu->num_crtcs - 2 * i, 2U);

		/* If we have more than one CRTCs in this group pre-associate
-		 * the low-order planes with CRTC 0 and the high-order planes
-		 * with CRTC 1 to minimize flicker occurring when the
-		 * association is changed.
+		 * planes 0-3 with CRTC 0 and planes 4-7 with CRTC 1 to minimize
+		 * flicker occurring when the association is changed.
		 */
-		rgrp->dptsr_planes = rgrp->num_crtcs > 1
-				   ? (rcdu->info->gen >= 3 ? 0x04 : 0xf0)
-				   : 0;
-
-		if (!rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE)) {
-			ret = rcar_du_planes_init(rgrp);
-			if (ret < 0)
-				return ret;
-		}
-	}
-
-	/* Initialize the compositors. */
-	if (rcar_du_has(rcdu, RCAR_DU_FEATURE_VSP1_SOURCE)) {
-		for (i = 0; i < rcdu->num_crtcs; ++i) {
-			struct rcar_du_vsp *vsp = &rcdu->vsps[i];
-
-			vsp->index = i;
-			vsp->dev = rcdu;
-			vsp->group = &rcdu->groups[i / 2];
+		rgrp->dptsr_planes = rgrp->num_crtcs > 1 ? 0xf0 : 0;

-			rcdu->crtcs[i].vsp = vsp;
-
-			ret = rcar_du_vsp_init(vsp);
-			if (ret < 0)
-				return ret;
-		}
+		ret = rcar_du_planes_init(rgrp);
+		if (ret < 0)
+			return ret;
	}

	/* Create the CRTCs. */
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_lvdscon.c b/drivers/gpu/drm/rcar-du/rcar_du_lvdscon.c
index d8446d2..0c43032 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_lvdscon.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_lvdscon.c
@@ -15,7 +15,6 @@
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
-#include <drm/drm_panel.h>

 #include <video/display_timing.h>
 #include <video/of_display_timing.h>
@@ -34,8 +33,6 @@ struct rcar_du_lvds_connector {
		unsigned int height_mm;		/* Panel height in mm */
		struct videomode mode;
	} panel;
-
-	struct drm_panel *drmpanel;
 };

 #define to_rcar_lvds_connector(c) \
@@ -47,10 +44,6 @@ static int rcar_du_lvds_connector_get_modes(struct drm_connector *connector)
		to_rcar_lvds_connector(connector);
	struct drm_display_mode *mode;

-	if (lvdscon->drmpanel){
-		return drm_panel_get_modes(lvdscon->drmpanel);
-	}
-
	mode = drm_mode_create(connector->dev);
	if (mode == NULL)
		return 0;
@@ -69,21 +62,16 @@ static const struct drm_connector_helper_funcs connector_helper_funcs = {
	.best_encoder = rcar_du_connector_best_encoder,
 };

-static enum drm_connector_status
-rcar_du_lvds_connector_detect(struct drm_connector *connector, bool force)
+static void rcar_du_lvds_connector_destroy(struct drm_connector *connector)
 {
-	return connector_status_connected;
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
 }

-static void rcar_du_lvds_connector_destroy(struct drm_connector *connector)
+static enum drm_connector_status
+rcar_du_lvds_connector_detect(struct drm_connector *connector, bool force)
 {
-	struct rcar_du_lvds_connector *lvdscon =
-		to_rcar_lvds_connector(connector);
-
-	if (lvdscon->drmpanel)
-		drm_panel_detach(lvdscon->drmpanel);
-
-	drm_connector_cleanup(connector);
+	return connector_status_connected;
 }

 static const struct drm_connector_funcs connector_funcs = {
@@ -110,23 +98,18 @@ int rcar_du_lvds_connector_init(struct rcar_du_device *rcdu,
	if (lvdscon == NULL)
		return -ENOMEM;

-	lvdscon->drmpanel = of_drm_find_panel(np);
-	connector = &lvdscon->connector.connector;
-
-	if (!lvdscon->drmpanel)
-	{
-		ret = of_get_display_timing(np, "panel-timing", &timing);
-		if (ret < 0)
-			return ret;
+	ret = of_get_display_timing(np, "panel-timing", &timing);
+	if (ret < 0)
+		return ret;

-		videomode_from_timing(&timing, &lvdscon->panel.mode);
+	videomode_from_timing(&timing, &lvdscon->panel.mode);

-		of_property_read_u32(np, "width-mm", &lvdscon->panel.width_mm);
-		of_property_read_u32(np, "height-mm", &lvdscon->panel.height_mm);
+	of_property_read_u32(np, "width-mm", &lvdscon->panel.width_mm);
+	of_property_read_u32(np, "height-mm", &lvdscon->panel.height_mm);

-		connector->display_info.width_mm = lvdscon->panel.width_mm;
-		connector->display_info.height_mm = lvdscon->panel.height_mm;
-	}
+	connector = &lvdscon->connector.connector;
+	connector->display_info.width_mm = lvdscon->panel.width_mm;
+	connector->display_info.height_mm = lvdscon->panel.height_mm;

	ret = drm_connector_init(rcdu->ddev, connector, &connector_funcs,
				 DRM_MODE_CONNECTOR_LVDS);
@@ -134,14 +117,14 @@ int rcar_du_lvds_connector_init(struct rcar_du_device *rcdu,
		return ret;

	drm_connector_helper_add(connector, &connector_helper_funcs);
+	ret = drm_connector_register(connector);
+	if (ret < 0)
+		return ret;

	connector->dpms = DRM_MODE_DPMS_OFF;
	drm_object_property_set_value(&connector->base,
		rcdu->ddev->mode_config.dpms_property, DRM_MODE_DPMS_OFF);

-	if (lvdscon->drmpanel)
-		drm_panel_attach(lvdscon->drmpanel, connector);
-
	ret = drm_mode_connector_attach_encoder(connector, encoder);
	if (ret < 0)
		return ret;
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.c b/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.c
index ef3a503..85043c5 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.c
@@ -38,106 +38,35 @@ static void rcar_lvds_write(struct rcar_du_lvdsenc *lvds, u32 reg, u32 data)
	iowrite32(data, lvds->mmio + reg);
 }

-static void rcar_du_lvdsenc_start_gen2(struct rcar_du_lvdsenc *lvds,
-				       struct rcar_du_crtc *rcrtc)
+static int rcar_du_lvdsenc_start(struct rcar_du_lvdsenc *lvds,
+				 struct rcar_du_crtc *rcrtc)
 {
	const struct drm_display_mode *mode = &rcrtc->crtc.mode;
	unsigned int freq = mode->clock;
	u32 lvdcr0;
+	u32 lvdhcr;
	u32 pllcr;
+	int ret;
+
+	if (lvds->enabled)
+		return 0;
+
+	ret = clk_prepare_enable(lvds->clock);
+	if (ret < 0)
+		return ret;

	/* PLL clock configuration */
-	if (freq < 39000)
+	if (freq <= 38000)
		pllcr = LVDPLLCR_CEEN | LVDPLLCR_COSEL | LVDPLLCR_PLLDLYCNT_38M;
-	else if (freq < 61000)
+	else if (freq <= 60000)
		pllcr = LVDPLLCR_CEEN | LVDPLLCR_COSEL | LVDPLLCR_PLLDLYCNT_60M;
-	else if (freq < 121000)
+	else if (freq <= 121000)
		pllcr = LVDPLLCR_CEEN | LVDPLLCR_COSEL | LVDPLLCR_PLLDLYCNT_121M;
	else
		pllcr = LVDPLLCR_PLLDLYCNT_150M;

	rcar_lvds_write(lvds, LVDPLLCR, pllcr);

-	/* Select the input, hardcode mode 0, enable LVDS operation and turn
-	 * bias circuitry on.
-	 */
-	lvdcr0 = LVDCR0_BEN | LVDCR0_LVEN;
-	if (rcrtc->index == 2)
-		lvdcr0 |= LVDCR0_DUSEL;
-	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
-
-	/* Turn all the channels on. */
-	rcar_lvds_write(lvds, LVDCR1,
-			LVDCR1_CHSTBY_GEN2(3) | LVDCR1_CHSTBY_GEN2(2) |
-			LVDCR1_CHSTBY_GEN2(1) | LVDCR1_CHSTBY_GEN2(0) |
-			LVDCR1_CLKSTBY_GEN2);
-
-	/* Turn the PLL on, wait for the startup delay, and turn the output
-	 * on.
-	 */
-	lvdcr0 |= LVDCR0_PLLON;
-	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
-
-	usleep_range(100, 150);
-
-	lvdcr0 |= LVDCR0_LVRES;
-	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
-}
-
-static void rcar_du_lvdsenc_start_gen3(struct rcar_du_lvdsenc *lvds,
-				       struct rcar_du_crtc *rcrtc)
-{
-	const struct drm_display_mode *mode = &rcrtc->crtc.mode;
-	unsigned int freq = mode->clock;
-	u32 lvdcr0;
-	u32 pllcr;
-
-	/* PLL clock configuration */
-	if (freq < 42000)
-		pllcr = LVDPLLCR_PLLDIVCNT_42M;
-	else if (freq < 85000)
-		pllcr = LVDPLLCR_PLLDIVCNT_85M;
-	else if (freq < 128000)
-		pllcr = LVDPLLCR_PLLDIVCNT_128M;
-	else
-		pllcr = LVDPLLCR_PLLDIVCNT_148M;
-
-	rcar_lvds_write(lvds, LVDPLLCR, pllcr);
-
-	/* Turn the PLL on, set it to LVDS normal mode, wait for the startup
-	 * delay and turn the output on.
-	 */
-	lvdcr0 = LVDCR0_PLLON;
-	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
-
-	lvdcr0 |= LVDCR0_PWD;
-	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
-
-	usleep_range(100, 150);
-
-	lvdcr0 |= LVDCR0_LVRES;
-	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
-
-	/* Turn all the channels on. */
-	rcar_lvds_write(lvds, LVDCR1,
-			LVDCR1_CHSTBY_GEN3(3) | LVDCR1_CHSTBY_GEN3(2) |
-			LVDCR1_CHSTBY_GEN3(1) | LVDCR1_CHSTBY_GEN3(0) |
-			LVDCR1_CLKSTBY_GEN3);
-}
-
-static int rcar_du_lvdsenc_start(struct rcar_du_lvdsenc *lvds,
-				 struct rcar_du_crtc *rcrtc)
-{
-	u32 lvdhcr;
-	int ret;
-
-	if (lvds->enabled)
-		return 0;
-
-	ret = clk_prepare_enable(lvds->clock);
-	if (ret < 0)
-		return ret;
-
	/* Hardcode the channels and control signals routing for now.
	 *
	 * HSYNC -> CTRL0
@@ -158,14 +87,30 @@ static int rcar_du_lvdsenc_start(struct rcar_du_lvdsenc *lvds,

	rcar_lvds_write(lvds, LVDCHCR, lvdhcr);

-	/* Perform generation-specific initialization. */
-	if (lvds->dev->info->gen < 3)
-		rcar_du_lvdsenc_start_gen2(lvds, rcrtc);
-	else
-		rcar_du_lvdsenc_start_gen3(lvds, rcrtc);
+	/* Select the input, hardcode mode 0, enable LVDS operation and turn
+	 * bias circuitry on.
+	 */
+	lvdcr0 = LVDCR0_BEN | LVDCR0_LVEN;
+	if (rcrtc->index == 2)
+		lvdcr0 |= LVDCR0_DUSEL;
+	rcar_lvds_write(lvds, LVDCR0, lvdcr0);

-	lvds->enabled = true;
+	/* Turn all the channels on. */
+	rcar_lvds_write(lvds, LVDCR1, LVDCR1_CHSTBY(3) | LVDCR1_CHSTBY(2) |
+			LVDCR1_CHSTBY(1) | LVDCR1_CHSTBY(0) | LVDCR1_CLKSTBY);
+
+	/* Turn the PLL on, wait for the startup delay, and turn the output
+	 * on.
+	 */
+	lvdcr0 |= LVDCR0_PLLEN;
+	rcar_lvds_write(lvds, LVDCR0, lvdcr0);

+	usleep_range(100, 150);
+
+	lvdcr0 |= LVDCR0_LVRES;
+	rcar_lvds_write(lvds, LVDCR0, lvdcr0);
+
+	lvds->enabled = true;
	return 0;
 }

@@ -195,21 +140,6 @@ int rcar_du_lvdsenc_enable(struct rcar_du_lvdsenc *lvds, struct drm_crtc *crtc,
		return -EINVAL;
 }

-void rcar_du_lvdsenc_atomic_check(struct rcar_du_lvdsenc *lvds,
-				  struct drm_display_mode *mode)
-{
-	struct rcar_du_device *rcdu = lvds->dev;
-
-	/* The internal LVDS encoder has a restricted clock frequency operating
-	 * range (30MHz to 150MHz on Gen2, 25.175MHz to 148.5MHz on Gen3). Clamp
-	 * the clock accordingly.
-	 */
-	if (rcdu->info->gen < 3)
-		mode->clock = clamp(mode->clock, 30000, 150000);
-	else
-		mode->clock = clamp(mode->clock, 25175, 148500);
-}
-
 static int rcar_du_lvdsenc_get_resources(struct rcar_du_lvdsenc *lvds,
					 struct platform_device *pdev)
 {
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.h b/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.h
index dfdba74..9a6001c 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_lvdsenc.h
@@ -30,8 +30,6 @@ enum rcar_lvds_input {
 int rcar_du_lvdsenc_init(struct rcar_du_device *rcdu);
 int rcar_du_lvdsenc_enable(struct rcar_du_lvdsenc *lvds,
			   struct drm_crtc *crtc, bool enable);
-void rcar_du_lvdsenc_atomic_check(struct rcar_du_lvdsenc *lvds,
-				  struct drm_display_mode *mode);
 #else
 static inline int rcar_du_lvdsenc_init(struct rcar_du_device *rcdu)
 {
@@ -42,10 +40,6 @@ static inline int rcar_du_lvdsenc_enable(struct rcar_du_lvdsenc *lvds,
 {
	return 0;
 }
-static inline void rcar_du_lvdsenc_atomic_check(struct rcar_du_lvdsenc *lvds,
-						struct drm_display_mode *mode)
-{
-}
 #endif

 #endif /* __RCAR_DU_LVDSENC_H__ */
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_plane.c b/drivers/gpu/drm/rcar-du/rcar_du_plane.c
index 8460ae1..ffa5837 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_plane.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_plane.c
@@ -1,7 +1,7 @@
 /*
  * rcar_du_plane.c  --  R-Car Display Unit Planes
  *
- * Copyright (C) 2013-2015 Renesas Electronics Corporation
+ * Copyright (C) 2013-2014 Renesas Electronics Corporation
  *
  * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
  *
@@ -12,7 +12,6 @@
  */

 #include <drm/drmP.h>
-#include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_crtc.h>
 #include <drm/drm_crtc_helper.h>
@@ -21,300 +20,21 @@
 #include <drm/drm_plane_helper.h>

 #include "rcar_du_drv.h"
-#include "rcar_du_group.h"
 #include "rcar_du_kms.h"
 #include "rcar_du_plane.h"
 #include "rcar_du_regs.h"

-/* -----------------------------------------------------------------------------
- * Atomic hardware plane allocator
- *
- * The hardware plane allocator is solely based on the atomic plane states
- * without keeping any external state to avoid races between .atomic_check()
- * and .atomic_commit().
- *
- * The core idea is to avoid using a free planes bitmask that would need to be
- * shared between check and commit handlers with a collective knowledge based on
- * the allocated hardware plane(s) for each KMS plane. The allocator then loops
- * over all plane states to compute the free planes bitmask, allocates hardware
- * planes based on that bitmask, and stores the result back in the plane states.
- *
- * For this to work we need to access the current state of planes not touched by
- * the atomic update. To ensure that it won't be modified, we need to lock all
- * planes using drm_atomic_get_plane_state(). This effectively serializes atomic
- * updates from .atomic_check() up to completion (when swapping the states if
- * the check step has succeeded) or rollback (when freeing the states if the
- * check step has failed).
- *
- * Allocation is performed in the .atomic_check() handler and applied
- * automatically when the core swaps the old and new states.
- */
-
-static bool rcar_du_plane_needs_realloc(struct rcar_du_plane *plane,
-					struct rcar_du_plane_state *new_state)
-{
-	struct rcar_du_plane_state *cur_state;
-
-	cur_state = to_rcar_plane_state(plane->plane.state);
-
-	/* Lowering the number of planes doesn't strictly require reallocation
-	 * as the extra hardware plane will be freed when committing, but doing
-	 * so could lead to more fragmentation.
-	 */
-	if (!cur_state->format ||
-	    cur_state->format->planes != new_state->format->planes)
-		return true;
-
-	/* Reallocate hardware planes if the source has changed. */
-	if (cur_state->source != new_state->source)
-		return true;
-
-	return false;
-}
-
-static unsigned int rcar_du_plane_hwmask(struct rcar_du_plane_state *state)
-{
-	unsigned int mask;
-
-	if (state->hwindex == -1)
-		return 0;
-
-	mask = 1 << state->hwindex;
-	if (state->format->planes == 2)
-		mask |= 1 << ((state->hwindex + 1) % 8);
-
-	return mask;
-}
-
-/*
- * The R8A7790 DU can source frames directly from the VSP1 devices VSPD0 and
- * VSPD1. VSPD0 feeds DU0/1 plane 0, and VSPD1 feeds either DU2 plane 0 or
- * DU0/1 plane 1.
- *
- * Allocate the correct fixed plane when sourcing frames from VSPD0 or VSPD1,
- * and allocate planes in reverse index order otherwise to ensure maximum
- * availability of planes 0 and 1.
- *
- * The caller is responsible for ensuring that the requested source is
- * compatible with the DU revision.
- */
-static int rcar_du_plane_hwalloc(struct rcar_du_plane *plane,
-				 struct rcar_du_plane_state *state,
-				 unsigned int free)
-{
-	unsigned int num_planes = state->format->planes;
-	int fixed = -1;
-	int i;
-
-	if (state->source == RCAR_DU_PLANE_VSPD0) {
-		/* VSPD0 feeds plane 0 on DU0/1. */
-		if (plane->group->index != 0)
-			return -EINVAL;
-
-		fixed = 0;
-	} else if (state->source == RCAR_DU_PLANE_VSPD1) {
-		/* VSPD1 feeds plane 1 on DU0/1 or plane 0 on DU2. */
-		fixed = plane->group->index == 0 ? 1 : 0;
-	}
-
-	if (fixed >= 0)
-		return free & (1 << fixed) ? fixed : -EBUSY;
-
-	for (i = RCAR_DU_NUM_HW_PLANES - 1; i >= 0; --i) {
-		if (!(free & (1 << i)))
-			continue;
-
-		if (num_planes == 1 || free & (1 << ((i + 1) % 8)))
-			break;
-	}
-
-	return i < 0 ? -EBUSY : i;
-}
-
-int rcar_du_atomic_check_planes(struct drm_device *dev,
-				struct drm_atomic_state *state)
-{
-	struct rcar_du_device *rcdu = dev->dev_private;
-	unsigned int group_freed_planes[RCAR_DU_MAX_GROUPS] = { 0, };
-	unsigned int group_free_planes[RCAR_DU_MAX_GROUPS] = { 0, };
-	bool needs_realloc = false;
-	unsigned int groups = 0;
-	unsigned int i;
-
-	/* Check if hardware planes need to be reallocated. */
-	for (i = 0; i < dev->mode_config.num_total_plane; ++i) {
-		struct rcar_du_plane_state *plane_state;
-		struct rcar_du_plane *plane;
-		unsigned int index;
-
-		if (!state->planes[i])
-			continue;
-
-		plane = to_rcar_plane(state->planes[i]);
-		plane_state = to_rcar_plane_state(state->plane_states[i]);
-
-		dev_dbg(rcdu->dev, "%s: checking plane (%u,%tu)\n", __func__,
-			plane->group->index, plane - plane->group->planes);
-
-		/* If the plane is being disabled we don't need to go through
-		 * the full reallocation procedure. Just mark the hardware
-		 * plane(s) as freed.
-		 */
-		if (!plane_state->format) {
-			dev_dbg(rcdu->dev, "%s: plane is being disabled\n",
-				__func__);
-			index = plane - plane->group->planes;
-			group_freed_planes[plane->group->index] |= 1 << index;
-			plane_state->hwindex = -1;
-			continue;
-		}
-
-		/* If the plane needs to be reallocated mark it as such, and
-		 * mark the hardware plane(s) as free.
-		 */
-		if (rcar_du_plane_needs_realloc(plane, plane_state)) {
-			dev_dbg(rcdu->dev, "%s: plane needs reallocation\n",
-				__func__);
-			groups |= 1 << plane->group->index;
-			needs_realloc = true;
-
-			index = plane - plane->group->planes;
-			group_freed_planes[plane->group->index] |= 1 << index;
-			plane_state->hwindex = -1;
-		}
-	}
-
-	if (!needs_realloc)
-		return 0;
-
-	/* Grab all plane states for the groups that need reallocation to ensure
-	 * locking and avoid racy updates. This serializes the update operation,
-	 * but there's not much we can do about it as that's the hardware
-	 * design.
-	 *
-	 * Compute the used planes mask for each group at the same time to avoid
-	 * looping over the planes separately later.
-	 */
-	while (groups) {
-		unsigned int index = ffs(groups) - 1;
-		struct rcar_du_group *group = &rcdu->groups[index];
-		unsigned int used_planes = 0;
-
-		dev_dbg(rcdu->dev, "%s: finding free planes for group %u\n",
-			__func__, index);
-
-		for (i = 0; i < group->num_planes; ++i) {
-			struct rcar_du_plane *plane = &group->planes[i];
-			struct rcar_du_plane_state *plane_state;
-			struct drm_plane_state *s;
-
-			s = drm_atomic_get_plane_state(state, &plane->plane);
-			if (IS_ERR(s))
-				return PTR_ERR(s);
-
-			/* If the plane has been freed in the above loop its
-			 * hardware planes must not be added to the used planes
-			 * bitmask. However, the current state doesn't reflect
-			 * the free state yet, as we've modified the new state
-			 * above. Use the local freed planes list to check for
-			 * that condition instead.
-			 */
-			if (group_freed_planes[index] & (1 << i)) {
-				dev_dbg(rcdu->dev,
-					"%s: plane (%u,%tu) has been freed, skipping\n",
-					__func__, plane->group->index,
-					plane - plane->group->planes);
-				continue;
-			}
-
-			plane_state = to_rcar_plane_state(plane->plane.state);
-			used_planes |= rcar_du_plane_hwmask(plane_state);
-
-			dev_dbg(rcdu->dev,
-				"%s: plane (%u,%tu) uses %u hwplanes (index %d)\n",
-				__func__, plane->group->index,
-				plane - plane->group->planes,
-				plane_state->format ?
-				plane_state->format->planes : 0,
-				plane_state->hwindex);
-		}
-
-		group_free_planes[index] = 0xff & ~used_planes;
-		groups &= ~(1 << index);
-
-		dev_dbg(rcdu->dev, "%s: group %u free planes mask 0x%02x\n",
-			__func__, index, group_free_planes[index]);
-	}
-
-	/* Reallocate hardware planes for each plane that needs it. */
-	for (i = 0; i < dev->mode_config.num_total_plane; ++i) {
-		struct rcar_du_plane_state *plane_state;
-		struct rcar_du_plane *plane;
-		unsigned int crtc_planes;
-		unsigned int free;
-		int idx;
-
-		if (!state->planes[i])
-			continue;
-
-		plane = to_rcar_plane(state->planes[i]);
-		plane_state = to_rcar_plane_state(state->plane_states[i]);
-
-		dev_dbg(rcdu->dev, "%s: allocating plane (%u,%tu)\n", __func__,
-			plane->group->index, plane - plane->group->planes);
-
-		/* Skip planes that are being disabled or don't need to be
-		 * reallocated.
-		 */
-		if (!plane_state->format ||
-		    !rcar_du_plane_needs_realloc(plane, plane_state))
-			continue;
-
-		/* Try to allocate the plane from the free planes currently
-		 * associated with the target CRTC to avoid restarting the CRTC
-		 * group and thus minimize flicker. If it fails fall back to
-		 * allocating from all free planes.
-		 */
-		crtc_planes = to_rcar_crtc(plane_state->state.crtc)->index % 2
-			    ? plane->group->dptsr_planes
-			    : ~plane->group->dptsr_planes;
-		free = group_free_planes[plane->group->index];
-
-		idx = rcar_du_plane_hwalloc(plane, plane_state,
-					    free & crtc_planes);
-		if (idx < 0)
-			idx = rcar_du_plane_hwalloc(plane, plane_state,
-						    free);
-		if (idx < 0) {
-			dev_dbg(rcdu->dev, "%s: no available hardware plane\n",
-				__func__);
-			return idx;
-		}
-
-		dev_dbg(rcdu->dev, "%s: allocated %u hwplanes (index %u)\n",
-			__func__, plane_state->format->planes, idx);
-
-		plane_state->hwindex = idx;
-
-		group_free_planes[plane->group->index] &=
-			~rcar_du_plane_hwmask(plane_state);
-
-		dev_dbg(rcdu->dev, "%s: group %u free planes mask 0x%02x\n",
-			__func__, plane->group->index,
-			group_free_planes[plane->group->index]);
-	}
-
-	return 0;
-}
-
-/* -----------------------------------------------------------------------------
- * Plane Setup
- */
-
 #define RCAR_DU_COLORKEY_NONE		(0 << 24)
 #define RCAR_DU_COLORKEY_SOURCE		(1 << 24)
 #define RCAR_DU_COLORKEY_MASK		(1 << 24)

+static u32 rcar_du_plane_read(struct rcar_du_group *rgrp,
+			      unsigned int index, u32 reg)
+{
+	return rcar_du_read(rgrp->dev,
+			    rgrp->mmio_offset + index * PLANE_OFF + reg);
+}
+
 static void rcar_du_plane_write(struct rcar_du_group *rgrp,
				unsigned int index, u32 reg, u32 data)
 {
@@ -322,45 +42,34 @@ static void rcar_du_plane_write(struct rcar_du_group *rgrp,
		      data);
 }

-static void rcar_du_plane_setup_scanout(struct rcar_du_group *rgrp,
-					const struct rcar_du_plane_state *state)
+static void rcar_du_plane_setup_fb(struct rcar_du_plane *plane)
 {
+	struct rcar_du_plane_state *state =
+		to_rcar_plane_state(plane->plane.state);
+	struct drm_framebuffer *fb = plane->plane.state->fb;
+	struct rcar_du_group *rgrp = plane->group;
	unsigned int src_x = state->state.src_x >> 16;
	unsigned int src_y = state->state.src_y >> 16;
	unsigned int index = state->hwindex;
-	unsigned int pitch;
+	struct drm_gem_cma_object *gem;
	bool interlaced;
-	u32 dma[2];
+	u32 mwr;

	interlaced = state->state.crtc->state->adjusted_mode.flags
		   & DRM_MODE_FLAG_INTERLACE;

-	if (state->source == RCAR_DU_PLANE_MEMORY) {
-		struct drm_framebuffer *fb = state->state.fb;
-		struct drm_gem_cma_object *gem;
-		unsigned int i;
-
-		if (state->format->planes == 2)
-			pitch = fb->pitches[0];
-		else
-			pitch = fb->pitches[0] * 8 / state->format->bpp;
-
-		for (i = 0; i < state->format->planes; ++i) {
-			gem = drm_fb_cma_get_gem_obj(fb, i);
-			dma[i] = gem->paddr + fb->offsets[i];
-		}
-	} else {
-		pitch = state->state.src_w >> 16;
-		dma[0] = 0;
-		dma[1] = 0;
-	}
-
	/* Memory pitch (expressed in pixels). Must be doubled for interlaced
	 * operation with 32bpp formats.
	 */
-	rcar_du_plane_write(rgrp, index, PnMWR,
-			    (interlaced && state->format->bpp == 32) ?
-			    pitch * 2 : pitch);
+	if (state->format->planes == 2)
+		mwr = fb->pitches[0];
+	else
+		mwr = fb->pitches[0] * 8 / state->format->bpp;
+
+	if (interlaced && state->format->bpp == 32)
+		mwr *= 2;
+
+	rcar_du_plane_write(rgrp, index, PnMWR, mwr);

	/* The Y position is expressed in raster line units and must be doubled
	 * for 32bpp formats, according to the R8A7790 datasheet. No mention of
@@ -378,25 +87,30 @@ static void rcar_du_plane_setup_scanout(struct rcar_du_group *rgrp,
	rcar_du_plane_write(rgrp, index, PnSPYR, src_y *
			    (!interlaced && state->format->bpp == 32 ? 2 : 1));

-	rcar_du_plane_write(rgrp, index, PnDSA0R, dma[0]);
+	gem = drm_fb_cma_get_gem_obj(fb, 0);
+	rcar_du_plane_write(rgrp, index, PnDSA0R, gem->paddr + fb->offsets[0]);

	if (state->format->planes == 2) {
		index = (index + 1) % 8;

-		rcar_du_plane_write(rgrp, index, PnMWR, pitch);
+		rcar_du_plane_write(rgrp, index, PnMWR, fb->pitches[0]);

		rcar_du_plane_write(rgrp, index, PnSPXR, src_x);
		rcar_du_plane_write(rgrp, index, PnSPYR, src_y *
				    (state->format->bpp == 16 ? 2 : 1) / 2);

-		rcar_du_plane_write(rgrp, index, PnDSA0R, dma[1]);
+		gem = drm_fb_cma_get_gem_obj(fb, 1);
+		rcar_du_plane_write(rgrp, index, PnDSA0R,
+				    gem->paddr + fb->offsets[1]);
	}
 }

-static void rcar_du_plane_setup_mode(struct rcar_du_group *rgrp,
-				     unsigned int index,
-				     const struct rcar_du_plane_state *state)
+static void rcar_du_plane_setup_mode(struct rcar_du_plane *plane,
+				     unsigned int index)
 {
+	struct rcar_du_plane_state *state =
+		to_rcar_plane_state(plane->plane.state);
+	struct rcar_du_group *rgrp = plane->group;
	u32 colorkey;
	u32 pnmr;

@@ -454,10 +168,12 @@ static void rcar_du_plane_setup_mode(struct rcar_du_group *rgrp,
	}
 }

-static void rcar_du_plane_setup_format_gen2(struct rcar_du_group *rgrp,
-					    unsigned int index,
-					    const struct rcar_du_plane_state *state)
+static void __rcar_du_plane_setup(struct rcar_du_plane *plane,
+				  unsigned int index)
 {
+	struct rcar_du_plane_state *state =
+		to_rcar_plane_state(plane->plane.state);
+	struct rcar_du_group *rgrp = plane->group;
	u32 ddcr2 = PnDDCR2_CODE;
	u32 ddcr4;

@@ -466,8 +182,11 @@ static void rcar_du_plane_setup_format_gen2(struct rcar_du_group *rgrp,
	 * The data format is selected by the DDDF field in PnMR and the EDF
	 * field in DDCR4.
	 */
+	ddcr4 = rcar_du_plane_read(rgrp, index, PnDDCR4);
+	ddcr4 &= ~PnDDCR4_EDF_MASK;
+	ddcr4 |= state->format->edf | PnDDCR4_CODE;

-	rcar_du_plane_setup_mode(rgrp, index, state);
+	rcar_du_plane_setup_mode(plane, index);

	if (state->format->planes == 2) {
		if (state->hwindex != index) {
@@ -485,72 +204,31 @@ static void rcar_du_plane_setup_format_gen2(struct rcar_du_group *rgrp,
	}

	rcar_du_plane_write(rgrp, index, PnDDCR2, ddcr2);
-
-	ddcr4 = state->format->edf | PnDDCR4_CODE;
-	if (state->source != RCAR_DU_PLANE_MEMORY)
-		ddcr4 |= PnDDCR4_VSPS;
-
	rcar_du_plane_write(rgrp, index, PnDDCR4, ddcr4);
-}
-
-static void rcar_du_plane_setup_format_gen3(struct rcar_du_group *rgrp,
-					    unsigned int index,
-					    const struct rcar_du_plane_state *state)
-{
-	rcar_du_plane_write(rgrp, index, PnMR,
-			    PnMR_SPIM_TP_OFF | state->format->pnmr);
-
-	rcar_du_plane_write(rgrp, index, PnDDCR4,
-			    state->format->edf | PnDDCR4_CODE);
-}
-
-static void rcar_du_plane_setup_format(struct rcar_du_group *rgrp,
-				       unsigned int index,
-				       const struct rcar_du_plane_state *state)
-{
-	struct rcar_du_device *rcdu = rgrp->dev;
-
-	if (rcdu->info->gen < 3)
-		rcar_du_plane_setup_format_gen2(rgrp, index, state);
-	else
-		rcar_du_plane_setup_format_gen3(rgrp, index, state);

	/* Destination position and size */
-	rcar_du_plane_write(rgrp, index, PnDSXR, state->state.crtc_w);
-	rcar_du_plane_write(rgrp, index, PnDSYR, state->state.crtc_h);
-	rcar_du_plane_write(rgrp, index, PnDPXR, state->state.crtc_x);
-	rcar_du_plane_write(rgrp, index, PnDPYR, state->state.crtc_y);
-
-	if (rcdu->info->gen < 3) {
-		/* Wrap-around and blinking, disabled */
-		rcar_du_plane_write(rgrp, index, PnWASPR, 0);
-		rcar_du_plane_write(rgrp, index, PnWAMWR, 4095);
-		rcar_du_plane_write(rgrp, index, PnBTR, 0);
-		rcar_du_plane_write(rgrp, index, PnMLR, 0);
-	}
+	rcar_du_plane_write(rgrp, index, PnDSXR, plane->plane.state->crtc_w);
+	rcar_du_plane_write(rgrp, index, PnDSYR, plane->plane.state->crtc_h);
+	rcar_du_plane_write(rgrp, index, PnDPXR, plane->plane.state->crtc_x);
+	rcar_du_plane_write(rgrp, index, PnDPYR, plane->plane.state->crtc_y);
+
+	/* Wrap-around and blinking, disabled */
+	rcar_du_plane_write(rgrp, index, PnWASPR, 0);
+	rcar_du_plane_write(rgrp, index, PnWAMWR, 4095);
+	rcar_du_plane_write(rgrp, index, PnBTR, 0);
+	rcar_du_plane_write(rgrp, index, PnMLR, 0);
 }

-void __rcar_du_plane_setup(struct rcar_du_group *rgrp,
-			   const struct rcar_du_plane_state *state)
+void rcar_du_plane_setup(struct rcar_du_plane *plane)
 {
-	struct rcar_du_device *rcdu = rgrp->dev;
+	struct rcar_du_plane_state *state =
+		to_rcar_plane_state(plane->plane.state);

-	rcar_du_plane_setup_format(rgrp, state->hwindex, state);
+	__rcar_du_plane_setup(plane, state->hwindex);
	if (state->format->planes == 2)
-		rcar_du_plane_setup_format(rgrp, (state->hwindex + 1) % 8,
-					   state);
+		__rcar_du_plane_setup(plane, (state->hwindex + 1) % 8);

-	if (rcdu->info->gen < 3)
-		rcar_du_plane_setup_scanout(rgrp, state);
-
-	if (state->source == RCAR_DU_PLANE_VSPD1) {
-		unsigned int vspd1_sink = rgrp->index ? 2 : 0;
-
-		if (rcdu->vspd1_sink != vspd1_sink) {
-			rcdu->vspd1_sink = vspd1_sink;
-			rcar_du_set_dpad0_vsp1_routing(rcdu);
-		}
-	}
+	rcar_du_plane_setup_fb(plane);
 }

 static int rcar_du_plane_atomic_check(struct drm_plane *plane,
@@ -585,27 +263,9 @@ static void rcar_du_plane_atomic_update(struct drm_plane *plane,
					struct drm_plane_state *old_state)
 {
	struct rcar_du_plane *rplane = to_rcar_plane(plane);
-	struct rcar_du_plane_state *old_rstate;
-	struct rcar_du_plane_state *new_rstate;
-
-	if (!plane->state->crtc)
-		return;
-
-	rcar_du_plane_setup(rplane);
-
-	/* Check whether the source has changed from memory to live source or
-	 * from live source to memory. The source has been configured by the
-	 * VSPS bit in the PnDDCR4 register. Although the datasheet states that
-	 * the bit is updated during vertical blanking, it seems that updates
-	 * only occur when the DU group is held in reset through the DSYSR.DRES
-	 * bit. We thus need to restart the group if the source changes.
-	 */
-	old_rstate = to_rcar_plane_state(old_state);
-	new_rstate = to_rcar_plane_state(plane->state);

-	if ((old_rstate->source == RCAR_DU_PLANE_MEMORY) !=
-	    (new_rstate->source == RCAR_DU_PLANE_MEMORY))
-		rplane->group->need_restart = true;
+	if (plane->state->crtc)
+		rcar_du_plane_setup(rplane);
 }

 static const struct drm_plane_helper_funcs rcar_du_plane_helper_funcs = {
@@ -653,7 +313,6 @@ static void rcar_du_plane_reset(struct drm_plane *plane)
		return;

	state->hwindex = -1;
-	state->source = RCAR_DU_PLANE_MEMORY;
	state->alpha = 255;
	state->colorkey = RCAR_DU_COLORKEY_NONE;
	state->zpos = plane->type == DRM_PLANE_TYPE_PRIMARY ? 0 : 1;
@@ -751,8 +410,7 @@ int rcar_du_planes_init(struct rcar_du_group *rgrp)

		ret = drm_universal_plane_init(rcdu->ddev, &plane->plane, crtcs,
					       &rcar_du_plane_funcs, formats,
-					       ARRAY_SIZE(formats), type,
-					       NULL);
+					       ARRAY_SIZE(formats), type);
		if (ret < 0)
			return ret;

diff --git a/drivers/gpu/drm/rcar-du/rcar_du_plane.h b/drivers/gpu/drm/rcar-du/rcar_du_plane.h
index b18b7b2..9732bff 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_plane.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_plane.h
@@ -28,12 +28,6 @@ struct rcar_du_group;
 #define RCAR_DU_NUM_KMS_PLANES		9
 #define RCAR_DU_NUM_HW_PLANES		8

-enum rcar_du_plane_source {
-	RCAR_DU_PLANE_MEMORY,
-	RCAR_DU_PLANE_VSPD0,
-	RCAR_DU_PLANE_VSPD1,
-};
-
 struct rcar_du_plane {
	struct drm_plane plane;
	struct rcar_du_group *group;
@@ -58,7 +52,6 @@ struct rcar_du_plane_state {

	const struct rcar_du_format_info *format;
	int hwindex;
-	enum rcar_du_plane_source source;

	unsigned int alpha;
	unsigned int colorkey;
@@ -71,20 +64,8 @@ to_rcar_plane_state(struct drm_plane_state *state)
	return container_of(state, struct rcar_du_plane_state, state);
 }

-int rcar_du_atomic_check_planes(struct drm_device *dev,
-				struct drm_atomic_state *state);
-
 int rcar_du_planes_init(struct rcar_du_group *rgrp);

-void __rcar_du_plane_setup(struct rcar_du_group *rgrp,
-			   const struct rcar_du_plane_state *state);
-
-static inline void rcar_du_plane_setup(struct rcar_du_plane *plane)
-{
-	struct rcar_du_plane_state *state =
-		to_rcar_plane_state(plane->plane.state);
-
-	return __rcar_du_plane_setup(plane->group, state);
-}
+void rcar_du_plane_setup(struct rcar_du_plane *plane);

 #endif /* __RCAR_DU_PLANE_H__ */
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_regs.h b/drivers/gpu/drm/rcar-du/rcar_du_regs.h
index 2a62e9f..70fcbc4 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_regs.h
+++ b/drivers/gpu/drm/rcar-du/rcar_du_regs.h
@@ -1,7 +1,7 @@
 /*
  * rcar_du_regs.h  --  R-Car Display Unit Registers Definitions
  *
- * Copyright (C) 2013-2015 Renesas Electronics Corporation
+ * Copyright (C) 2013 Renesas Electronics Corporation
  *
  * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
  *
@@ -16,7 +16,6 @@
 #define DU0_REG_OFFSET		0x00000
 #define DU1_REG_OFFSET		0x30000
 #define DU2_REG_OFFSET		0x40000
-#define DU3_REG_OFFSET		0x70000

 /* -----------------------------------------------------------------------------
  * Display Control Registers
@@ -261,21 +260,6 @@
 #define DIDSR_PDCS_CLK(n, clk)	(clk << ((n) * 2))
 #define DIDSR_PDCS_MASK(n)	(3 << ((n) * 2))

-#define DEFR10			0x20038
-#define DEFR10_CODE		(0x7795 << 16)
-#define DEFR10_VSPF1_RGB	(0 << 14)
-#define DEFR10_VSPF1_YC		(1 << 14)
-#define DEFR10_DOCF1_RGB	(0 << 12)
-#define DEFR10_DOCF1_YC		(1 << 12)
-#define DEFR10_YCDF0_YCBCR444	(0 << 11)
-#define DEFR10_YCDF0_YCBCR422	(1 << 11)
-#define DEFR10_VSPF0_RGB	(0 << 10)
-#define DEFR10_VSPF0_YC		(1 << 10)
-#define DEFR10_DOCF0_RGB	(0 << 8)
-#define DEFR10_DOCF0_YC		(1 << 8)
-#define DEFR10_TSEL_H3_TCON1	(0 << 1) /* DEFR102 register only (DU2/DU3) */
-#define DEFR10_DEFE10		(1 << 0)
-
 /* -----------------------------------------------------------------------------
  * Display Timing Generation Registers
  */
@@ -405,7 +389,6 @@

 #define PnDDCR4			0x00190
 #define PnDDCR4_CODE		(0x7766 << 16)
-#define PnDDCR4_VSPS		(1 << 13)
 #define PnDDCR4_SDFS_RGB	(0 << 4)
 #define PnDDCR4_SDFS_YC		(5 << 4)
 #define PnDDCR4_SDFS_MASK	(7 << 4)
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_vgacon.c b/drivers/gpu/drm/rcar-du/rcar_du_vgacon.c
index a03bab1..e0a5d8f 100644
--- a/drivers/gpu/drm/rcar-du/rcar_du_vgacon.c
+++ b/drivers/gpu/drm/rcar-du/rcar_du_vgacon.c
@@ -23,7 +23,7 @@

 static int rcar_du_vga_connector_get_modes(struct drm_connector *connector)
 {
-	return drm_add_modes_noedid(connector, 1280, 768);
+	return 0;
 }

 static const struct drm_connector_helper_funcs connector_helper_funcs = {
@@ -31,6 +31,12 @@ static const struct drm_connector_helper_funcs connector_helper_funcs = {
	.best_encoder = rcar_du_connector_best_encoder,
 };

+static void rcar_du_vga_connector_destroy(struct drm_connector *connector)
+{
+	drm_connector_unregister(connector);
+	drm_connector_cleanup(connector);
+}
+
 static enum drm_connector_status
 rcar_du_vga_connector_detect(struct drm_connector *connector, bool force)
 {
@@ -42,7 +48,7 @@ static const struct drm_connector_funcs connector_funcs = {
	.reset = drm_atomic_helper_connector_reset,
	.detect = rcar_du_vga_connector_detect,
	.fill_modes = drm_helper_probe_single_connector_modes,
-	.destroy = drm_connector_cleanup,
+	.destroy = rcar_du_vga_connector_destroy,
	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
 };
@@ -70,6 +76,9 @@ int rcar_du_vga_connector_init(struct rcar_du_device *rcdu,
		return ret;

	drm_connector_helper_add(connector, &connector_helper_funcs);
+	ret = drm_connector_register(connector);
+	if (ret < 0)
+		return ret;

	connector->dpms = DRM_MODE_DPMS_OFF;
	drm_object_property_set_value(&connector->base,
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_vsp.c b/drivers/gpu/drm/rcar-du/rcar_du_vsp.c
deleted file mode 100644
index 6673648..0000000
--- a/drivers/gpu/drm/rcar-du/rcar_du_vsp.c
+++ /dev/null
@@ -1,401 +0,0 @@
-/*
- * rcar_du_vsp.h  --  R-Car Display Unit VSP-Based Compositor
- *
- * Copyright (C) 2015 Renesas Electronics Corporation
- *
- * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <drm/drmP.h>
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_crtc.h>
-#include <drm/drm_crtc_helper.h>
-#include <drm/drm_fb_cma_helper.h>
-#include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_plane_helper.h>
-
-#include <linux/of_platform.h>
-#include <linux/videodev2.h>
-
-#include <media/vsp1.h>
-
-#include "rcar_du_drv.h"
-#include "rcar_du_kms.h"
-#include "rcar_du_vsp.h"
-
-void rcar_du_vsp_enable(struct rcar_du_crtc *crtc)
-{
-	if (crtc->vsp->vsp) {
-
-		const struct drm_display_mode *mode = &crtc->crtc.state->adjusted_mode;
-		struct rcar_du_device *rcdu = crtc->group->dev;
-		struct rcar_du_plane_state state = {
-			.state = {
-				.crtc = &crtc->crtc,
-				.crtc_x = 0,
-				.crtc_y = 0,
-				.crtc_w = mode->hdisplay,
-				.crtc_h = mode->vdisplay,
-				.src_x = 0,
-				.src_y = 0,
-				.src_w = mode->hdisplay << 16,
-				.src_h = mode->vdisplay << 16,
-			},
-			.format = rcar_du_format_info(DRM_FORMAT_ARGB8888),
-			.source = RCAR_DU_PLANE_VSPD0,
-			.alpha = 255,
-			.colorkey = 0,
-			.zpos = 1,
-		};
-
-		if (rcdu->info->gen >= 3)
-			state.hwindex = (crtc->index % 2) ? 2 : 0;
-		else
-			state.hwindex = crtc->index % 2;
-
-		__rcar_du_plane_setup(crtc->group, &state);
-
-		/* Ensure that the plane source configuration takes effect by requesting
-		 * a restart of the group. See rcar_du_plane_atomic_update() for a more
-		 * detailed explanation.
-		 *
-		 * TODO: Check whether this is still needed on Gen3.
-		 */
-		crtc->group->need_restart = true;
-
-		vsp1_du_setup_lif(crtc->vsp->vsp, mode->hdisplay, mode->vdisplay);
-	}
-}
-
-void rcar_du_vsp_disable(struct rcar_du_crtc *crtc)
-{
-	if (crtc->vsp->vsp)
-		vsp1_du_setup_lif(crtc->vsp->vsp, 0, 0);
-}
-
-void rcar_du_vsp_atomic_begin(struct rcar_du_crtc *crtc)
-{
-	if (crtc->vsp->vsp)
-		vsp1_du_atomic_begin(crtc->vsp->vsp);
-}
-
-void rcar_du_vsp_atomic_flush(struct rcar_du_crtc *crtc)
-{
-	if (crtc->vsp->vsp)
-		vsp1_du_atomic_flush(crtc->vsp->vsp);
-}
-
-/* Keep the two tables in sync. */
-static const u32 formats_kms[] = {
-	DRM_FORMAT_RGB332,
-	DRM_FORMAT_ARGB4444,
-	DRM_FORMAT_XRGB4444,
-	DRM_FORMAT_ARGB1555,
-	DRM_FORMAT_XRGB1555,
-	DRM_FORMAT_RGB565,
-	DRM_FORMAT_BGR888,
-	DRM_FORMAT_RGB888,
-	DRM_FORMAT_BGRA8888,
-	DRM_FORMAT_BGRX8888,
-	DRM_FORMAT_ARGB8888,
-	DRM_FORMAT_XRGB8888,
-	DRM_FORMAT_UYVY,
-	DRM_FORMAT_VYUY,
-	DRM_FORMAT_YUYV,
-	DRM_FORMAT_YVYU,
-	DRM_FORMAT_NV12,
-	DRM_FORMAT_NV21,
-	DRM_FORMAT_NV16,
-	DRM_FORMAT_NV61,
-};
-
-static const u32 formats_v4l2[] = {
-	V4L2_PIX_FMT_RGB332,
-	V4L2_PIX_FMT_ARGB444,
-	V4L2_PIX_FMT_XRGB444,
-	V4L2_PIX_FMT_ARGB555,
-	V4L2_PIX_FMT_XRGB555,
-	V4L2_PIX_FMT_RGB565,
-	V4L2_PIX_FMT_RGB24,
-	V4L2_PIX_FMT_BGR24,
-	V4L2_PIX_FMT_ARGB32,
-	V4L2_PIX_FMT_XRGB32,
-	V4L2_PIX_FMT_ABGR32,
-	V4L2_PIX_FMT_XBGR32,
-	V4L2_PIX_FMT_UYVY,
-	V4L2_PIX_FMT_VYUY,
-	V4L2_PIX_FMT_YUYV,
-	V4L2_PIX_FMT_YVYU,
-	V4L2_PIX_FMT_NV12M,
-	V4L2_PIX_FMT_NV21M,
-	V4L2_PIX_FMT_NV16M,
-	V4L2_PIX_FMT_NV61M,
-};
-
-static void rcar_du_vsp_plane_setup(struct rcar_du_vsp_plane *plane)
-{
-	struct rcar_du_vsp_plane_state *state =
-		to_rcar_vsp_plane_state(plane->plane.state);
-	struct drm_framebuffer *fb = plane->plane.state->fb;
-	struct drm_gem_cma_object *gem;
-	struct v4l2_rect src;
-	struct v4l2_rect dst;
-	dma_addr_t paddr[2] = { 0, };
-	u32 pixelformat = 0;
-	unsigned int i;
-
-	src.left = state->state.src_x >> 16;
-	src.top = state->state.src_y >> 16;
-	src.width = state->state.src_w >> 16;
-	src.height = state->state.src_h >> 16;
-
-	dst.left = state->state.crtc_x;
-	dst.top = state->state.crtc_y;
-	dst.width = state->state.crtc_w;
-	dst.height = state->state.crtc_h;
-
-	gem = drm_fb_cma_get_gem_obj(fb, 0);
-	paddr[0] = gem->paddr + fb->offsets[0];
-
-	if (state->format->planes == 2) {
-		gem = drm_fb_cma_get_gem_obj(fb, 1);
-		paddr[1] = gem->paddr + fb->offsets[1];
-	}
-
-	for (i = 0; i < ARRAY_SIZE(formats_kms); ++i) {
-		if (formats_kms[i] == state->format->fourcc) {
-			pixelformat = formats_v4l2[i];
-			break;
-		}
-	}
-
-	WARN_ON(!pixelformat);
-
-	if (plane->vsp->vsp)
-		vsp1_du_atomic_update(plane->vsp->vsp, plane->index, pixelformat,
-                             fb->pitches[0], paddr, &src, &dst);
-}
-
-static int rcar_du_vsp_plane_atomic_check(struct drm_plane *plane,
-					  struct drm_plane_state *state)
-{
-	struct rcar_du_vsp_plane_state *rstate = to_rcar_vsp_plane_state(state);
-	struct rcar_du_vsp_plane *rplane = to_rcar_vsp_plane(plane);
-	struct rcar_du_device *rcdu = rplane->vsp->dev;
-
-	if (!state->fb || !state->crtc) {
-		rstate->format = NULL;
-		return 0;
-	}
-
-	if (state->src_w >> 16 != state->crtc_w ||
-	    state->src_h >> 16 != state->crtc_h) {
-		dev_dbg(rcdu->dev, "%s: scaling not supported\n", __func__);
-		return -EINVAL;
-	}
-
-	rstate->format = rcar_du_format_info(state->fb->pixel_format);
-	if (rstate->format == NULL) {
-		dev_dbg(rcdu->dev, "%s: unsupported format %08x\n", __func__,
-			state->fb->pixel_format);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static void rcar_du_vsp_plane_atomic_update(struct drm_plane *plane,
-					struct drm_plane_state *old_state)
-{
-	struct rcar_du_vsp_plane *rplane = to_rcar_vsp_plane(plane);
-
-	if (rplane->vsp->vsp) {
-		if (plane->state->crtc)
-			rcar_du_vsp_plane_setup(rplane);
-		else
-			vsp1_du_atomic_update(rplane->vsp->vsp, rplane->index, 0, 0, 0, NULL, NULL);
-	}
-	else {
-		struct rcar_du_plane_state state = {
-			.format = rcar_du_format_info(DRM_FORMAT_ARGB8888),
-			.source = RCAR_DU_PLANE_MEMORY,
-			.alpha = 255,
-			.colorkey = 0,
-			.zpos = 0,
-		};
-
-		state.state = *(plane->state);
-
-		if (!plane->state->crtc)
-			return;
-
-		state.hwindex = (rplane->index + 4 % 8);
-
-		__rcar_du_plane_setup(rplane->vsp->group,&state);
-	}
-}
-
-static const struct drm_plane_helper_funcs rcar_du_vsp_plane_helper_funcs = {
-	.atomic_check = rcar_du_vsp_plane_atomic_check,
-	.atomic_update = rcar_du_vsp_plane_atomic_update,
-};
-
-static struct drm_plane_state *
-rcar_du_vsp_plane_atomic_duplicate_state(struct drm_plane *plane)
-{
-	struct rcar_du_vsp_plane_state *state;
-	struct rcar_du_vsp_plane_state *copy;
-
-	if (WARN_ON(!plane->state))
-		return NULL;
-
-	state = to_rcar_vsp_plane_state(plane->state);
-	copy = kmemdup(state, sizeof(*state), GFP_KERNEL);
-	if (copy == NULL)
-		return NULL;
-
-	__drm_atomic_helper_plane_duplicate_state(plane, &copy->state);
-
-	return &copy->state;
-}
-
-static void rcar_du_vsp_plane_atomic_destroy_state(struct drm_plane *plane,
-						   struct drm_plane_state *state)
-{
-	__drm_atomic_helper_plane_destroy_state(plane, state);
-	kfree(to_rcar_vsp_plane_state(state));
-}
-
-static void rcar_du_vsp_plane_reset(struct drm_plane *plane)
-{
-	struct rcar_du_vsp_plane_state *state;
-
-	if (plane->state) {
-		rcar_du_vsp_plane_atomic_destroy_state(plane, plane->state);
-		plane->state = NULL;
-	}
-
-	state = kzalloc(sizeof(*state), GFP_KERNEL);
-	if (state == NULL)
-		return;
-
-	state->alpha = 255;
-
-	plane->state = &state->state;
-	plane->state->plane = plane;
-}
-
-static int rcar_du_vsp_plane_atomic_set_property(struct drm_plane *plane,
-	struct drm_plane_state *state, struct drm_property *property,
-	uint64_t val)
-{
-	struct rcar_du_vsp_plane_state *rstate = to_rcar_vsp_plane_state(state);
-	struct rcar_du_device *rcdu = to_rcar_vsp_plane(plane)->vsp->dev;
-
-	if (property == rcdu->props.alpha)
-		rstate->alpha = val;
-	else
-		return -EINVAL;
-
-	return 0;
-}
-
-static int rcar_du_vsp_plane_atomic_get_property(struct drm_plane *plane,
-	const struct drm_plane_state *state, struct drm_property *property,
-	uint64_t *val)
-{
-	const struct rcar_du_vsp_plane_state *rstate =
-		container_of(state, const struct rcar_du_vsp_plane_state, state);
-	struct rcar_du_device *rcdu = to_rcar_vsp_plane(plane)->vsp->dev;
-
-	if (property == rcdu->props.alpha)
-		*val = rstate->alpha;
-	else
-		return -EINVAL;
-
-	return 0;
-}
-
-static const struct drm_plane_funcs rcar_du_vsp_plane_funcs = {
-	.update_plane = drm_atomic_helper_update_plane,
-	.disable_plane = drm_atomic_helper_disable_plane,
-	.reset = rcar_du_vsp_plane_reset,
-	.set_property = drm_atomic_helper_plane_set_property,
-	.destroy = drm_plane_cleanup,
-	.atomic_duplicate_state = rcar_du_vsp_plane_atomic_duplicate_state,
-	.atomic_destroy_state = rcar_du_vsp_plane_atomic_destroy_state,
-	.atomic_set_property = rcar_du_vsp_plane_atomic_set_property,
-	.atomic_get_property = rcar_du_vsp_plane_atomic_get_property,
-};
-
-int rcar_du_vsp_init(struct rcar_du_vsp *vsp)
-{
-	struct rcar_du_device *rcdu = vsp->dev;
-	struct platform_device *pdev;
-	struct device_node *np;
-	unsigned int i;
-	int ret;
-
-	/* Find the VSP device and initialize it. */
-	if ((1 << vsp->index ) & (rcdu->info->vspd_crtcs)) {
-		np = of_parse_phandle(rcdu->dev->of_node, "vsps", vsp->index);
-		if (!np) {
-			dev_err(rcdu->dev, "vsps node not found\n");
-			return -ENXIO;
-		}
-
-		pdev = of_find_device_by_node(np);
-		of_node_put(np);
-		if (!pdev)
-			return -ENXIO;
-
-		vsp->vsp = &pdev->dev;
-
-		ret = vsp1_du_init(vsp->vsp);
-		if (ret < 0)
-			return ret;
-	}
-	 /* The VSP2D (Gen3) has 5 RPFs, but the VSP1D (Gen2) is limited to
-	  * 4 RPFs.
-	  */
-	vsp->num_planes = rcdu->info->gen >= 3 ? 5 : 4;
-
-	vsp->planes = devm_kcalloc(rcdu->dev, vsp->num_planes,
-				   sizeof(*vsp->planes), GFP_KERNEL);
-	if (!vsp->planes)
-		return -ENOMEM;
-
-	for (i = 0; i < vsp->num_planes; ++i) {
-		enum drm_plane_type type = i ? DRM_PLANE_TYPE_OVERLAY
-					 : DRM_PLANE_TYPE_PRIMARY;
-		struct rcar_du_vsp_plane *plane = &vsp->planes[i];
-
-		plane->vsp = vsp;
-		plane->index = i;
-
-		ret = drm_universal_plane_init(rcdu->ddev, &plane->plane,
-					       1 << vsp->index,
-					       &rcar_du_vsp_plane_funcs,
-					       formats_kms,
-					       ARRAY_SIZE(formats_kms), type,
-					       NULL);
-		if (ret < 0)
-			return ret;
-
-		drm_plane_helper_add(&plane->plane,
-				     &rcar_du_vsp_plane_helper_funcs);
-
-		if (type == DRM_PLANE_TYPE_PRIMARY)
-			continue;
-
-		drm_object_attach_property(&plane->plane.base,
-					   rcdu->props.alpha, 255);
-	}
-
-	return 0;
-}
diff --git a/drivers/gpu/drm/rcar-du/rcar_du_vsp.h b/drivers/gpu/drm/rcar-du/rcar_du_vsp.h
deleted file mode 100644
index 2f21daa..0000000
--- a/drivers/gpu/drm/rcar-du/rcar_du_vsp.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * rcar_du_vsp.h  --  R-Car Display Unit VSP-Based Compositor
- *
- * Copyright (C) 2015 Renesas Electronics Corporation
- *
- * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#ifndef __RCAR_DU_VSP_H__
-#define __RCAR_DU_VSP_H__
-
-#include <drm/drmP.h>
-#include <drm/drm_crtc.h>
-
-struct rcar_du_format_info;
-struct rcar_du_vsp;
-struct rcar_du_group;
-
-struct rcar_du_vsp_plane {
-	struct drm_plane plane;
-	struct rcar_du_vsp *vsp;
-	unsigned int index;
-};
-
-struct rcar_du_vsp {
-	unsigned int index;
-	struct device *vsp;
-	struct rcar_du_device *dev;
-	struct rcar_du_vsp_plane *planes;
-	struct rcar_du_group* group;
-	unsigned int num_planes;
-};
-
-static inline struct rcar_du_vsp_plane *to_rcar_vsp_plane(struct drm_plane *p)
-{
-	return container_of(p, struct rcar_du_vsp_plane, plane);
-}
-
-/**
- * struct rcar_du_vsp_plane_state - Driver-specific plane state
- * @state: base DRM plane state
- * @format: information about the pixel format used by the plane
- * @alpha: value of the plane alpha property
- */
-struct rcar_du_vsp_plane_state {
-	struct drm_plane_state state;
-
-	const struct rcar_du_format_info *format;
-
-	unsigned int alpha;
-};
-
-static inline struct rcar_du_vsp_plane_state *
-to_rcar_vsp_plane_state(struct drm_plane_state *state)
-{
-	return container_of(state, struct rcar_du_vsp_plane_state, state);
-}
-
-#ifdef CONFIG_DRM_RCAR_VSP
-int rcar_du_vsp_init(struct rcar_du_vsp *vsp);
-void rcar_du_vsp_enable(struct rcar_du_crtc *crtc);
-void rcar_du_vsp_disable(struct rcar_du_crtc *crtc);
-void rcar_du_vsp_atomic_begin(struct rcar_du_crtc *crtc);
-void rcar_du_vsp_atomic_flush(struct rcar_du_crtc *crtc);
-#else
-static inline int rcar_du_vsp_init(struct rcar_du_vsp *vsp) { return 0; };
-static inline void rcar_du_vsp_enable(struct rcar_du_crtc *crtc) { };
-static inline void rcar_du_vsp_disable(struct rcar_du_crtc *crtc) { };
-static inline void rcar_du_vsp_atomic_begin(struct rcar_du_crtc *crtc) { };
-static inline void rcar_du_vsp_atomic_flush(struct rcar_du_crtc *crtc) { };
-#endif
-
-#endif /* __RCAR_DU_VSP_H__ */
diff --git a/drivers/gpu/drm/rcar-du/rcar_lvds_regs.h b/drivers/gpu/drm/rcar-du/rcar_lvds_regs.h
index d7d294b..77cf928 100644
--- a/drivers/gpu/drm/rcar-du/rcar_lvds_regs.h
+++ b/drivers/gpu/drm/rcar-du/rcar_lvds_regs.h
@@ -1,7 +1,7 @@
 /*
  * rcar_lvds_regs.h  --  R-Car LVDS Interface Registers Definitions
  *
- * Copyright (C) 2013-2015 Renesas Electronics Corporation
+ * Copyright (C) 2013 Renesas Electronics Corporation
  *
  * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
  *
@@ -15,38 +15,28 @@

 #define LVDCR0				0x0000
 #define LVDCR0_DUSEL			(1 << 15)
-#define LVDCR0_DMD			(1 << 12)		/* Gen2 only */
+#define LVDCR0_DMD			(1 << 12)
 #define LVDCR0_LVMD_MASK		(0xf << 8)
 #define LVDCR0_LVMD_SHIFT		8
-#define LVDCR0_PLLON			(1 << 4)
-#define LVDCR0_PWD			(1 << 2)		/* Gen3 only */
-#define LVDCR0_BEN			(1 << 2)		/* Gen2 only */
-#define LVDCR0_LVEN			(1 << 1)		/* Gen2 only */
+#define LVDCR0_PLLEN			(1 << 4)
+#define LVDCR0_BEN			(1 << 2)
+#define LVDCR0_LVEN			(1 << 1)
 #define LVDCR0_LVRES			(1 << 0)

 #define LVDCR1				0x0004
-#define LVDCR1_CKSEL			(1 << 15)		/* Gen2 only */
-#define LVDCR1_CHSTBY_GEN2(n)		(3 << (2 + (n) * 2))	/* Gen2 only */
-#define LVDCR1_CHSTBY_GEN3(n)		(1 << (2 + (n) * 2))	/* Gen3 only */
-#define LVDCR1_CLKSTBY_GEN2		(3 << 0)		/* Gen2 only */
-#define LVDCR1_CLKSTBY_GEN3		(1 << 0)		/* Gen3 only */
+#define LVDCR1_CKSEL			(1 << 15)
+#define LVDCR1_CHSTBY(n)		(3 << (2 + (n) * 2))
+#define LVDCR1_CLKSTBY			(3 << 0)

 #define LVDPLLCR			0x0008
 #define LVDPLLCR_CEEN			(1 << 14)
 #define LVDPLLCR_FBEN			(1 << 13)
 #define LVDPLLCR_COSEL			(1 << 12)
-/* Gen2 */
 #define LVDPLLCR_PLLDLYCNT_150M		(0x1bf << 0)
 #define LVDPLLCR_PLLDLYCNT_121M		(0x22c << 0)
 #define LVDPLLCR_PLLDLYCNT_60M		(0x77b << 0)
 #define LVDPLLCR_PLLDLYCNT_38M		(0x69a << 0)
 #define LVDPLLCR_PLLDLYCNT_MASK		(0x7ff << 0)
-/* Gen3 */
-#define LVDPLLCR_PLLDIVCNT_42M		(0x014cb << 0)
-#define LVDPLLCR_PLLDIVCNT_85M		(0x00a45 << 0)
-#define LVDPLLCR_PLLDIVCNT_128M		(0x006c3 << 0)
-#define LVDPLLCR_PLLDIVCNT_148M		(0x046c1 << 0)
-#define LVDPLLCR_PLLDIVCNT_MASK		(0x7ffff << 0)

 #define LVDCTRCR			0x000c
 #define LVDCTRCR_CTR3SEL_ZERO		(0 << 12)
diff --git a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
index 525b5a8..80d6fc8 100644
--- a/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
+++ b/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c
@@ -295,7 +295,7 @@ static int dw_hdmi_rockchip_bind(struct device *dev, struct device *master,

	drm_encoder_helper_add(encoder, &dw_hdmi_rockchip_encoder_helper_funcs);
	drm_encoder_init(drm, encoder, &dw_hdmi_rockchip_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);

	return dw_hdmi_bind(dev, master, data, encoder, iores, irq, plat_data);
 }
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_fb.c b/drivers/gpu/drm/rockchip/rockchip_drm_fb.c
index b8ac591..002645b 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_fb.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_fb.c
@@ -72,7 +72,7 @@ static struct drm_framebuffer_funcs rockchip_drm_fb_funcs = {
 };

 static struct rockchip_drm_fb *
-rockchip_fb_alloc(struct drm_device *dev, const struct drm_mode_fb_cmd2 *mode_cmd,
+rockchip_fb_alloc(struct drm_device *dev, struct drm_mode_fb_cmd2 *mode_cmd,
		  struct drm_gem_object **obj, unsigned int num_planes)
 {
	struct rockchip_drm_fb *rockchip_fb;
@@ -102,7 +102,7 @@ rockchip_fb_alloc(struct drm_device *dev, const struct drm_mode_fb_cmd2 *mode_cm

 static struct drm_framebuffer *
 rockchip_user_fb_create(struct drm_device *dev, struct drm_file *file_priv,
-			const struct drm_mode_fb_cmd2 *mode_cmd)
+			struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct rockchip_drm_fb *rockchip_fb;
	struct drm_gem_object *objs[ROCKCHIP_MAX_FB_BUFFER];
@@ -173,7 +173,7 @@ static const struct drm_mode_config_funcs rockchip_drm_mode_config_funcs = {

 struct drm_framebuffer *
 rockchip_drm_framebuffer_init(struct drm_device *dev,
-			      const struct drm_mode_fb_cmd2 *mode_cmd,
+			      struct drm_mode_fb_cmd2 *mode_cmd,
			      struct drm_gem_object *obj)
 {
	struct rockchip_drm_fb *rockchip_fb;
diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_fb.h b/drivers/gpu/drm/rockchip/rockchip_drm_fb.h
index 2fe47f1..09574d4 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_fb.h
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_fb.h
@@ -17,7 +17,7 @@

 struct drm_framebuffer *
 rockchip_drm_framebuffer_init(struct drm_device *dev,
-			      const struct drm_mode_fb_cmd2 *mode_cmd,
+			      struct drm_mode_fb_cmd2 *mode_cmd,
			      struct drm_gem_object *obj);
 void rockchip_drm_framebuffer_fini(struct drm_framebuffer *fb);

diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
index dd8e086..03c47ee 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
@@ -1478,7 +1478,7 @@ static int vop_create_crtc(struct vop *vop)
					       0, &vop_plane_funcs,
					       win_data->phy->data_formats,
					       win_data->phy->nformats,
-					       win_data->type, NULL);
+					       win_data->type);
		if (ret) {
			DRM_ERROR("failed to initialize plane\n");
			goto err_cleanup_planes;
@@ -1492,7 +1492,7 @@ static int vop_create_crtc(struct vop *vop)
	}

	ret = drm_crtc_init_with_planes(drm_dev, crtc, primary, cursor,
-					&vop_crtc_funcs, NULL);
+					&vop_crtc_funcs);
	if (ret)
		return ret;

@@ -1515,7 +1515,7 @@ static int vop_create_crtc(struct vop *vop)
					       &vop_plane_funcs,
					       win_data->phy->data_formats,
					       win_data->phy->nformats,
-					       win_data->type, NULL);
+					       win_data->type);
		if (ret) {
			DRM_ERROR("failed to initialize overlay plane\n");
			goto err_cleanup_crtc;
diff --git a/drivers/gpu/drm/shmobile/shmob_drm_crtc.c b/drivers/gpu/drm/shmobile/shmob_drm_crtc.c
index b80802f..e9272b0 100644
--- a/drivers/gpu/drm/shmobile/shmob_drm_crtc.c
+++ b/drivers/gpu/drm/shmobile/shmob_drm_crtc.c
@@ -613,7 +613,7 @@ int shmob_drm_encoder_create(struct shmob_drm_device *sdev)
	encoder->possible_crtcs = 1;

	ret = drm_encoder_init(sdev->ddev, encoder, &encoder_funcs,
-			       DRM_MODE_ENCODER_LVDS, NULL);
+			       DRM_MODE_ENCODER_LVDS);
	if (ret < 0)
		return ret;

diff --git a/drivers/gpu/drm/shmobile/shmob_drm_kms.c b/drivers/gpu/drm/shmobile/shmob_drm_kms.c
index 388a0fc..aaf98ac 100644
--- a/drivers/gpu/drm/shmobile/shmob_drm_kms.c
+++ b/drivers/gpu/drm/shmobile/shmob_drm_kms.c
@@ -104,7 +104,7 @@ const struct shmob_drm_format_info *shmob_drm_format_info(u32 fourcc)

 static struct drm_framebuffer *
 shmob_drm_fb_create(struct drm_device *dev, struct drm_file *file_priv,
-		    const struct drm_mode_fb_cmd2 *mode_cmd)
+		    struct drm_mode_fb_cmd2 *mode_cmd)
 {
	const struct shmob_drm_format_info *format;

diff --git a/drivers/gpu/drm/sti/sti_crtc.c b/drivers/gpu/drm/sti/sti_crtc.c
index de11c7c..3ae09dc 100644
--- a/drivers/gpu/drm/sti/sti_crtc.c
+++ b/drivers/gpu/drm/sti/sti_crtc.c
@@ -367,7 +367,7 @@ int sti_crtc_init(struct drm_device *drm_dev, struct sti_mixer *mixer,
	int res;

	res = drm_crtc_init_with_planes(drm_dev, crtc, primary, cursor,
-					&sti_crtc_funcs, NULL);
+					&sti_crtc_funcs);
	if (res) {
		DRM_ERROR("Can't initialze CRTC\n");
		return -EINVAL;
diff --git a/drivers/gpu/drm/sti/sti_cursor.c b/drivers/gpu/drm/sti/sti_cursor.c
index 8078631..dd10321 100644
--- a/drivers/gpu/drm/sti/sti_cursor.c
+++ b/drivers/gpu/drm/sti/sti_cursor.c
@@ -272,7 +272,7 @@ struct drm_plane *sti_cursor_create(struct drm_device *drm_dev,
				       &sti_plane_helpers_funcs,
				       cursor_supported_formats,
				       ARRAY_SIZE(cursor_supported_formats),
-				       DRM_PLANE_TYPE_CURSOR, NULL);
+				       DRM_PLANE_TYPE_CURSOR);
	if (res) {
		DRM_ERROR("Failed to initialize universal plane\n");
		goto err_plane;
diff --git a/drivers/gpu/drm/sti/sti_gdp.c b/drivers/gpu/drm/sti/sti_gdp.c
index f9a1d92..c85dc7d 100644
--- a/drivers/gpu/drm/sti/sti_gdp.c
+++ b/drivers/gpu/drm/sti/sti_gdp.c
@@ -630,7 +630,7 @@ struct drm_plane *sti_gdp_create(struct drm_device *drm_dev,
				       &sti_plane_helpers_funcs,
				       gdp_supported_formats,
				       ARRAY_SIZE(gdp_supported_formats),
-				       type, NULL);
+				       type);
	if (res) {
		DRM_ERROR("Failed to initialize universal plane\n");
		goto err;
diff --git a/drivers/gpu/drm/sti/sti_hqvdp.c b/drivers/gpu/drm/sti/sti_hqvdp.c
index 43861b5..ea0690b 100644
--- a/drivers/gpu/drm/sti/sti_hqvdp.c
+++ b/drivers/gpu/drm/sti/sti_hqvdp.c
@@ -973,7 +973,7 @@ static struct drm_plane *sti_hqvdp_create(struct drm_device *drm_dev,
				       &sti_plane_helpers_funcs,
				       hqvdp_supported_formats,
				       ARRAY_SIZE(hqvdp_supported_formats),
-				       DRM_PLANE_TYPE_OVERLAY, NULL);
+				       DRM_PLANE_TYPE_OVERLAY);
	if (res) {
		DRM_ERROR("Failed to initialize universal plane\n");
		return NULL;
diff --git a/drivers/gpu/drm/sti/sti_tvout.c b/drivers/gpu/drm/sti/sti_tvout.c
index f2afcf5..c8a4c5d 100644
--- a/drivers/gpu/drm/sti/sti_tvout.c
+++ b/drivers/gpu/drm/sti/sti_tvout.c
@@ -512,8 +512,7 @@ sti_tvout_create_dvo_encoder(struct drm_device *dev,
	drm_encoder->possible_clones = 1 << 0;

	drm_encoder_init(dev, drm_encoder,
-			 &sti_tvout_encoder_funcs, DRM_MODE_ENCODER_LVDS,
-			 NULL);
+			 &sti_tvout_encoder_funcs, DRM_MODE_ENCODER_LVDS);

	drm_encoder_helper_add(drm_encoder, &sti_dvo_encoder_helper_funcs);

@@ -565,7 +564,7 @@ static struct drm_encoder *sti_tvout_create_hda_encoder(struct drm_device *dev,
	drm_encoder->possible_clones = 1 << 0;

	drm_encoder_init(dev, drm_encoder,
-			&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_DAC, NULL);
+			&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_DAC);

	drm_encoder_helper_add(drm_encoder, &sti_hda_encoder_helper_funcs);

@@ -614,7 +613,7 @@ static struct drm_encoder *sti_tvout_create_hdmi_encoder(struct drm_device *dev,
	drm_encoder->possible_clones = 1 << 1;

	drm_encoder_init(dev, drm_encoder,
-			&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_TMDS, NULL);
+			&sti_tvout_encoder_funcs, DRM_MODE_ENCODER_TMDS);

	drm_encoder_helper_add(drm_encoder, &sti_hdmi_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/tegra/dc.c b/drivers/gpu/drm/tegra/dc.c
index 1f5cb68..e9f24a8 100644
--- a/drivers/gpu/drm/tegra/dc.c
+++ b/drivers/gpu/drm/tegra/dc.c
@@ -660,8 +660,7 @@ static struct drm_plane *tegra_dc_primary_plane_create(struct drm_device *drm,

	err = drm_universal_plane_init(drm, &plane->base, possible_crtcs,
				       &tegra_primary_plane_funcs, formats,
-				       num_formats, DRM_PLANE_TYPE_PRIMARY,
-				       NULL);
+				       num_formats, DRM_PLANE_TYPE_PRIMARY);
	if (err < 0) {
		kfree(plane);
		return ERR_PTR(err);
@@ -828,8 +827,7 @@ static struct drm_plane *tegra_dc_cursor_plane_create(struct drm_device *drm,

	err = drm_universal_plane_init(drm, &plane->base, 1 << dc->pipe,
				       &tegra_cursor_plane_funcs, formats,
-				       num_formats, DRM_PLANE_TYPE_CURSOR,
-				       NULL);
+				       num_formats, DRM_PLANE_TYPE_CURSOR);
	if (err < 0) {
		kfree(plane);
		return ERR_PTR(err);
@@ -892,8 +890,7 @@ static struct drm_plane *tegra_dc_overlay_plane_create(struct drm_device *drm,

	err = drm_universal_plane_init(drm, &plane->base, 1 << dc->pipe,
				       &tegra_overlay_plane_funcs, formats,
-				       num_formats, DRM_PLANE_TYPE_OVERLAY,
-				       NULL);
+				       num_formats, DRM_PLANE_TYPE_OVERLAY);
	if (err < 0) {
		kfree(plane);
		return ERR_PTR(err);
@@ -1735,7 +1732,7 @@ static int tegra_dc_init(struct host1x_client *client)
	}

	err = drm_crtc_init_with_planes(drm, &dc->base, primary, cursor,
-					&tegra_crtc_funcs, NULL);
+					&tegra_crtc_funcs);
	if (err < 0)
		goto cleanup;

diff --git a/drivers/gpu/drm/tegra/drm.h b/drivers/gpu/drm/tegra/drm.h
index 5ff5af3..ec49275 100644
--- a/drivers/gpu/drm/tegra/drm.h
+++ b/drivers/gpu/drm/tegra/drm.h
@@ -268,7 +268,7 @@ int tegra_fb_get_tiling(struct drm_framebuffer *framebuffer,
			struct tegra_bo_tiling *tiling);
 struct drm_framebuffer *tegra_fb_create(struct drm_device *drm,
					struct drm_file *file,
-					const struct drm_mode_fb_cmd2 *cmd);
+					struct drm_mode_fb_cmd2 *cmd);
 int tegra_drm_fb_prepare(struct drm_device *drm);
 void tegra_drm_fb_free(struct drm_device *drm);
 int tegra_drm_fb_init(struct drm_device *drm);
diff --git a/drivers/gpu/drm/tegra/dsi.c b/drivers/gpu/drm/tegra/dsi.c
index 50d46ae..f0a138e 100644
--- a/drivers/gpu/drm/tegra/dsi.c
+++ b/drivers/gpu/drm/tegra/dsi.c
@@ -1023,7 +1023,7 @@ static int tegra_dsi_init(struct host1x_client *client)

		drm_encoder_init(drm, &dsi->output.encoder,
				 &tegra_dsi_encoder_funcs,
-				 DRM_MODE_ENCODER_DSI, NULL);
+				 DRM_MODE_ENCODER_DSI);
		drm_encoder_helper_add(&dsi->output.encoder,
				       &tegra_dsi_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/tegra/fb.c b/drivers/gpu/drm/tegra/fb.c
index bf81dab..1004075 100644
--- a/drivers/gpu/drm/tegra/fb.c
+++ b/drivers/gpu/drm/tegra/fb.c
@@ -92,7 +92,7 @@ static struct drm_framebuffer_funcs tegra_fb_funcs = {
 };

 static struct tegra_fb *tegra_fb_alloc(struct drm_device *drm,
-				       const struct drm_mode_fb_cmd2 *mode_cmd,
+				       struct drm_mode_fb_cmd2 *mode_cmd,
				       struct tegra_bo **planes,
				       unsigned int num_planes)
 {
@@ -131,7 +131,7 @@ static struct tegra_fb *tegra_fb_alloc(struct drm_device *drm,

 struct drm_framebuffer *tegra_fb_create(struct drm_device *drm,
					struct drm_file *file,
-					const struct drm_mode_fb_cmd2 *cmd)
+					struct drm_mode_fb_cmd2 *cmd)
 {
	unsigned int hsub, vsub, i;
	struct tegra_bo *planes[4];
diff --git a/drivers/gpu/drm/tegra/hdmi.c b/drivers/gpu/drm/tegra/hdmi.c
index b7ef492..52b32cb 100644
--- a/drivers/gpu/drm/tegra/hdmi.c
+++ b/drivers/gpu/drm/tegra/hdmi.c
@@ -1320,7 +1320,7 @@ static int tegra_hdmi_init(struct host1x_client *client)
	hdmi->output.connector.dpms = DRM_MODE_DPMS_OFF;

	drm_encoder_init(drm, &hdmi->output.encoder, &tegra_hdmi_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);
	drm_encoder_helper_add(&hdmi->output.encoder,
			       &tegra_hdmi_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/tegra/rgb.c b/drivers/gpu/drm/tegra/rgb.c
index e246334..bc9735b 100644
--- a/drivers/gpu/drm/tegra/rgb.c
+++ b/drivers/gpu/drm/tegra/rgb.c
@@ -287,7 +287,7 @@ int tegra_dc_rgb_init(struct drm_device *drm, struct tegra_dc *dc)
	output->connector.dpms = DRM_MODE_DPMS_OFF;

	drm_encoder_init(drm, &output->encoder, &tegra_rgb_encoder_funcs,
-			 DRM_MODE_ENCODER_LVDS, NULL);
+			 DRM_MODE_ENCODER_LVDS);
	drm_encoder_helper_add(&output->encoder,
			       &tegra_rgb_encoder_helper_funcs);

diff --git a/drivers/gpu/drm/tegra/sor.c b/drivers/gpu/drm/tegra/sor.c
index 3e012ee..3eff7cf 100644
--- a/drivers/gpu/drm/tegra/sor.c
+++ b/drivers/gpu/drm/tegra/sor.c
@@ -2178,7 +2178,7 @@ static int tegra_sor_init(struct host1x_client *client)
	sor->output.connector.dpms = DRM_MODE_DPMS_OFF;

	drm_encoder_init(drm, &sor->output.encoder, &tegra_sor_encoder_funcs,
-			 encoder, NULL);
+			 encoder);
	drm_encoder_helper_add(&sor->output.encoder, helpers);

	drm_mode_connector_attach_encoder(&sor->output.connector,
diff --git a/drivers/gpu/drm/tilcdc/tilcdc_drv.c b/drivers/gpu/drm/tilcdc/tilcdc_drv.c
index 4ddb21e..876cad5 100644
--- a/drivers/gpu/drm/tilcdc/tilcdc_drv.c
+++ b/drivers/gpu/drm/tilcdc/tilcdc_drv.c
@@ -46,7 +46,7 @@ void tilcdc_module_cleanup(struct tilcdc_module *mod)
 static struct of_device_id tilcdc_of_match[];

 static struct drm_framebuffer *tilcdc_fb_create(struct drm_device *dev,
-		struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd)
+		struct drm_file *file_priv, struct drm_mode_fb_cmd2 *mode_cmd)
 {
	return drm_fb_cma_create(dev, file_priv, mode_cmd);
 }
diff --git a/drivers/gpu/drm/tilcdc/tilcdc_panel.c b/drivers/gpu/drm/tilcdc/tilcdc_panel.c
index 4dda6e2..0af8bed 100644
--- a/drivers/gpu/drm/tilcdc/tilcdc_panel.c
+++ b/drivers/gpu/drm/tilcdc/tilcdc_panel.c
@@ -128,7 +128,7 @@ static struct drm_encoder *panel_encoder_create(struct drm_device *dev,
	encoder->possible_crtcs = 1;

	ret = drm_encoder_init(dev, encoder, &panel_encoder_funcs,
-			DRM_MODE_ENCODER_LVDS, NULL);
+			DRM_MODE_ENCODER_LVDS);
	if (ret < 0)
		goto fail;

diff --git a/drivers/gpu/drm/tilcdc/tilcdc_tfp410.c b/drivers/gpu/drm/tilcdc/tilcdc_tfp410.c
index 5052a8a..354c47c 100644
--- a/drivers/gpu/drm/tilcdc/tilcdc_tfp410.c
+++ b/drivers/gpu/drm/tilcdc/tilcdc_tfp410.c
@@ -138,7 +138,7 @@ static struct drm_encoder *tfp410_encoder_create(struct drm_device *dev,
	encoder->possible_crtcs = 1;

	ret = drm_encoder_init(dev, encoder, &tfp410_encoder_funcs,
-			DRM_MODE_ENCODER_TMDS, NULL);
+			DRM_MODE_ENCODER_TMDS);
	if (ret < 0)
		goto fail;

diff --git a/drivers/gpu/drm/udl/udl_drv.h b/drivers/gpu/drm/udl/udl_drv.h
index 4a064ef..80adbac 100644
--- a/drivers/gpu/drm/udl/udl_drv.h
+++ b/drivers/gpu/drm/udl/udl_drv.h
@@ -108,7 +108,7 @@ void udl_fbdev_unplug(struct drm_device *dev);
 struct drm_framebuffer *
 udl_fb_user_fb_create(struct drm_device *dev,
		      struct drm_file *file,
-		      const struct drm_mode_fb_cmd2 *mode_cmd);
+		      struct drm_mode_fb_cmd2 *mode_cmd);

 int udl_render_hline(struct drm_device *dev, int bpp, struct urb **urb_ptr,
		     const char *front, char **urb_buf_ptr,
diff --git a/drivers/gpu/drm/udl/udl_encoder.c b/drivers/gpu/drm/udl/udl_encoder.c
index a181a64..4052c46 100644
--- a/drivers/gpu/drm/udl/udl_encoder.c
+++ b/drivers/gpu/drm/udl/udl_encoder.c
@@ -73,8 +73,7 @@ struct drm_encoder *udl_encoder_init(struct drm_device *dev)
	if (!encoder)
		return NULL;

-	drm_encoder_init(dev, encoder, &udl_enc_funcs, DRM_MODE_ENCODER_TMDS,
-			 NULL);
+	drm_encoder_init(dev, encoder, &udl_enc_funcs, DRM_MODE_ENCODER_TMDS);
	drm_encoder_helper_add(encoder, &udl_helper_funcs);
	encoder->possible_crtcs = 1;
	return encoder;
diff --git a/drivers/gpu/drm/udl/udl_fb.c b/drivers/gpu/drm/udl/udl_fb.c
index f09b11a..62c7b1d 100644
--- a/drivers/gpu/drm/udl/udl_fb.c
+++ b/drivers/gpu/drm/udl/udl_fb.c
@@ -456,7 +456,7 @@ static const struct drm_framebuffer_funcs udlfb_funcs = {
 static int
 udl_framebuffer_init(struct drm_device *dev,
		     struct udl_framebuffer *ufb,
-		     const struct drm_mode_fb_cmd2 *mode_cmd,
+		     struct drm_mode_fb_cmd2 *mode_cmd,
		     struct udl_gem_object *obj)
 {
	int ret;
@@ -624,7 +624,7 @@ void udl_fbdev_unplug(struct drm_device *dev)
 struct drm_framebuffer *
 udl_fb_user_fb_create(struct drm_device *dev,
		   struct drm_file *file,
-		   const struct drm_mode_fb_cmd2 *mode_cmd)
+		   struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_gem_object *obj;
	struct udl_framebuffer *ufb;
diff --git a/drivers/gpu/drm/vc4/vc4_crtc.c b/drivers/gpu/drm/vc4/vc4_crtc.c
index 2168a99..265064c 100644
--- a/drivers/gpu/drm/vc4/vc4_crtc.c
+++ b/drivers/gpu/drm/vc4/vc4_crtc.c
@@ -606,7 +606,7 @@ static int vc4_crtc_bind(struct device *dev, struct device *master, void *data)
	}

	drm_crtc_init_with_planes(drm, crtc, primary_plane, cursor_plane,
-				  &vc4_crtc_funcs, NULL);
+				  &vc4_crtc_funcs);
	drm_crtc_helper_add(crtc, &vc4_crtc_helper_funcs);
	primary_plane->crtc = crtc;
	cursor_plane->crtc = crtc;
diff --git a/drivers/gpu/drm/vc4/vc4_hdmi.c b/drivers/gpu/drm/vc4/vc4_hdmi.c
index c69c046..da9a36d 100644
--- a/drivers/gpu/drm/vc4/vc4_hdmi.c
+++ b/drivers/gpu/drm/vc4/vc4_hdmi.c
@@ -519,7 +519,7 @@ static int vc4_hdmi_bind(struct device *dev, struct device *master, void *data)
	WARN_ON_ONCE((HD_READ(VC4_HD_M_CTL) & VC4_HD_M_ENABLE) == 0);

	drm_encoder_init(drm, hdmi->encoder, &vc4_hdmi_encoder_funcs,
-			 DRM_MODE_ENCODER_TMDS, NULL);
+			 DRM_MODE_ENCODER_TMDS);
	drm_encoder_helper_add(hdmi->encoder, &vc4_hdmi_encoder_helper_funcs);

	hdmi->connector = vc4_hdmi_connector_init(drm, hdmi->encoder);
diff --git a/drivers/gpu/drm/vc4/vc4_plane.c b/drivers/gpu/drm/vc4/vc4_plane.c
index f34c422..887f3ca 100644
--- a/drivers/gpu/drm/vc4/vc4_plane.c
+++ b/drivers/gpu/drm/vc4/vc4_plane.c
@@ -317,7 +317,7 @@ struct drm_plane *vc4_plane_init(struct drm_device *dev,
	ret = drm_universal_plane_init(dev, plane, 0xff,
				       &vc4_plane_funcs,
				       formats, ARRAY_SIZE(formats),
-				       type, NULL);
+				       type);

	drm_plane_helper_add(plane, &vc4_plane_helper_funcs);

diff --git a/drivers/gpu/drm/virtio/virtgpu_display.c b/drivers/gpu/drm/virtio/virtgpu_display.c
index 923844e..578fe0a 100644
--- a/drivers/gpu/drm/virtio/virtgpu_display.c
+++ b/drivers/gpu/drm/virtio/virtgpu_display.c
@@ -215,7 +215,7 @@ static const struct drm_framebuffer_funcs virtio_gpu_fb_funcs = {
 int
 virtio_gpu_framebuffer_init(struct drm_device *dev,
			    struct virtio_gpu_framebuffer *vgfb,
-			    const struct drm_mode_fb_cmd2 *mode_cmd,
+			    struct drm_mode_fb_cmd2 *mode_cmd,
			    struct drm_gem_object *obj)
 {
	int ret;
@@ -443,7 +443,7 @@ static int vgdev_output_init(struct virtio_gpu_device *vgdev, int index)
	if (IS_ERR(plane))
		return PTR_ERR(plane);
	drm_crtc_init_with_planes(dev, crtc, plane, NULL,
-				  &virtio_gpu_crtc_funcs, NULL);
+				  &virtio_gpu_crtc_funcs);
	drm_mode_crtc_set_gamma_size(crtc, 256);
	drm_crtc_helper_add(crtc, &virtio_gpu_crtc_helper_funcs);
	plane->crtc = crtc;
@@ -453,7 +453,7 @@ static int vgdev_output_init(struct virtio_gpu_device *vgdev, int index)
	drm_connector_helper_add(connector, &virtio_gpu_conn_helper_funcs);

	drm_encoder_init(dev, encoder, &virtio_gpu_enc_funcs,
-			 DRM_MODE_ENCODER_VIRTUAL, NULL);
+			 DRM_MODE_ENCODER_VIRTUAL);
	drm_encoder_helper_add(encoder, &virtio_gpu_enc_helper_funcs);
	encoder->possible_crtcs = 1 << index;

@@ -465,7 +465,7 @@ static int vgdev_output_init(struct virtio_gpu_device *vgdev, int index)
 static struct drm_framebuffer *
 virtio_gpu_user_framebuffer_create(struct drm_device *dev,
				   struct drm_file *file_priv,
-				   const struct drm_mode_fb_cmd2 *mode_cmd)
+				   struct drm_mode_fb_cmd2 *mode_cmd)
 {
	struct drm_gem_object *obj = NULL;
	struct virtio_gpu_framebuffer *virtio_gpu_fb;
diff --git a/drivers/gpu/drm/virtio/virtgpu_drv.h b/drivers/gpu/drm/virtio/virtgpu_drv.h
index 8f486f4..79f0abe 100644
--- a/drivers/gpu/drm/virtio/virtgpu_drv.h
+++ b/drivers/gpu/drm/virtio/virtgpu_drv.h
@@ -328,7 +328,7 @@ void virtio_gpu_dequeue_fence_func(struct work_struct *work);
 /* virtio_gpu_display.c */
 int virtio_gpu_framebuffer_init(struct drm_device *dev,
				struct virtio_gpu_framebuffer *vgfb,
-				const struct drm_mode_fb_cmd2 *mode_cmd,
+				struct drm_mode_fb_cmd2 *mode_cmd,
				struct drm_gem_object *obj);
 int virtio_gpu_modeset_init(struct virtio_gpu_device *vgdev);
 void virtio_gpu_modeset_fini(struct virtio_gpu_device *vgdev);
diff --git a/drivers/gpu/drm/virtio/virtgpu_plane.c b/drivers/gpu/drm/virtio/virtgpu_plane.c
index 572fb35..4a74129 100644
--- a/drivers/gpu/drm/virtio/virtgpu_plane.c
+++ b/drivers/gpu/drm/virtio/virtgpu_plane.c
@@ -107,7 +107,7 @@ struct drm_plane *virtio_gpu_plane_init(struct virtio_gpu_device *vgdev,
				       &virtio_gpu_plane_funcs,
				       virtio_gpu_formats,
				       ARRAY_SIZE(virtio_gpu_formats),
-				       DRM_PLANE_TYPE_PRIMARY, NULL);
+				       DRM_PLANE_TYPE_PRIMARY);
	if (ret)
		goto err_plane_init;

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
index 10d1fb4..7c2e118 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
@@ -972,7 +972,7 @@ vmw_kms_new_framebuffer(struct vmw_private *dev_priv,

 static struct drm_framebuffer *vmw_kms_fb_create(struct drm_device *dev,
						 struct drm_file *file_priv,
-						 const struct drm_mode_fb_cmd2 *mode_cmd2)
+						 struct drm_mode_fb_cmd2 *mode_cmd2)
 {
	struct vmw_private *dev_priv = vmw_priv(dev);
	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c
index a51e8c1..52caecb 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_ldu.c
@@ -367,7 +367,7 @@ static int vmw_ldu_init(struct vmw_private *dev_priv, unsigned unit)
	connector->status = vmw_du_connector_detect(connector, true);

	drm_encoder_init(dev, encoder, &vmw_legacy_encoder_funcs,
-			 DRM_MODE_ENCODER_VIRTUAL, NULL);
+			 DRM_MODE_ENCODER_VIRTUAL);
	drm_mode_connector_attach_encoder(connector, encoder);
	encoder->possible_crtcs = (1 << unit);
	encoder->possible_clones = 0;
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c b/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c
index 6203909..13926ff 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_scrn.c
@@ -603,7 +603,7 @@ static int vmw_sou_init(struct vmw_private *dev_priv, unsigned unit)
	connector->status = vmw_du_connector_detect(connector, true);

	drm_encoder_init(dev, encoder, &vmw_screen_object_encoder_funcs,
-			 DRM_MODE_ENCODER_VIRTUAL, NULL);
+			 DRM_MODE_ENCODER_VIRTUAL);
	drm_mode_connector_attach_encoder(connector, encoder);
	encoder->possible_crtcs = (1 << unit);
	encoder->possible_clones = 0;
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
index 67a4a8a..f823fc3 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c
@@ -1149,7 +1149,7 @@ static int vmw_stdu_init(struct vmw_private *dev_priv, unsigned unit)
	connector->status = vmw_du_connector_detect(connector, false);

	drm_encoder_init(dev, encoder, &vmw_stdu_encoder_funcs,
-			 DRM_MODE_ENCODER_VIRTUAL, NULL);
+			 DRM_MODE_ENCODER_VIRTUAL);
	drm_mode_connector_attach_encoder(connector, encoder);
	encoder->possible_crtcs = (1 << unit);
	encoder->possible_clones = 0;
diff --git a/drivers/media/platform/vsp1/Makefile b/drivers/media/platform/vsp1/Makefile
index 95b3ac2..6a93f92 100644
--- a/drivers/media/platform/vsp1/Makefile
+++ b/drivers/media/platform/vsp1/Makefile
@@ -1,5 +1,4 @@
-vsp1-y					:= vsp1_drv.o vsp1_entity.o vsp1_pipe.o
-vsp1-y					+= vsp1_dl.o vsp1_drm.o vsp1_video.o
+vsp1-y					:= vsp1_drv.o vsp1_entity.o vsp1_video.o
 vsp1-y					+= vsp1_rpf.o vsp1_rwpf.o vsp1_wpf.o
 vsp1-y					+= vsp1_hsit.o vsp1_lif.o vsp1_lut.o
 vsp1-y					+= vsp1_bru.o vsp1_sru.o vsp1_uds.o
diff --git a/drivers/media/platform/vsp1/vsp1.h b/drivers/media/platform/vsp1/vsp1.h
index 910d6b8..989e96f 100644
--- a/drivers/media/platform/vsp1/vsp1.h
+++ b/drivers/media/platform/vsp1/vsp1.h
@@ -26,9 +26,6 @@
 struct clk;
 struct device;

-struct vsp1_dl;
-struct vsp1_drm;
-struct vsp1_entity;
 struct vsp1_platform_data;
 struct vsp1_bru;
 struct vsp1_hsit;
@@ -45,21 +42,17 @@ struct vsp1_uds;
 #define VSP1_HAS_LIF		(1 << 0)
 #define VSP1_HAS_LUT		(1 << 1)
 #define VSP1_HAS_SRU		(1 << 2)
-#define VSP1_HAS_BRU		(1 << 3)

-struct vsp1_device_info {
-	u32 version;
+struct vsp1_platform_data {
	unsigned int features;
	unsigned int rpf_count;
	unsigned int uds_count;
	unsigned int wpf_count;
-	unsigned int num_bru_inputs;
-	bool uapi;
 };

 struct vsp1_device {
	struct device *dev;
-	const struct vsp1_device_info *info;
+	struct vsp1_platform_data pdata;

	void __iomem *mmio;
	struct clk *clock;
@@ -78,22 +71,14 @@ struct vsp1_device {
	struct vsp1_rwpf *wpf[VSP1_MAX_WPF];

	struct list_head entities;
-	struct list_head videos;

	struct v4l2_device v4l2_dev;
	struct media_device media_dev;
-	struct media_entity_operations media_ops;
-
-	struct vsp1_drm *drm;
-
-	bool use_dl;
 };

 int vsp1_device_get(struct vsp1_device *vsp1);
 void vsp1_device_put(struct vsp1_device *vsp1);

-int vsp1_reset_wpf(struct vsp1_device *vsp1, unsigned int index);
-
 static inline u32 vsp1_read(struct vsp1_device *vsp1, u32 reg)
 {
	return ioread32(vsp1->mmio + reg);
@@ -104,14 +89,4 @@ static inline void vsp1_write(struct vsp1_device *vsp1, u32 reg, u32 data)
	iowrite32(data, vsp1->mmio + reg);
 }

-#include "vsp1_dl.h"
-
-static inline void vsp1_mod_write(struct vsp1_entity *e, u32 reg, u32 data)
-{
-	if (e->vsp1->use_dl)
-		vsp1_dl_add(e, reg, data);
-	else
-		vsp1_write(e->vsp1, reg, data);
-}
-
 #endif /* __VSP1_H__ */
diff --git a/drivers/media/platform/vsp1/vsp1_bru.c b/drivers/media/platform/vsp1/vsp1_bru.c
index cb0dbc1..7dd7633 100644
--- a/drivers/media/platform/vsp1/vsp1_bru.c
+++ b/drivers/media/platform/vsp1/vsp1_bru.c
@@ -19,7 +19,6 @@
 #include "vsp1.h"
 #include "vsp1_bru.h"
 #include "vsp1_rwpf.h"
-#include "vsp1_video.h"

 #define BRU_MIN_SIZE				1U
 #define BRU_MAX_SIZE				8190U
@@ -28,9 +27,14 @@
  * Device Access
  */

+static inline u32 vsp1_bru_read(struct vsp1_bru *bru, u32 reg)
+{
+	return vsp1_read(bru->entity.vsp1, reg);
+}
+
 static inline void vsp1_bru_write(struct vsp1_bru *bru, u32 reg, u32 data)
 {
-	vsp1_mod_write(&bru->entity, reg, data);
+	vsp1_write(bru->entity.vsp1, reg, data);
 }

 /* -----------------------------------------------------------------------------
@@ -79,7 +83,7 @@ static int bru_s_stream(struct v4l2_subdev *subdev, int enable)
	if (!enable)
		return 0;

-	format = &bru->entity.formats[bru->entity.source_pad];
+	format = &bru->entity.formats[BRU_PAD_SOURCE];

	/* The hardware is extremely flexible but we have no userspace API to
	 * expose all the parameters, nor is it clear whether we would have use
@@ -90,7 +94,7 @@ static int bru_s_stream(struct v4l2_subdev *subdev, int enable)
	/* Disable dithering and enable color data normalization unless the
	 * format at the pipeline output is premultiplied.
	 */
-	flags = pipe->output ? pipe->output->format.flags : 0;
+	flags = pipe->output ? pipe->output->video.format.flags : 0;
	vsp1_bru_write(bru, VI6_BRU_INCTRL,
		       flags & V4L2_PIX_FMT_FLAG_PREMUL_ALPHA ?
		       0 : VI6_BRU_INCTRL_NRM);
@@ -109,7 +113,7 @@ static int bru_s_stream(struct v4l2_subdev *subdev, int enable)
		       VI6_BRU_ROP_CROP(VI6_ROP_NOP) |
		       VI6_BRU_ROP_AROP(VI6_ROP_NOP));

-	for (i = 0; i < bru->entity.source_pad; ++i) {
+	for (i = 0; i < 4; ++i) {
		bool premultiplied = false;
		u32 ctrl = 0;

@@ -121,7 +125,7 @@ static int bru_s_stream(struct v4l2_subdev *subdev, int enable)
		if (bru->inputs[i].rpf) {
			ctrl |= VI6_BRU_CTRL_RBC;

-			premultiplied = bru->inputs[i].rpf->format.flags
+			premultiplied = bru->inputs[i].rpf->video.format.flags
				      & V4L2_PIX_FMT_FLAG_PREMUL_ALPHA;
		} else {
			ctrl |= VI6_BRU_CTRL_CROP(VI6_ROP_NOP)
@@ -291,7 +295,7 @@ static int bru_set_format(struct v4l2_subdev *subdev, struct v4l2_subdev_pad_con
	*format = fmt->format;

	/* Reset the compose rectangle */
-	if (fmt->pad != bru->entity.source_pad) {
+	if (fmt->pad != BRU_PAD_SOURCE) {
		struct v4l2_rect *compose;

		compose = bru_get_compose(bru, cfg, fmt->pad, fmt->which);
@@ -305,7 +309,7 @@ static int bru_set_format(struct v4l2_subdev *subdev, struct v4l2_subdev_pad_con
	if (fmt->pad == BRU_PAD_SINK(0)) {
		unsigned int i;

-		for (i = 0; i <= bru->entity.source_pad; ++i) {
+		for (i = 0; i <= BRU_PAD_SOURCE; ++i) {
			format = vsp1_entity_get_pad_format(&bru->entity, cfg,
							    i, fmt->which);
			format->code = fmt->format.code;
@@ -321,7 +325,7 @@ static int bru_get_selection(struct v4l2_subdev *subdev,
 {
	struct vsp1_bru *bru = to_bru(subdev);

-	if (sel->pad == bru->entity.source_pad)
+	if (sel->pad == BRU_PAD_SOURCE)
		return -EINVAL;

	switch (sel->target) {
@@ -349,7 +353,7 @@ static int bru_set_selection(struct v4l2_subdev *subdev,
	struct v4l2_mbus_framefmt *format;
	struct v4l2_rect *compose;

-	if (sel->pad == bru->entity.source_pad)
+	if (sel->pad == BRU_PAD_SOURCE)
		return -EINVAL;

	if (sel->target != V4L2_SEL_TGT_COMPOSE)
@@ -358,8 +362,8 @@ static int bru_set_selection(struct v4l2_subdev *subdev,
	/* The compose rectangle top left corner must be inside the output
	 * frame.
	 */
-	format = vsp1_entity_get_pad_format(&bru->entity, cfg,
-					    bru->entity.source_pad, sel->which);
+	format = vsp1_entity_get_pad_format(&bru->entity, cfg, BRU_PAD_SOURCE,
+					    sel->which);
	sel->r.left = clamp_t(unsigned int, sel->r.left, 0, format->width - 1);
	sel->r.top = clamp_t(unsigned int, sel->r.top, 0, format->height - 1);

@@ -415,8 +419,7 @@ struct vsp1_bru *vsp1_bru_create(struct vsp1_device *vsp1)

	bru->entity.type = VSP1_ENTITY_BRU;

-	ret = vsp1_entity_init(vsp1, &bru->entity,
-			       vsp1->info->num_bru_inputs + 1);
+	ret = vsp1_entity_init(vsp1, &bru->entity, 5);
	if (ret < 0)
		return ERR_PTR(ret);

@@ -424,7 +427,7 @@ struct vsp1_bru *vsp1_bru_create(struct vsp1_device *vsp1)
	subdev = &bru->entity.subdev;
	v4l2_subdev_init(subdev, &bru_ops);

-	subdev->entity.ops = &vsp1->media_ops;
+	subdev->entity.ops = &vsp1_media_ops;
	subdev->internal_ops = &vsp1_subdev_internal_ops;
	snprintf(subdev->name, sizeof(subdev->name), "%s bru",
		 dev_name(vsp1->dev));
diff --git a/drivers/media/platform/vsp1/vsp1_bru.h b/drivers/media/platform/vsp1/vsp1_bru.h
index dbac968..16b1c65 100644
--- a/drivers/media/platform/vsp1/vsp1_bru.h
+++ b/drivers/media/platform/vsp1/vsp1_bru.h
@@ -23,6 +23,7 @@ struct vsp1_device;
 struct vsp1_rwpf;

 #define BRU_PAD_SINK(n)				(n)
+#define BRU_PAD_SOURCE				4

 struct vsp1_bru {
	struct vsp1_entity entity;
@@ -32,7 +33,7 @@ struct vsp1_bru {
	struct {
		struct vsp1_rwpf *rpf;
		struct v4l2_rect compose;
-	} inputs[VSP1_MAX_RPF];
+	} inputs[4];
 };

 static inline struct vsp1_bru *to_bru(struct v4l2_subdev *subdev)
diff --git a/drivers/media/platform/vsp1/vsp1_dl.c b/drivers/media/platform/vsp1/vsp1_dl.c
deleted file mode 100644
index a4dcccf..0000000
--- a/drivers/media/platform/vsp1/vsp1_dl.c
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * vsp1_dl.h  --  R-Car VSP1 Display List
- *
- * Copyright (C) 2015 Renesas Corporation
- *
- * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <linux/device.h>
-#include <linux/dma-mapping.h>
-#include <linux/gfp.h>
-
-#include "vsp1.h"
-#include "vsp1_dl.h"
-#include "vsp1_pipe.h"
-
-/*
- * Global resources
- *
- * - Display-related interrupts (can be used for vblank evasion ?)
- * - Display-list enable
- * - Header-less for WPF0
- * - DL swap
- */
-
-#define VSP1_DL_BODY_SIZE		(2 * 4 * 256)
-#define VSP1_DL_NUM_LISTS		3
-
-struct vsp1_dl_entry {
-	u32 addr;
-	u32 data;
-} __attribute__((__packed__));
-
-struct vsp1_dl_list {
-	size_t size;
-	int reg_count;
-
-	bool in_use;
-
-	struct vsp1_dl_entry *body;
-	dma_addr_t dma;
-};
-
-/**
- * struct vsp1_dl - Display List manager
- * @vsp1: the VSP1 device
- * @lock: protects the active, queued and pending lists
- * @lists.all: array of all allocate display lists
- * @lists.active: list currently being processed (loaded) by hardware
- * @lists.queued: list queued to the hardware (written to the DL registers)
- * @lists.pending: list waiting to be queued to the hardware
- * @lists.write: list being written to by software
- */
-struct vsp1_dl {
-	struct vsp1_device *vsp1;
-
-	spinlock_t lock;
-
-	size_t size;
-	dma_addr_t dma;
-	void *mem;
-
-	struct {
-		struct vsp1_dl_list all[VSP1_DL_NUM_LISTS];
-
-		struct vsp1_dl_list *active;
-		struct vsp1_dl_list *queued;
-		struct vsp1_dl_list *pending;
-		struct vsp1_dl_list *write;
-	} lists;
-};
-
-/* -----------------------------------------------------------------------------
- * Display List Transaction Management
- */
-
-static void vsp1_dl_free_list(struct vsp1_dl_list *list)
-{
-	if (!list)
-		return;
-
-	list->in_use = false;
-}
-
-void vsp1_dl_reset(struct vsp1_dl *dl)
-{
-	unsigned int i;
-
-	dl->lists.active = NULL;
-	dl->lists.queued = NULL;
-	dl->lists.pending = NULL;
-	dl->lists.write = NULL;
-
-	for (i = 0; i < ARRAY_SIZE(dl->lists.all); ++i)
-		dl->lists.all[i].in_use = false;
-}
-
-void vsp1_dl_begin(struct vsp1_dl *dl)
-{
-	struct vsp1_dl_list *list = NULL;
-	unsigned long flags;
-	unsigned int i;
-
-	spin_lock_irqsave(&dl->lock, flags);
-
-	for (i = 0; i < ARRAY_SIZE(dl->lists.all); ++i) {
-		if (!dl->lists.all[i].in_use) {
-			list = &dl->lists.all[i];
-			break;
-		}
-	}
-
-	if (!list) {
-		list = dl->lists.pending;
-		dl->lists.pending = NULL;
-	}
-
-	spin_unlock_irqrestore(&dl->lock, flags);
-
-	dl->lists.write = list;
-
-	list->in_use = true;
-	list->reg_count = 0;
-}
-
-void vsp1_dl_add(struct vsp1_entity *e, u32 reg, u32 data)
-{
-	struct vsp1_pipeline *pipe = to_vsp1_pipeline(&e->subdev.entity);
-	struct vsp1_dl *dl = pipe->dl;
-	struct vsp1_dl_list *list = dl->lists.write;
-
-	list->body[list->reg_count].addr = reg;
-	list->body[list->reg_count].data = data;
-	list->reg_count++;
-}
-
-void vsp1_dl_commit(struct vsp1_dl *dl)
-{
-	struct vsp1_device *vsp1 = dl->vsp1;
-	struct vsp1_dl_list *list;
-	unsigned long flags;
-	bool update;
-
-	list = dl->lists.write;
-	dl->lists.write = NULL;
-
-	spin_lock_irqsave(&dl->lock, flags);
-
-	/* Once the UPD bit has been set the hardware can start processing the
-	 * display list at any time and we can't touch the address and size
-	 * registers. In that case mark the update as pending, it will be
-	 * queued up to the hardware by the frame end interrupt handler.
-	 */
-	update = !!(vsp1_read(vsp1, VI6_DL_BODY_SIZE) & VI6_DL_BODY_SIZE_UPD);
-	if (update) {
-		vsp1_dl_free_list(dl->lists.pending);
-		dl->lists.pending = list;
-		goto done;
-	}
-
-	/* Program the hardware with the display list body address and size.
-	 * The UPD bit will be cleared by the device when the display list is
-	 * processed.
-	 */
-	vsp1_write(vsp1, VI6_DL_HDR_ADDR(0), list->dma);
-	vsp1_write(vsp1, VI6_DL_BODY_SIZE, VI6_DL_BODY_SIZE_UPD |
-		   (list->reg_count * 8));
-
-	vsp1_dl_free_list(dl->lists.queued);
-	dl->lists.queued = list;
-
-done:
-	spin_unlock_irqrestore(&dl->lock, flags);
-}
-
-/* -----------------------------------------------------------------------------
- * Interrupt Handling
- */
-
-void vsp1_dl_irq_display_start(struct vsp1_dl *dl)
-{
-	spin_lock(&dl->lock);
-
-	/* The display start interrupt signals the end of the display list
-	 * processing by the device. The active display list, if any, won't be
-	 * accessed anymore and can be reused.
-	 */
-	if (dl->lists.active) {
-		vsp1_dl_free_list(dl->lists.active);
-		dl->lists.active = NULL;
-	}
-
-	spin_unlock(&dl->lock);
-}
-
-void vsp1_dl_irq_frame_end(struct vsp1_dl *dl)
-{
-	struct vsp1_device *vsp1 = dl->vsp1;
-
-	spin_lock(&dl->lock);
-
-	/* The UPD bit set indicates that the commit operation raced with the
-	 * interrupt and occurred after the frame end event and UPD clear but
-	 * before interrupt processing. The hardware hasn't taken the update
-	 * into account yet, we'll thus skip one frame and retry.
-	 */
-	if (vsp1_read(vsp1, VI6_DL_BODY_SIZE) & VI6_DL_BODY_SIZE_UPD)
-		goto done;
-
-	/* The device starts processing the queued display list right after the
-	 * frame end interrupt. The display list thus becomes active.
-	 */
-	if (dl->lists.queued) {
-		WARN_ON(dl->lists.active);
-		dl->lists.active = dl->lists.queued;
-		dl->lists.queued = NULL;
-	}
-
-	/* Now that the UPD bit has been cleared we can queue the next display
-	 * list to the hardware if one has been prepared.
-	 */
-	if (dl->lists.pending) {
-		struct vsp1_dl_list *list = dl->lists.pending;
-
-		vsp1_write(vsp1, VI6_DL_HDR_ADDR(0), list->dma);
-		vsp1_write(vsp1, VI6_DL_BODY_SIZE, VI6_DL_BODY_SIZE_UPD |
-			   (list->reg_count * 8));
-
-		dl->lists.queued = list;
-		dl->lists.pending = NULL;
-	}
-
-done:
-	spin_unlock(&dl->lock);
-}
-
-/* -----------------------------------------------------------------------------
- * Hardware Setup
- */
-
-void vsp1_dl_setup(struct vsp1_device *vsp1)
-{
-	u32 ctrl = (256 << VI6_DL_CTRL_AR_WAIT_SHIFT)
-		 | VI6_DL_CTRL_DC2 | VI6_DL_CTRL_DC1 | VI6_DL_CTRL_DC0
-		 | VI6_DL_CTRL_DLE;
-
-	/* The DRM pipeline operates with header-less display lists in
-	 * Continuous Frame Mode.
-	 */
-	if (vsp1->drm)
-		ctrl |= VI6_DL_CTRL_CFM0 | VI6_DL_CTRL_NH0;
-
-	vsp1_write(vsp1, VI6_DL_CTRL, ctrl);
-	vsp1_write(vsp1, VI6_DL_SWAP, VI6_DL_SWAP_LWS);
-}
-
-/* -----------------------------------------------------------------------------
- * Initialization and Cleanup
- */
-
-struct vsp1_dl *vsp1_dl_create(struct vsp1_device *vsp1)
-{
-	struct vsp1_dl *dl;
-	unsigned int i;
-
-	dl = kzalloc(sizeof(*dl), GFP_KERNEL);
-	if (!dl)
-		return NULL;
-
-	spin_lock_init(&dl->lock);
-
-	dl->vsp1 = vsp1;
-	dl->size = VSP1_DL_BODY_SIZE * ARRAY_SIZE(dl->lists.all);
-
-	dl->mem = dma_alloc_writecombine(vsp1->dev, dl->size, &dl->dma,
-					 GFP_KERNEL);
-	if (!dl->mem) {
-		kfree(dl);
-		return NULL;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(dl->lists.all); ++i) {
-		struct vsp1_dl_list *list = &dl->lists.all[i];
-
-		list->size = VSP1_DL_BODY_SIZE;
-		list->reg_count = 0;
-		list->in_use = false;
-		list->dma = dl->dma + VSP1_DL_BODY_SIZE * i;
-		list->body = dl->mem + VSP1_DL_BODY_SIZE * i;
-	}
-
-	return dl;
-}
-
-void vsp1_dl_destroy(struct vsp1_dl *dl)
-{
-	dma_free_writecombine(dl->vsp1->dev, dl->size, dl->mem, dl->dma);
-	kfree(dl);
-}
diff --git a/drivers/media/platform/vsp1/vsp1_dl.h b/drivers/media/platform/vsp1/vsp1_dl.h
deleted file mode 100644
index 448c425..0000000
--- a/drivers/media/platform/vsp1/vsp1_dl.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * vsp1_dl.h  --  R-Car VSP1 Display List
- *
- * Copyright (C) 2015 Renesas Corporation
- *
- * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-#ifndef __VSP1_DL_H__
-#define __VSP1_DL_H__
-
-#include "vsp1_entity.h"
-
-struct vsp1_device;
-struct vsp1_dl;
-
-struct vsp1_dl *vsp1_dl_create(struct vsp1_device *vsp1);
-void vsp1_dl_destroy(struct vsp1_dl *dl);
-
-void vsp1_dl_setup(struct vsp1_device *vsp1);
-
-void vsp1_dl_reset(struct vsp1_dl *dl);
-void vsp1_dl_begin(struct vsp1_dl *dl);
-void vsp1_dl_add(struct vsp1_entity *e, u32 reg, u32 data);
-void vsp1_dl_commit(struct vsp1_dl *dl);
-
-void vsp1_dl_irq_display_start(struct vsp1_dl *dl);
-void vsp1_dl_irq_frame_end(struct vsp1_dl *dl);
-
-static inline void vsp1_dl_mod_write(struct vsp1_entity *e, u32 reg, u32 data)
-{
-	if (e->vsp1->use_dl)
-		vsp1_dl_add(e, reg, data);
-	else
-		vsp1_write(e->vsp1, reg, data);
-}
-
-#endif /* __VSP1_DL_H__ */
diff --git a/drivers/media/platform/vsp1/vsp1_drm.c b/drivers/media/platform/vsp1/vsp1_drm.c
deleted file mode 100644
index 302d02a..0000000
--- a/drivers/media/platform/vsp1/vsp1_drm.c
+++ /dev/null
@@ -1,597 +0,0 @@
-/*
- * vsp1_drm.c  --  R-Car VSP1 DRM API
- *
- * Copyright (C) 2015 Renesas Electronics Corporation
- *
- * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <linux/device.h>
-#include <linux/slab.h>
-#include <linux/vsp1.h>
-
-#include <media/media-entity.h>
-#include <media/v4l2-subdev.h>
-
-#include "vsp1.h"
-#include "vsp1_bru.h"
-#include "vsp1_dl.h"
-#include "vsp1_drm.h"
-#include "vsp1_lif.h"
-#include "vsp1_pipe.h"
-#include "vsp1_rwpf.h"
-
-/* -----------------------------------------------------------------------------
- * Runtime Handling
- */
-
-static void vsp1_drm_pipeline_frame_end(struct vsp1_pipeline *pipe)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&pipe->irqlock, flags);
-	if (pipe->num_inputs)
-		vsp1_pipeline_run(pipe);
-	spin_unlock_irqrestore(&pipe->irqlock, flags);
-}
-
-/* -----------------------------------------------------------------------------
- * DU Driver API
- */
-
-int vsp1_du_init(struct device *dev)
-{
-	struct vsp1_device *vsp1 = dev_get_drvdata(dev);
-
-	if (!vsp1)
-		return -EPROBE_DEFER;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(vsp1_du_init);
-
-/**
- * vsp1_du_setup_lif - Setup the output part of the VSP pipeline
- * @dev: the VSP device
- * @width: output frame width in pixels
- * @height: output frame height in pixels
- *
- * Configure the output part of VSP DRM pipeline for the given frame @width and
- * @height. This sets up formats on the BRU source pad, the WPF0 sink and source
- * pads, and the LIF sink pad.
- *
- * As the media bus code on the BRU source pad is conditioned by the
- * configuration of the BRU sink 0 pad, we also set up the formats on all BRU
- * sinks, even if the configuration will be overwritten later by
- * vsp1_du_setup_rpf(). This ensures that the BRU configuration is set to a well
- * defined state.
- *
- * Return 0 on success or a negative error code on failure.
- */
-int vsp1_du_setup_lif(struct device *dev, unsigned int width,
-		      unsigned int height)
-{
-	struct vsp1_device *vsp1 = dev_get_drvdata(dev);
-	struct vsp1_pipeline *pipe = &vsp1->drm->pipe;
-	struct vsp1_bru *bru = vsp1->bru;
-	struct v4l2_subdev_format format;
-	unsigned int i;
-	int ret;
-
-	dev_dbg(vsp1->dev, "%s: configuring LIF with format %ux%u\n",
-		__func__, width, height);
-
-	if (width == 0 || height == 0) {
-		/* Zero width or height means the CRTC is being disabled, stop
-		 * the pipeline and turn the light off.
-		 */
-		ret = vsp1_pipeline_stop(pipe);
-		if (ret == -ETIMEDOUT)
-			dev_err(vsp1->dev, "DRM pipeline stop timeout\n");
-
-		media_entity_pipeline_stop(&pipe->output->entity.subdev.entity);
-
-		for (i = 0; i < bru->entity.source_pad; ++i) {
-			bru->inputs[i].rpf = NULL;
-			pipe->inputs[i] = NULL;
-		}
-
-		pipe->num_inputs = 0;
-
-		vsp1_device_put(vsp1);
-
-		dev_dbg(vsp1->dev, "%s: pipeline disabled\n", __func__);
-
-		return 0;
-	}
-
-	vsp1_dl_reset(vsp1->drm->dl);
-
-	/* Configure the format at the BRU sinks and propagate it through the
-	 * pipeline.
-	 */
-	memset(&format, 0, sizeof(format));
-	format.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-
-	for (i = 0; i < bru->entity.source_pad; ++i) {
-		format.pad = i;
-
-		format.format.width = width;
-		format.format.height = height;
-		format.format.code = MEDIA_BUS_FMT_ARGB8888_1X32;
-		format.format.field = V4L2_FIELD_NONE;
-
-		ret = v4l2_subdev_call(&bru->entity.subdev, pad,
-				       set_fmt, NULL, &format);
-		if (ret < 0)
-			return ret;
-
-		dev_dbg(vsp1->dev, "%s: set format %ux%u (%x) on BRU pad %u\n",
-			__func__, format.format.width, format.format.height,
-			format.format.code, i);
-	}
-
-	format.pad = bru->entity.source_pad;
-	format.format.width = width;
-	format.format.height = height;
-	format.format.code = MEDIA_BUS_FMT_ARGB8888_1X32;
-	format.format.field = V4L2_FIELD_NONE;
-
-	ret = v4l2_subdev_call(&bru->entity.subdev, pad, set_fmt, NULL,
-			       &format);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(vsp1->dev, "%s: set format %ux%u (%x) on BRU pad %u\n",
-		__func__, format.format.width, format.format.height,
-		format.format.code, i);
-
-	format.pad = RWPF_PAD_SINK;
-	ret = v4l2_subdev_call(&vsp1->wpf[0]->entity.subdev, pad, set_fmt, NULL,
-			       &format);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(vsp1->dev, "%s: set format %ux%u (%x) on WPF0 sink\n",
-		__func__, format.format.width, format.format.height,
-		format.format.code);
-
-	format.pad = RWPF_PAD_SOURCE;
-	ret = v4l2_subdev_call(&vsp1->wpf[0]->entity.subdev, pad, get_fmt, NULL,
-			       &format);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(vsp1->dev, "%s: got format %ux%u (%x) on WPF0 source\n",
-		__func__, format.format.width, format.format.height,
-		format.format.code);
-
-	format.pad = LIF_PAD_SINK;
-	ret = v4l2_subdev_call(&vsp1->lif->entity.subdev, pad, set_fmt, NULL,
-			       &format);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(vsp1->dev, "%s: set format %ux%u (%x) on LIF sink\n",
-		__func__, format.format.width, format.format.height,
-		format.format.code);
-
-	/* Verify that the format at the output of the pipeline matches the
-	 * requested frame size and media bus code.
-	 */
-	if (format.format.width != width || format.format.height != height ||
-	    format.format.code != MEDIA_BUS_FMT_ARGB8888_1X32) {
-		dev_dbg(vsp1->dev, "%s: format mismatch\n", __func__);
-		return -EPIPE;
-	}
-
-	/* Mark the pipeline as streaming and enable the VSP1. This will store
-	 * the pipeline pointer in all entities, which the s_stream handlers
-	 * will need. We don't start the entities themselves right at this point
-	 * as there's no plane configured yet, so we can't start processing
-	 * buffers.
-	 */
-	ret = vsp1_device_get(vsp1);
-	if (ret < 0)
-		return ret;
-
-	ret = media_entity_pipeline_start(&pipe->output->entity.subdev.entity,
-					  &pipe->pipe);
-	if (ret < 0) {
-		dev_dbg(vsp1->dev, "%s: pipeline start failed\n", __func__);
-		vsp1_device_put(vsp1);
-		return ret;
-	}
-
-	dev_dbg(vsp1->dev, "%s: pipeline enabled\n", __func__);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(vsp1_du_setup_lif);
-
-/**
- * vsp1_du_atomic_begin - Prepare for an atomic update
- * @dev: the VSP device
- */
-void vsp1_du_atomic_begin(struct device *dev)
-{
-	struct vsp1_device *vsp1 = dev_get_drvdata(dev);
-	struct vsp1_pipeline *pipe = &vsp1->drm->pipe;
-	unsigned long flags;
-
-	spin_lock_irqsave(&pipe->irqlock, flags);
-
-	vsp1->drm->num_inputs = pipe->num_inputs;
-
-	spin_unlock_irqrestore(&pipe->irqlock, flags);
-
-	/* Prepare the display list. */
-	vsp1_dl_begin(vsp1->drm->dl);
-}
-EXPORT_SYMBOL_GPL(vsp1_du_atomic_begin);
-
-/**
- * vsp1_du_atomic_update - Setup one RPF input of the VSP pipeline
- * @dev: the VSP device
- * @rpf_index: index of the RPF to setup (0-based)
- * @pixelformat: V4L2 pixel format for the RPF memory input
- * @pitch: number of bytes per line in the image stored in memory
- * @mem: DMA addresses of the memory buffers (one per plane)
- * @src: the source crop rectangle for the RPF
- * @dst: the destination compose rectangle for the BRU input
- *
- * Configure the VSP to perform composition of the image referenced by @mem
- * through RPF @rpf_index, using the @src crop rectangle and the @dst
- * composition rectangle. The Z-order is fixed with RPF 0 at the bottom.
- *
- * Image format as stored in memory is expressed as a V4L2 @pixelformat value.
- * As a special case, setting the pixel format to 0 will disable the RPF. The
- * @pitch, @mem, @src and @dst parameters are ignored in that case. Calling the
- * function on a disabled RPF is allowed.
- *
- * The memory pitch is configurable to allow for padding at end of lines, or
- * simple for images that extend beyond the crop rectangle boundaries. The
- * @pitch value is expressed in bytes and applies to all planes for multiplanar
- * formats.
- *
- * The source memory buffer is referenced by the DMA address of its planes in
- * the @mem array. Up to two planes are supported. The second plane DMA address
- * is ignored for formats using a single plane.
- *
- * This function isn't reentrant, the caller needs to serialize calls.
- *
- * TODO: Implement Z-order control by decoupling the RPF index from the BRU
- * input index.
- *
- * Return 0 on success or a negative error code on failure.
- */
-int vsp1_du_atomic_update(struct device *dev, unsigned int rpf_index,
-			  u32 pixelformat, unsigned int pitch,
-			  dma_addr_t mem[2], const struct v4l2_rect *src,
-			  const struct v4l2_rect *dst)
-{
-	struct vsp1_device *vsp1 = dev_get_drvdata(dev);
-	struct vsp1_pipeline *pipe = &vsp1->drm->pipe;
-	const struct vsp1_format_info *fmtinfo;
-	struct v4l2_subdev_selection sel;
-	struct v4l2_subdev_format format;
-	struct vsp1_rwpf_memory memory;
-	struct vsp1_rwpf *rpf;
-	unsigned long flags;
-	int ret;
-
-	if (rpf_index >= vsp1->info->rpf_count)
-		return -EINVAL;
-
-	rpf = vsp1->rpf[rpf_index];
-
-	if (pixelformat == 0) {
-		dev_dbg(vsp1->dev, "%s: RPF%u: disable requested\n", __func__,
-			rpf_index);
-
-		spin_lock_irqsave(&pipe->irqlock, flags);
-
-		if (pipe->inputs[rpf_index]) {
-			/* Remove the RPF from the pipeline if it was previously
-			 * enabled.
-			 */
-			vsp1->bru->inputs[rpf_index].rpf = NULL;
-			pipe->inputs[rpf_index] = NULL;
-
-			pipe->num_inputs--;
-		}
-
-		spin_unlock_irqrestore(&pipe->irqlock, flags);
-
-		return 0;
-	}
-
-	dev_dbg(vsp1->dev,
-		"%s: RPF%u: (%u,%u)/%ux%u -> (%u,%u)/%ux%u (%08x), pitch %u dma { %pad, %pad }\n",
-		__func__, rpf_index,
-		src->left, src->top, src->width, src->height,
-		dst->left, dst->top, dst->width, dst->height,
-		pixelformat, pitch, &mem[0], &mem[1]);
-
-	/* Set the stride at the RPF input. */
-	fmtinfo = vsp1_get_format_info(pixelformat);
-	if (!fmtinfo) {
-		dev_dbg(vsp1->dev, "Unsupport pixel format %08x for RPF\n",
-			pixelformat);
-		return -EINVAL;
-	}
-
-	rpf->fmtinfo = fmtinfo;
-	rpf->format.num_planes = fmtinfo->planes;
-	rpf->format.plane_fmt[0].bytesperline = pitch;
-	rpf->format.plane_fmt[1].bytesperline = pitch;
-
-	/* Configure the format on the RPF sink pad and propagate it up to the
-	 * BRU sink pad.
-	 */
-	memset(&format, 0, sizeof(format));
-	format.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	format.pad = RWPF_PAD_SINK;
-	format.format.width = src->width + src->left;
-	format.format.height = src->height + src->top;
-	format.format.code = fmtinfo->mbus;
-	format.format.field = V4L2_FIELD_NONE;
-
-	ret = v4l2_subdev_call(&rpf->entity.subdev, pad, set_fmt, NULL,
-			       &format);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(vsp1->dev,
-		"%s: set format %ux%u (%x) on RPF%u sink\n",
-		__func__, format.format.width, format.format.height,
-		format.format.code, rpf->entity.index);
-
-	memset(&sel, 0, sizeof(sel));
-	sel.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	sel.pad = RWPF_PAD_SINK;
-	sel.target = V4L2_SEL_TGT_CROP;
-	sel.r = *src;
-
-	ret = v4l2_subdev_call(&rpf->entity.subdev, pad, set_selection, NULL,
-			       &sel);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(vsp1->dev,
-		"%s: set selection (%u,%u)/%ux%u on RPF%u sink\n",
-		__func__, sel.r.left, sel.r.top, sel.r.width, sel.r.height,
-		rpf->entity.index);
-
-	/* RPF source, hardcode the format to ARGB8888 to turn on format
-	 * conversion if needed.
-	 */
-	format.pad = RWPF_PAD_SOURCE;
-
-	ret = v4l2_subdev_call(&rpf->entity.subdev, pad, get_fmt, NULL,
-			       &format);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(vsp1->dev,
-		"%s: got format %ux%u (%x) on RPF%u source\n",
-		__func__, format.format.width, format.format.height,
-		format.format.code, rpf->entity.index);
-
-	format.format.code = MEDIA_BUS_FMT_ARGB8888_1X32;
-
-	ret = v4l2_subdev_call(&rpf->entity.subdev, pad, set_fmt, NULL,
-			       &format);
-	if (ret < 0)
-		return ret;
-
-	/* BRU sink, propagate the format from the RPF source. */
-	format.pad = rpf->entity.index;
-
-	ret = v4l2_subdev_call(&vsp1->bru->entity.subdev, pad, set_fmt, NULL,
-			       &format);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(vsp1->dev, "%s: set format %ux%u (%x) on BRU pad %u\n",
-		__func__, format.format.width, format.format.height,
-		format.format.code, format.pad);
-
-	sel.pad = rpf->entity.index;
-	sel.target = V4L2_SEL_TGT_COMPOSE;
-	sel.r = *dst;
-
-	ret = v4l2_subdev_call(&vsp1->bru->entity.subdev, pad, set_selection,
-			       NULL, &sel);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(vsp1->dev,
-		"%s: set selection (%u,%u)/%ux%u on BRU pad %u\n",
-		__func__, sel.r.left, sel.r.top, sel.r.width, sel.r.height,
-		sel.pad);
-
-	/* Store the compose rectangle coordinates in the RPF. */
-	rpf->location.left = dst->left;
-	rpf->location.top = dst->top;
-
-	/* Set the memory buffer address. */
-	memory.num_planes = fmtinfo->planes;
-	memory.addr[0] = mem[0];
-	memory.addr[1] = mem[1];
-
-	rpf->ops->set_memory(rpf, &memory);
-
-	spin_lock_irqsave(&pipe->irqlock, flags);
-
-	/* If the RPF was previously stopped set the BRU input to the RPF and
-	 * store the RPF in the pipeline inputs array.
-	 */
-	if (!pipe->inputs[rpf->entity.index]) {
-		vsp1->bru->inputs[rpf_index].rpf = rpf;
-		pipe->inputs[rpf->entity.index] = rpf;
-		pipe->num_inputs++;
-	}
-
-	spin_unlock_irqrestore(&pipe->irqlock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(vsp1_du_atomic_update);
-
-/**
- * vsp1_du_atomic_flush - Commit an atomic update
- * @dev: the VSP device
- */
-void vsp1_du_atomic_flush(struct device *dev)
-{
-	struct vsp1_device *vsp1 = dev_get_drvdata(dev);
-	struct vsp1_pipeline *pipe = &vsp1->drm->pipe;
-	struct vsp1_entity *entity;
-	unsigned long flags;
-	bool stop = false;
-	int ret;
-
-	list_for_each_entry(entity, &pipe->entities, list_pipe) {
-		/* Disconnect unused RPFs from the pipeline. */
-		if (entity->type == VSP1_ENTITY_RPF) {
-			struct vsp1_rwpf *rpf = to_rwpf(&entity->subdev);
-
-			if (!pipe->inputs[rpf->entity.index]) {
-				vsp1_mod_write(entity, entity->route->reg,
-					   VI6_DPR_NODE_UNUSED);
-				continue;
-			}
-		}
-
-		vsp1_entity_route_setup(entity);
-
-		ret = v4l2_subdev_call(&entity->subdev, video,
-				       s_stream, 1);
-		if (ret < 0) {
-			dev_err(vsp1->dev,
-				"DRM pipeline start failure on entity %s\n",
-				entity->subdev.name);
-			return;
-		}
-	}
-
-	vsp1_dl_commit(vsp1->drm->dl);
-
-	spin_lock_irqsave(&pipe->irqlock, flags);
-
-	/* Start or stop the pipeline if needed. */
-	if (!vsp1->drm->num_inputs && pipe->num_inputs) {
-		vsp1_write(vsp1, VI6_DISP_IRQ_STA, 0);
-		vsp1_write(vsp1, VI6_DISP_IRQ_ENB, VI6_DISP_IRQ_ENB_DSTE);
-		vsp1_pipeline_run(pipe);
-	} else if (vsp1->drm->num_inputs && !pipe->num_inputs) {
-		stop = true;
-	}
-
-	spin_unlock_irqrestore(&pipe->irqlock, flags);
-
-	if (stop) {
-		vsp1_write(vsp1, VI6_DISP_IRQ_ENB, 0);
-		vsp1_pipeline_stop(pipe);
-	}
-}
-EXPORT_SYMBOL_GPL(vsp1_du_atomic_flush);
-
-/* -----------------------------------------------------------------------------
- * Initialization
- */
-
-int vsp1_drm_create_links(struct vsp1_device *vsp1)
-{
-	const u32 flags = MEDIA_LNK_FL_ENABLED | MEDIA_LNK_FL_IMMUTABLE;
-	unsigned int i;
-	int ret;
-
-	/* VSPD instances require a BRU to perform composition and a LIF to
-	 * output to the DU.
-	 */
-	if (!vsp1->bru || !vsp1->lif)
-		return -ENXIO;
-
-	for (i = 0; i < vsp1->info->rpf_count; ++i) {
-		struct vsp1_rwpf *rpf = vsp1->rpf[i];
-
-		ret = media_entity_create_link(&rpf->entity.subdev.entity,
-					       RWPF_PAD_SOURCE,
-					       &vsp1->bru->entity.subdev.entity,
-					       i, flags);
-		if (ret < 0)
-			return ret;
-
-		rpf->entity.sink = &vsp1->bru->entity.subdev.entity;
-		rpf->entity.sink_pad = i;
-	}
-
-	ret = media_entity_create_link(&vsp1->bru->entity.subdev.entity,
-				       vsp1->bru->entity.source_pad,
-				       &vsp1->wpf[0]->entity.subdev.entity,
-				       RWPF_PAD_SINK, flags);
-	if (ret < 0)
-		return ret;
-
-	vsp1->bru->entity.sink = &vsp1->wpf[0]->entity.subdev.entity;
-	vsp1->bru->entity.sink_pad = RWPF_PAD_SINK;
-
-	ret = media_entity_create_link(&vsp1->wpf[0]->entity.subdev.entity,
-				       RWPF_PAD_SOURCE,
-				       &vsp1->lif->entity.subdev.entity,
-				       LIF_PAD_SINK, flags);
-	if (ret < 0)
-		return ret;
-
-	return 0;
-}
-
-int vsp1_drm_init(struct vsp1_device *vsp1)
-{
-	struct vsp1_pipeline *pipe;
-	unsigned int i;
-
-	vsp1->drm = devm_kzalloc(vsp1->dev, sizeof(*vsp1->drm), GFP_KERNEL);
-	if (!vsp1->drm)
-		return -ENOMEM;
-
-	vsp1->drm->dl = vsp1_dl_create(vsp1);
-	if (!vsp1->drm->dl)
-		return -ENOMEM;
-
-	pipe = &vsp1->drm->pipe;
-
-	vsp1_pipeline_init(pipe);
-	pipe->frame_end = vsp1_drm_pipeline_frame_end;
-
-	/* The DRM pipeline is static, add entities manually. */
-	for (i = 0; i < vsp1->info->rpf_count; ++i) {
-		struct vsp1_rwpf *input = vsp1->rpf[i];
-
-		list_add_tail(&input->entity.list_pipe, &pipe->entities);
-	}
-
-	list_add_tail(&vsp1->bru->entity.list_pipe, &pipe->entities);
-	list_add_tail(&vsp1->wpf[0]->entity.list_pipe, &pipe->entities);
-	list_add_tail(&vsp1->lif->entity.list_pipe, &pipe->entities);
-
-	pipe->bru = &vsp1->bru->entity;
-	pipe->lif = &vsp1->lif->entity;
-	pipe->output = vsp1->wpf[0];
-
-	pipe->dl = vsp1->drm->dl;
-
-	return 0;
-}
-
-void vsp1_drm_cleanup(struct vsp1_device *vsp1)
-{
-	vsp1_dl_destroy(vsp1->drm->dl);
-}
diff --git a/drivers/media/platform/vsp1/vsp1_drm.h b/drivers/media/platform/vsp1/vsp1_drm.h
deleted file mode 100644
index 7704038..0000000
--- a/drivers/media/platform/vsp1/vsp1_drm.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * vsp1_drm.h  --  R-Car VSP1 DRM/KMS Interface
- *
- * Copyright (C) 2015 Renesas Electronics Corporation
- *
- * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-#ifndef __VSP1_DRM_H__
-#define __VSP1_DRM_H__
-
-#include "vsp1_pipe.h"
-
-struct vsp1_dl;
-
-/**
- * vsp1_drm - State for the API exposed to the DRM driver
- * @dl: display list for DRM pipeline operation
- * @pipe: the VSP1 pipeline used for display
- * @num_inputs: number of active pipeline inputs at the beginning of an update
- * @update: the pipeline configuration has been updated
- */
-struct vsp1_drm {
-	struct vsp1_dl *dl;
-	struct vsp1_pipeline pipe;
-	unsigned int num_inputs;
-	bool update;
-};
-
-int vsp1_drm_init(struct vsp1_device *vsp1);
-void vsp1_drm_cleanup(struct vsp1_device *vsp1);
-int vsp1_drm_create_links(struct vsp1_device *vsp1);
-
-#endif /* __VSP1_DRM_H__ */
diff --git a/drivers/media/platform/vsp1/vsp1_drv.c b/drivers/media/platform/vsp1/vsp1_drv.c
index ea37c78..4e61886 100644
--- a/drivers/media/platform/vsp1/vsp1_drv.c
+++ b/drivers/media/platform/vsp1/vsp1_drv.c
@@ -17,23 +17,17 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/of.h>
-#include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/videodev2.h>

-#include <media/v4l2-subdev.h>
-
 #include "vsp1.h"
 #include "vsp1_bru.h"
-#include "vsp1_dl.h"
-#include "vsp1_drm.h"
 #include "vsp1_hsit.h"
 #include "vsp1_lif.h"
 #include "vsp1_lut.h"
 #include "vsp1_rwpf.h"
 #include "vsp1_sru.h"
 #include "vsp1_uds.h"
-#include "vsp1_video.h"

 /* -----------------------------------------------------------------------------
  * Interrupt Handling
@@ -45,11 +39,11 @@ static irqreturn_t vsp1_irq_handler(int irq, void *data)
	struct vsp1_device *vsp1 = data;
	irqreturn_t ret = IRQ_NONE;
	unsigned int i;
-	u32 status;

-	for (i = 0; i < vsp1->info->wpf_count; ++i) {
+	for (i = 0; i < vsp1->pdata.wpf_count; ++i) {
		struct vsp1_rwpf *wpf = vsp1->wpf[i];
		struct vsp1_pipeline *pipe;
+		u32 status;

		if (wpf == NULL)
			continue;
@@ -64,21 +58,6 @@ static irqreturn_t vsp1_irq_handler(int irq, void *data)
		}
	}

-	status = vsp1_read(vsp1, VI6_DISP_IRQ_STA);
-	vsp1_write(vsp1, VI6_DISP_IRQ_STA, ~status & VI6_DISP_IRQ_STA_DST);
-
-	if (status & VI6_DISP_IRQ_STA_DST) {
-		struct vsp1_rwpf *wpf = vsp1->wpf[0];
-		struct vsp1_pipeline *pipe;
-
-		if (wpf) {
-			pipe = to_vsp1_pipeline(&wpf->entity.subdev.entity);
-			vsp1_pipeline_display_start(pipe);
-		}
-
-		ret = IRQ_HANDLED;
-	}
-
	return ret;
 }

@@ -87,7 +66,7 @@ static irqreturn_t vsp1_irq_handler(int irq, void *data)
  */

 /*
- * vsp1_create_sink_links - Create links from all sources to the given sink
+ * vsp1_create_links - Create links from all sources to the given sink
  *
  * This function creates media links from all valid sources to the given sink
  * pad. Links that would be invalid according to the VSP1 hardware capabilities
@@ -96,8 +75,7 @@ static irqreturn_t vsp1_irq_handler(int irq, void *data)
  * - from a UDS to a UDS (UDS entities can't be chained)
  * - from an entity to itself (no loops are allowed)
  */
-static int vsp1_create_sink_links(struct vsp1_device *vsp1,
-				  struct vsp1_entity *sink)
+static int vsp1_create_links(struct vsp1_device *vsp1, struct vsp1_entity *sink)
 {
	struct media_entity *entity = &sink->subdev.entity;
	struct vsp1_entity *source;
@@ -137,85 +115,18 @@ static int vsp1_create_sink_links(struct vsp1_device *vsp1,
	return 0;
 }

-static int vsp1_uapi_create_links(struct vsp1_device *vsp1)
-{
-	struct vsp1_entity *entity;
-	unsigned int i;
-	int ret;
-
-	list_for_each_entry(entity, &vsp1->entities, list_dev) {
-		if (entity->type == VSP1_ENTITY_LIF ||
-		    entity->type == VSP1_ENTITY_RPF)
-			continue;
-
-		ret = vsp1_create_sink_links(vsp1, entity);
-		if (ret < 0)
-			return ret;
-	}
-
-	if (vsp1->info->features & VSP1_HAS_LIF) {
-		ret = media_entity_create_link(
-			&vsp1->wpf[0]->entity.subdev.entity, RWPF_PAD_SOURCE,
-			&vsp1->lif->entity.subdev.entity, LIF_PAD_SINK, 0);
-		if (ret < 0)
-			return ret;
-	}
-
-	for (i = 0; i < vsp1->info->rpf_count; ++i) {
-		struct vsp1_rwpf *rpf = vsp1->rpf[i];
-
-		ret = media_entity_create_link(&rpf->video->video.entity, 0,
-					       &rpf->entity.subdev.entity,
-					       RWPF_PAD_SINK,
-					       MEDIA_LNK_FL_ENABLED |
-					       MEDIA_LNK_FL_IMMUTABLE);
-		if (ret < 0)
-			return ret;
-	}
-
-	for (i = 0; i < vsp1->info->wpf_count; ++i) {
-		/* Connect the video device to the WPF. All connections are
-		 * immutable except for the WPF0 source link if a LIF is
-		 * present.
-		 */
-		struct vsp1_rwpf *wpf = vsp1->wpf[i];
-		unsigned int flags = MEDIA_LNK_FL_ENABLED;
-
-		if (!(vsp1->info->features & VSP1_HAS_LIF) || i != 0)
-			flags |= MEDIA_LNK_FL_IMMUTABLE;
-
-		ret = media_entity_create_link(&wpf->entity.subdev.entity,
-					       RWPF_PAD_SOURCE,
-					       &wpf->video->video.entity,
-					       0, flags);
-		if (ret < 0)
-			return ret;
-	}
-
-	return 0;
-}
-
 static void vsp1_destroy_entities(struct vsp1_device *vsp1)
 {
-	struct vsp1_entity *entity, *_entity;
-	struct vsp1_video *video, *_video;
+	struct vsp1_entity *entity;
+	struct vsp1_entity *next;

-	list_for_each_entry_safe(entity, _entity, &vsp1->entities, list_dev) {
+	list_for_each_entry_safe(entity, next, &vsp1->entities, list_dev) {
		list_del(&entity->list_dev);
		vsp1_entity_destroy(entity);
	}

-	list_for_each_entry_safe(video, _video, &vsp1->videos, list) {
-		list_del(&video->list);
-		vsp1_video_cleanup(video);
-	}
-
	v4l2_device_unregister(&vsp1->v4l2_dev);
-	if (!vsp1->info->uapi)
-		media_device_unregister(&vsp1->media_dev);
-
-	if (!vsp1->info->uapi)
-		vsp1_drm_cleanup(vsp1);
+	media_device_unregister(&vsp1->media_dev);
 }

 static int vsp1_create_entities(struct vsp1_device *vsp1)
@@ -230,27 +141,12 @@ static int vsp1_create_entities(struct vsp1_device *vsp1)
	strlcpy(mdev->model, "VSP1", sizeof(mdev->model));
	snprintf(mdev->bus_info, sizeof(mdev->bus_info), "platform:%s",
		 dev_name(mdev->dev));
-
-	if (!vsp1->info->uapi) {
-		mdev->entity_id = 1;
-		INIT_LIST_HEAD(&mdev->entities);
-		spin_lock_init(&mdev->lock);
-		mutex_init(&mdev->graph_mutex);
-	} else {
-		ret = media_device_register(mdev);
-		if (ret < 0) {
-			dev_err(vsp1->dev, "media device registration failed (%d)\n",
-				ret);
-			return ret;
-		}
+	ret = media_device_register(mdev);
+	if (ret < 0) {
+		dev_err(vsp1->dev, "media device registration failed (%d)\n",
+			ret);
+		return ret;
	}
-	vsp1->media_ops.link_setup = vsp1_entity_link_setup;
-	/* Don't perform link validation when the userspace API is disabled as
-	 * the pipeline is configured internally by the driver in that case, and
-	 * its configuration can thus be trusted.
-	 */
-	if (vsp1->info->uapi)
-		vsp1->media_ops.link_validate = v4l2_subdev_link_validate;

	vdev->mdev = mdev;
	ret = v4l2_device_register(vsp1->dev, vdev);
@@ -261,16 +157,14 @@ static int vsp1_create_entities(struct vsp1_device *vsp1)
	}

	/* Instantiate all the entities. */
-	if (vsp1->info->features & VSP1_HAS_BRU) {
-		vsp1->bru = vsp1_bru_create(vsp1);
-		if (IS_ERR(vsp1->bru)) {
-			ret = PTR_ERR(vsp1->bru);
-			goto done;
-		}
-
-		list_add_tail(&vsp1->bru->entity.list_dev, &vsp1->entities);
+	vsp1->bru = vsp1_bru_create(vsp1);
+	if (IS_ERR(vsp1->bru)) {
+		ret = PTR_ERR(vsp1->bru);
+		goto done;
	}

+	list_add_tail(&vsp1->bru->entity.list_dev, &vsp1->entities);
+
	vsp1->hsi = vsp1_hsit_create(vsp1, true);
	if (IS_ERR(vsp1->hsi)) {
		ret = PTR_ERR(vsp1->hsi);
@@ -287,7 +181,7 @@ static int vsp1_create_entities(struct vsp1_device *vsp1)

	list_add_tail(&vsp1->hst->entity.list_dev, &vsp1->entities);

-	if (vsp1->info->features & VSP1_HAS_LIF) {
+	if (vsp1->pdata.features & VSP1_HAS_LIF) {
		vsp1->lif = vsp1_lif_create(vsp1);
		if (IS_ERR(vsp1->lif)) {
			ret = PTR_ERR(vsp1->lif);
@@ -297,7 +191,7 @@ static int vsp1_create_entities(struct vsp1_device *vsp1)
		list_add_tail(&vsp1->lif->entity.list_dev, &vsp1->entities);
	}

-	if (vsp1->info->features & VSP1_HAS_LUT) {
+	if (vsp1->pdata.features & VSP1_HAS_LUT) {
		vsp1->lut = vsp1_lut_create(vsp1);
		if (IS_ERR(vsp1->lut)) {
			ret = PTR_ERR(vsp1->lut);
@@ -307,7 +201,7 @@ static int vsp1_create_entities(struct vsp1_device *vsp1)
		list_add_tail(&vsp1->lut->entity.list_dev, &vsp1->entities);
	}

-	for (i = 0; i < vsp1->info->rpf_count; ++i) {
+	for (i = 0; i < vsp1->pdata.rpf_count; ++i) {
		struct vsp1_rwpf *rpf;

		rpf = vsp1_rpf_create(vsp1, i);
@@ -318,20 +212,9 @@ static int vsp1_create_entities(struct vsp1_device *vsp1)

		vsp1->rpf[i] = rpf;
		list_add_tail(&rpf->entity.list_dev, &vsp1->entities);
-
-		if (vsp1->info->uapi) {
-			struct vsp1_video *video = vsp1_video_create(vsp1, rpf);
-
-			if (IS_ERR(video)) {
-				ret = PTR_ERR(video);
-				goto done;
-			}
-
-			list_add_tail(&video->list, &vsp1->videos);
-		}
	}

-	if (vsp1->info->features & VSP1_HAS_SRU) {
+	if (vsp1->pdata.features & VSP1_HAS_SRU) {
		vsp1->sru = vsp1_sru_create(vsp1);
		if (IS_ERR(vsp1->sru)) {
			ret = PTR_ERR(vsp1->sru);
@@ -341,7 +224,7 @@ static int vsp1_create_entities(struct vsp1_device *vsp1)
		list_add_tail(&vsp1->sru->entity.list_dev, &vsp1->entities);
	}

-	for (i = 0; i < vsp1->info->uds_count; ++i) {
+	for (i = 0; i < vsp1->pdata.uds_count; ++i) {
		struct vsp1_uds *uds;

		uds = vsp1_uds_create(vsp1, i);
@@ -354,7 +237,7 @@ static int vsp1_create_entities(struct vsp1_device *vsp1)
		list_add_tail(&uds->entity.list_dev, &vsp1->entities);
	}

-	for (i = 0; i < vsp1->info->wpf_count; ++i) {
+	for (i = 0; i < vsp1->pdata.wpf_count; ++i) {
		struct vsp1_rwpf *wpf;

		wpf = vsp1_wpf_create(vsp1, i);
@@ -365,27 +248,26 @@ static int vsp1_create_entities(struct vsp1_device *vsp1)

		vsp1->wpf[i] = wpf;
		list_add_tail(&wpf->entity.list_dev, &vsp1->entities);
+	}

-		if (vsp1->info->uapi) {
-			struct vsp1_video *video = vsp1_video_create(vsp1, wpf);
-
-			if (IS_ERR(video)) {
-				ret = PTR_ERR(video);
-				goto done;
-			}
+	/* Create links. */
+	list_for_each_entry(entity, &vsp1->entities, list_dev) {
+		if (entity->type == VSP1_ENTITY_LIF ||
+		    entity->type == VSP1_ENTITY_RPF)
+			continue;

-			list_add_tail(&video->list, &vsp1->videos);
-			wpf->entity.sink = &video->video.entity;
-		}
+		ret = vsp1_create_links(vsp1, entity);
+		if (ret < 0)
+			goto done;
	}

-	/* Create links. */
-	if (vsp1->info->uapi)
-		ret = vsp1_uapi_create_links(vsp1);
-	else
-		ret = vsp1_drm_create_links(vsp1);
-	if (ret < 0)
-		goto done;
+	if (vsp1->pdata.features & VSP1_HAS_LIF) {
+		ret = media_entity_create_link(
+			&vsp1->wpf[0]->entity.subdev.entity, RWPF_PAD_SOURCE,
+			&vsp1->lif->entity.subdev.entity, LIF_PAD_SINK, 0);
+		if (ret < 0)
+			return ret;
+	}

	/* Register all subdevs. */
	list_for_each_entry(entity, &vsp1->entities, list_dev) {
@@ -395,13 +277,7 @@ static int vsp1_create_entities(struct vsp1_device *vsp1)
			goto done;
	}

-	if (vsp1->info->uapi) {
-		vsp1->use_dl = false;
-		ret = v4l2_device_register_subdev_nodes(&vsp1->v4l2_dev);
-	} else {
-		vsp1->use_dl = true;
-		ret = vsp1_drm_init(vsp1);
-	}
+	ret = v4l2_device_register_subdev_nodes(&vsp1->v4l2_dev);

 done:
	if (ret < 0)
@@ -410,51 +286,42 @@ done:
	return ret;
 }

-int vsp1_reset_wpf(struct vsp1_device *vsp1, unsigned int index)
+static int vsp1_device_init(struct vsp1_device *vsp1)
 {
-	unsigned int timeout;
+	unsigned int i;
	u32 status;

+	/* Reset any channel that might be running. */
	status = vsp1_read(vsp1, VI6_STATUS);
-	if (!(status & VI6_STATUS_SYS_ACT(index)))
-		return 0;

-	vsp1_write(vsp1, VI6_SRESET, VI6_SRESET_SRTS(index));
-	for (timeout = 10; timeout > 0; --timeout) {
-		status = vsp1_read(vsp1, VI6_STATUS);
-		if (!(status & VI6_STATUS_SYS_ACT(index)))
-			break;
+	for (i = 0; i < vsp1->pdata.wpf_count; ++i) {
+		unsigned int timeout;

-		usleep_range(1000, 2000);
-	}
+		if (!(status & VI6_STATUS_SYS_ACT(i)))
+			continue;

-	if (!timeout) {
-		dev_err(vsp1->dev, "failed to reset wpf.%u\n", index);
-		return -ETIMEDOUT;
-	}
+		vsp1_write(vsp1, VI6_SRESET, VI6_SRESET_SRTS(i));
+		for (timeout = 10; timeout > 0; --timeout) {
+			status = vsp1_read(vsp1, VI6_STATUS);
+			if (!(status & VI6_STATUS_SYS_ACT(i)))
+				break;

-	return 0;
-}
-
-static int vsp1_device_init(struct vsp1_device *vsp1)
-{
-	unsigned int i;
-	int ret;
+			usleep_range(1000, 2000);
+		}

-	/* Reset any channel that might be running. */
-	for (i = 0; i < vsp1->info->wpf_count; ++i) {
-		ret = vsp1_reset_wpf(vsp1, i);
-		if (ret < 0)
-			return ret;
+		if (!timeout) {
+			dev_err(vsp1->dev, "failed to reset wpf.%u\n", i);
+			return -ETIMEDOUT;
+		}
	}

	vsp1_write(vsp1, VI6_CLK_DCSWT, (8 << VI6_CLK_DCSWT_CSTPW_SHIFT) |
		   (8 << VI6_CLK_DCSWT_CSTRW_SHIFT));

-	for (i = 0; i < vsp1->info->rpf_count; ++i)
+	for (i = 0; i < vsp1->pdata.rpf_count; ++i)
		vsp1_write(vsp1, VI6_DPR_RPF_ROUTE(i), VI6_DPR_NODE_UNUSED);

-	for (i = 0; i < vsp1->info->uds_count; ++i)
+	for (i = 0; i < vsp1->pdata.uds_count; ++i)
		vsp1_write(vsp1, VI6_DPR_UDS_ROUTE(i), VI6_DPR_NODE_UNUSED);

	vsp1_write(vsp1, VI6_DPR_SRU_ROUTE, VI6_DPR_NODE_UNUSED);
@@ -469,9 +336,6 @@ static int vsp1_device_init(struct vsp1_device *vsp1)
	vsp1_write(vsp1, VI6_DPR_HGT_SMPPT, (7 << VI6_DPR_SMPPT_TGW_SHIFT) |
		   (VI6_DPR_NODE_UNUSED << VI6_DPR_SMPPT_PT_SHIFT));

-	if (vsp1->use_dl)
-		vsp1_dl_setup(vsp1);
-
	return 0;
 }

@@ -571,76 +435,48 @@ static const struct dev_pm_ops vsp1_pm_ops = {
  * Platform Driver
  */

-static const struct vsp1_device_info vsp1_device_infos[] = {
-	{
-		.version = VI6_IP_VERSION_MODEL_VSPS_H2,
-		.features = VSP1_HAS_BRU | VSP1_HAS_LUT | VSP1_HAS_SRU,
-		.rpf_count = 5,
-		.uds_count = 3,
-		.wpf_count = 4,
-		.num_bru_inputs = 4,
-		.uapi = true,
-	}, {
-		.version = VI6_IP_VERSION_MODEL_VSPR_H2,
-		.features = VSP1_HAS_BRU | VSP1_HAS_SRU,
-		.rpf_count = 5,
-		.uds_count = 3,
-		.wpf_count = 4,
-		.num_bru_inputs = 4,
-		.uapi = true,
-	}, {
-		.version = VI6_IP_VERSION_MODEL_VSPD_GEN2,
-		.features = VSP1_HAS_BRU | VSP1_HAS_LIF | VSP1_HAS_LUT,
-		.rpf_count = 4,
-		.uds_count = 1,
-		.wpf_count = 1,
-		.num_bru_inputs = 4,
-		.uapi = false,
-	}, {
-		.version = VI6_IP_VERSION_MODEL_VSPS_M2,
-		.features = VSP1_HAS_BRU | VSP1_HAS_LUT | VSP1_HAS_SRU,
-		.rpf_count = 5,
-		.uds_count = 1,
-		.wpf_count = 4,
-		.num_bru_inputs = 4,
-		.uapi = true,
-	}, {
-		.version = VI6_IP_VERSION_MODEL_VSPI_GEN3,
-		.features = VSP1_HAS_LUT | VSP1_HAS_SRU,
-		.rpf_count = 1,
-		.uds_count = 1,
-		.wpf_count = 1,
-		.uapi = true,
-	}, {
-		.version = VI6_IP_VERSION_MODEL_VSPBD_GEN3,
-		.features = VSP1_HAS_BRU,
-		.rpf_count = 5,
-		.wpf_count = 1,
-		.num_bru_inputs = 5,
-		.uapi = true,
-	}, {
-		.version = VI6_IP_VERSION_MODEL_VSPBC_GEN3,
-		.features = VSP1_HAS_BRU | VSP1_HAS_LUT,
-		.rpf_count = 5,
-		.wpf_count = 1,
-		.num_bru_inputs = 5,
-		.uapi = true,
-	}, {
-		.version = VI6_IP_VERSION_MODEL_VSPD_GEN3,
-		.features = VSP1_HAS_BRU | VSP1_HAS_LIF | VSP1_HAS_LUT,
-		.rpf_count = 5,
-		.wpf_count = 2,
-		.num_bru_inputs = 5,
-	},
-};
+static int vsp1_parse_dt(struct vsp1_device *vsp1)
+{
+	struct device_node *np = vsp1->dev->of_node;
+	struct vsp1_platform_data *pdata = &vsp1->pdata;
+
+	if (of_property_read_bool(np, "renesas,has-lif"))
+		pdata->features |= VSP1_HAS_LIF;
+	if (of_property_read_bool(np, "renesas,has-lut"))
+		pdata->features |= VSP1_HAS_LUT;
+	if (of_property_read_bool(np, "renesas,has-sru"))
+		pdata->features |= VSP1_HAS_SRU;
+
+	of_property_read_u32(np, "renesas,#rpf", &pdata->rpf_count);
+	of_property_read_u32(np, "renesas,#uds", &pdata->uds_count);
+	of_property_read_u32(np, "renesas,#wpf", &pdata->wpf_count);
+
+	if (pdata->rpf_count <= 0 || pdata->rpf_count > VSP1_MAX_RPF) {
+		dev_err(vsp1->dev, "invalid number of RPF (%u)\n",
+			pdata->rpf_count);
+		return -EINVAL;
+	}
+
+	if (pdata->uds_count <= 0 || pdata->uds_count > VSP1_MAX_UDS) {
+		dev_err(vsp1->dev, "invalid number of UDS (%u)\n",
+			pdata->uds_count);
+		return -EINVAL;
+	}
+
+	if (pdata->wpf_count <= 0 || pdata->wpf_count > VSP1_MAX_WPF) {
+		dev_err(vsp1->dev, "invalid number of WPF (%u)\n",
+			pdata->wpf_count);
+		return -EINVAL;
+	}
+
+	return 0;
+}

 static int vsp1_probe(struct platform_device *pdev)
 {
	struct vsp1_device *vsp1;
	struct resource *irq;
	struct resource *io;
-	unsigned int i;
-	u32 version;
	int ret;

	vsp1 = devm_kzalloc(&pdev->dev, sizeof(*vsp1), GFP_KERNEL);
@@ -650,7 +486,10 @@ static int vsp1_probe(struct platform_device *pdev)
	vsp1->dev = &pdev->dev;
	mutex_init(&vsp1->lock);
	INIT_LIST_HEAD(&vsp1->entities);
-	INIT_LIST_HEAD(&vsp1->videos);
+
+	ret = vsp1_parse_dt(vsp1);
+	if (ret < 0)
+		return ret;

	/* I/O, IRQ and clock resources */
	io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -677,29 +516,6 @@ static int vsp1_probe(struct platform_device *pdev)
		return ret;
	}

-	/* Configure device parameters based on the version register. */
-	ret = clk_prepare_enable(vsp1->clock);
-	if (ret < 0)
-		return ret;
-
-	version = vsp1_read(vsp1, VI6_IP_VERSION);
-	clk_disable_unprepare(vsp1->clock);
-
-	for (i = 0; i < ARRAY_SIZE(vsp1_device_infos); ++i) {
-		if ((version & VI6_IP_VERSION_MODEL_MASK) ==
-		    vsp1_device_infos[i].version) {
-			vsp1->info = &vsp1_device_infos[i];
-			break;
-		}
-	}
-
-	if (!vsp1->info) {
-		dev_err(&pdev->dev, "unsupported IP version 0x%08x\n", version);
-		return -ENXIO;
-	}
-
-	dev_dbg(&pdev->dev, "IP version 0x%08x\n", version);
-
	/* Instanciate entities */
	ret = vsp1_create_entities(vsp1);
	if (ret < 0) {
@@ -723,7 +539,6 @@ static int vsp1_remove(struct platform_device *pdev)

 static const struct of_device_id vsp1_of_match[] = {
	{ .compatible = "renesas,vsp1" },
-	{ .compatible = "renesas,vsp2" },
	{ },
 };

diff --git a/drivers/media/platform/vsp1/vsp1_entity.c b/drivers/media/platform/vsp1/vsp1_entity.c
index d65cf80..fd95a75 100644
--- a/drivers/media/platform/vsp1/vsp1_entity.c
+++ b/drivers/media/platform/vsp1/vsp1_entity.c
@@ -20,6 +20,7 @@

 #include "vsp1.h"
 #include "vsp1_entity.h"
+#include "vsp1_video.h"

 bool vsp1_entity_is_streaming(struct vsp1_entity *entity)
 {
@@ -45,7 +46,7 @@ int vsp1_entity_set_streaming(struct vsp1_entity *entity, bool streaming)
	if (!streaming)
		return 0;

-	if (!entity->vsp1->info->uapi || !entity->subdev.ctrl_handler)
+	if (!entity->subdev.ctrl_handler)
		return 0;

	ret = v4l2_ctrl_handler_setup(entity->subdev.ctrl_handler);
@@ -58,18 +59,6 @@ int vsp1_entity_set_streaming(struct vsp1_entity *entity, bool streaming)
	return ret;
 }

-void vsp1_entity_route_setup(struct vsp1_entity *source)
-{
-	struct vsp1_entity *sink;
-
-	if (source->route->reg == 0)
-		return;
-
-	sink = container_of(source->sink, struct vsp1_entity, subdev.entity);
-	vsp1_mod_write(source, source->route->reg,
-		       sink->route->inputs[source->sink_pad]);
-}
-
 /* -----------------------------------------------------------------------------
  * V4L2 Subdevice Operations
  */
@@ -131,9 +120,9 @@ const struct v4l2_subdev_internal_ops vsp1_subdev_internal_ops = {
  * Media Operations
  */

-int vsp1_entity_link_setup(struct media_entity *entity,
-			   const struct media_pad *local,
-			   const struct media_pad *remote, u32 flags)
+static int vsp1_entity_link_setup(struct media_entity *entity,
+				  const struct media_pad *local,
+				  const struct media_pad *remote, u32 flags)
 {
	struct vsp1_entity *source;

@@ -158,6 +147,11 @@ int vsp1_entity_link_setup(struct media_entity *entity,
	return 0;
 }

+const struct media_entity_operations vsp1_media_ops = {
+	.link_setup = vsp1_entity_link_setup,
+	.link_validate = v4l2_subdev_link_validate,
+};
+
 /* -----------------------------------------------------------------------------
  * Initialization
  */
@@ -165,8 +159,7 @@ int vsp1_entity_link_setup(struct media_entity *entity,
 static const struct vsp1_route vsp1_routes[] = {
	{ VSP1_ENTITY_BRU, 0, VI6_DPR_BRU_ROUTE,
	  { VI6_DPR_NODE_BRU_IN(0), VI6_DPR_NODE_BRU_IN(1),
-	    VI6_DPR_NODE_BRU_IN(2), VI6_DPR_NODE_BRU_IN(3),
-	    VI6_DPR_NODE_BRU_IN(4) } },
+	    VI6_DPR_NODE_BRU_IN(2), VI6_DPR_NODE_BRU_IN(3), } },
	{ VSP1_ENTITY_HSI, 0, VI6_DPR_HSI_ROUTE, { VI6_DPR_NODE_HSI, } },
	{ VSP1_ENTITY_HST, 0, VI6_DPR_HST_ROUTE, { VI6_DPR_NODE_HST, } },
	{ VSP1_ENTITY_LIF, 0, 0, { VI6_DPR_NODE_LIF, } },
@@ -232,6 +225,8 @@ int vsp1_entity_init(struct vsp1_device *vsp1, struct vsp1_entity *entity,

 void vsp1_entity_destroy(struct vsp1_entity *entity)
 {
+	if (entity->video)
+		vsp1_video_cleanup(entity->video);
	if (entity->subdev.ctrl_handler)
		v4l2_ctrl_handler_free(entity->subdev.ctrl_handler);
	media_entity_cleanup(&entity->subdev.entity);
diff --git a/drivers/media/platform/vsp1/vsp1_entity.h b/drivers/media/platform/vsp1/vsp1_entity.h
index 83570df..8867a578 100644
--- a/drivers/media/platform/vsp1/vsp1_entity.h
+++ b/drivers/media/platform/vsp1/vsp1_entity.h
@@ -19,6 +19,7 @@
 #include <media/v4l2-subdev.h>

 struct vsp1_device;
+struct vsp1_video;

 enum vsp1_entity_type {
	VSP1_ENTITY_BRU,
@@ -32,8 +33,6 @@ enum vsp1_entity_type {
	VSP1_ENTITY_WPF,
 };

-#define VSP1_ENTITY_MAX_INPUTS		5	/* For the BRU */
-
 /*
  * struct vsp1_route - Entity routing configuration
  * @type: Entity type this routing entry is associated with
@@ -50,7 +49,7 @@ struct vsp1_route {
	enum vsp1_entity_type type;
	unsigned int index;
	unsigned int reg;
-	unsigned int inputs[VSP1_ENTITY_MAX_INPUTS];
+	unsigned int inputs[4];
 };

 struct vsp1_entity {
@@ -72,6 +71,8 @@ struct vsp1_entity {
	struct v4l2_subdev subdev;
	struct v4l2_mbus_framefmt *formats;

+	struct vsp1_video *video;
+
	spinlock_t lock;		/* Protects the streaming field */
	bool streaming;
 };
@@ -86,10 +87,7 @@ int vsp1_entity_init(struct vsp1_device *vsp1, struct vsp1_entity *entity,
 void vsp1_entity_destroy(struct vsp1_entity *entity);

 extern const struct v4l2_subdev_internal_ops vsp1_subdev_internal_ops;
-
-int vsp1_entity_link_setup(struct media_entity *entity,
-			   const struct media_pad *local,
-			   const struct media_pad *remote, u32 flags);
+extern const struct media_entity_operations vsp1_media_ops;

 struct v4l2_mbus_framefmt *
 vsp1_entity_get_pad_format(struct vsp1_entity *entity,
@@ -101,6 +99,4 @@ void vsp1_entity_init_formats(struct v4l2_subdev *subdev,
 bool vsp1_entity_is_streaming(struct vsp1_entity *entity);
 int vsp1_entity_set_streaming(struct vsp1_entity *entity, bool streaming);

-void vsp1_entity_route_setup(struct vsp1_entity *source);
-
 #endif /* __VSP1_ENTITY_H__ */
diff --git a/drivers/media/platform/vsp1/vsp1_hsit.c b/drivers/media/platform/vsp1/vsp1_hsit.c
index c1087cf..8ffb817 100644
--- a/drivers/media/platform/vsp1/vsp1_hsit.c
+++ b/drivers/media/platform/vsp1/vsp1_hsit.c
@@ -203,7 +203,7 @@ struct vsp1_hsit *vsp1_hsit_create(struct vsp1_device *vsp1, bool inverse)
	subdev = &hsit->entity.subdev;
	v4l2_subdev_init(subdev, &hsit_ops);

-	subdev->entity.ops = &vsp1->media_ops;
+	subdev->entity.ops = &vsp1_media_ops;
	subdev->internal_ops = &vsp1_subdev_internal_ops;
	snprintf(subdev->name, sizeof(subdev->name), "%s %s",
		 dev_name(vsp1->dev), inverse ? "hsi" : "hst");
diff --git a/drivers/media/platform/vsp1/vsp1_lif.c b/drivers/media/platform/vsp1/vsp1_lif.c
index 433853c..39fa5ef 100644
--- a/drivers/media/platform/vsp1/vsp1_lif.c
+++ b/drivers/media/platform/vsp1/vsp1_lif.c
@@ -26,9 +26,14 @@
  * Device Access
  */

+static inline u32 vsp1_lif_read(struct vsp1_lif *lif, u32 reg)
+{
+	return vsp1_read(lif->entity.vsp1, reg);
+}
+
 static inline void vsp1_lif_write(struct vsp1_lif *lif, u32 reg, u32 data)
 {
-	vsp1_mod_write(&lif->entity, reg, data);
+	vsp1_write(lif->entity.vsp1, reg, data);
 }

 /* -----------------------------------------------------------------------------
@@ -44,7 +49,7 @@ static int lif_s_stream(struct v4l2_subdev *subdev, int enable)
	unsigned int lbth = 200;

	if (!enable) {
-		vsp1_write(lif->entity.vsp1, VI6_LIF_CTRL, 0);
+		vsp1_lif_write(lif, VI6_LIF_CTRL, 0);
		return 0;
	}

@@ -223,7 +228,7 @@ struct vsp1_lif *vsp1_lif_create(struct vsp1_device *vsp1)
	subdev = &lif->entity.subdev;
	v4l2_subdev_init(subdev, &lif_ops);

-	subdev->entity.ops = &vsp1->media_ops;
+	subdev->entity.ops = &vsp1_media_ops;
	subdev->internal_ops = &vsp1_subdev_internal_ops;
	snprintf(subdev->name, sizeof(subdev->name), "%s lif",
		 dev_name(vsp1->dev));
diff --git a/drivers/media/platform/vsp1/vsp1_lut.c b/drivers/media/platform/vsp1/vsp1_lut.c
index 4b89095..656ec27 100644
--- a/drivers/media/platform/vsp1/vsp1_lut.c
+++ b/drivers/media/platform/vsp1/vsp1_lut.c
@@ -27,6 +27,11 @@
  * Device Access
  */

+static inline u32 vsp1_lut_read(struct vsp1_lut *lut, u32 reg)
+{
+	return vsp1_read(lut->entity.vsp1, reg);
+}
+
 static inline void vsp1_lut_write(struct vsp1_lut *lut, u32 reg, u32 data)
 {
	vsp1_write(lut->entity.vsp1, reg, data);
@@ -237,7 +242,7 @@ struct vsp1_lut *vsp1_lut_create(struct vsp1_device *vsp1)
	subdev = &lut->entity.subdev;
	v4l2_subdev_init(subdev, &lut_ops);

-	subdev->entity.ops = &vsp1->media_ops;
+	subdev->entity.ops = &vsp1_media_ops;
	subdev->internal_ops = &vsp1_subdev_internal_ops;
	snprintf(subdev->name, sizeof(subdev->name), "%s lut",
		 dev_name(vsp1->dev));
diff --git a/drivers/media/platform/vsp1/vsp1_pipe.c b/drivers/media/platform/vsp1/vsp1_pipe.c
deleted file mode 100644
index 96f0e7d..0000000
--- a/drivers/media/platform/vsp1/vsp1_pipe.c
+++ /dev/null
@@ -1,405 +0,0 @@
-/*
- * vsp1_pipe.c  --  R-Car VSP1 Pipeline
- *
- * Copyright (C) 2013-2015 Renesas Electronics Corporation
- *
- * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-#include <linux/delay.h>
-#include <linux/list.h>
-#include <linux/wait.h>
-
-#include <media/media-entity.h>
-#include <media/v4l2-subdev.h>
-
-#include "vsp1.h"
-#include "vsp1_bru.h"
-#include "vsp1_dl.h"
-#include "vsp1_entity.h"
-#include "vsp1_pipe.h"
-#include "vsp1_rwpf.h"
-#include "vsp1_uds.h"
-
-/* -----------------------------------------------------------------------------
- * Helper Functions
- */
-
-static const struct vsp1_format_info vsp1_video_formats[] = {
-	{ V4L2_PIX_FMT_RGB332, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_RGB_332, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  1, { 8, 0, 0 }, false, false, 1, 1, false },
-	{ V4L2_PIX_FMT_ARGB444, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_ARGB_4444, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS,
-	  1, { 16, 0, 0 }, false, false, 1, 1, true },
-	{ V4L2_PIX_FMT_XRGB444, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_XRGB_4444, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS,
-	  1, { 16, 0, 0 }, false, false, 1, 1, true },
-	{ V4L2_PIX_FMT_ARGB555, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_ARGB_1555, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS,
-	  1, { 16, 0, 0 }, false, false, 1, 1, true },
-	{ V4L2_PIX_FMT_XRGB555, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_XRGB_1555, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS,
-	  1, { 16, 0, 0 }, false, false, 1, 1, false },
-	{ V4L2_PIX_FMT_RGB565, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_RGB_565, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS,
-	  1, { 16, 0, 0 }, false, false, 1, 1, false },
-	{ V4L2_PIX_FMT_BGR24, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_BGR_888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  1, { 24, 0, 0 }, false, false, 1, 1, false },
-	{ V4L2_PIX_FMT_RGB24, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_RGB_888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  1, { 24, 0, 0 }, false, false, 1, 1, false },
-	{ V4L2_PIX_FMT_ABGR32, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_ARGB_8888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS,
-	  1, { 32, 0, 0 }, false, false, 1, 1, true },
-	{ V4L2_PIX_FMT_XBGR32, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_ARGB_8888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS,
-	  1, { 32, 0, 0 }, false, false, 1, 1, false },
-	{ V4L2_PIX_FMT_ARGB32, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_ARGB_8888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  1, { 32, 0, 0 }, false, false, 1, 1, true },
-	{ V4L2_PIX_FMT_XRGB32, MEDIA_BUS_FMT_ARGB8888_1X32,
-	  VI6_FMT_ARGB_8888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  1, { 32, 0, 0 }, false, false, 1, 1, false },
-	{ V4L2_PIX_FMT_UYVY, MEDIA_BUS_FMT_AYUV8_1X32,
-	  VI6_FMT_YUYV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  1, { 16, 0, 0 }, false, false, 2, 1, false },
-	{ V4L2_PIX_FMT_VYUY, MEDIA_BUS_FMT_AYUV8_1X32,
-	  VI6_FMT_YUYV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  1, { 16, 0, 0 }, false, true, 2, 1, false },
-	{ V4L2_PIX_FMT_YUYV, MEDIA_BUS_FMT_AYUV8_1X32,
-	  VI6_FMT_YUYV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  1, { 16, 0, 0 }, true, false, 2, 1, false },
-	{ V4L2_PIX_FMT_YVYU, MEDIA_BUS_FMT_AYUV8_1X32,
-	  VI6_FMT_YUYV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  1, { 16, 0, 0 }, true, true, 2, 1, false },
-	{ V4L2_PIX_FMT_NV12M, MEDIA_BUS_FMT_AYUV8_1X32,
-	  VI6_FMT_Y_UV_420, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  2, { 8, 16, 0 }, false, false, 2, 2, false },
-	{ V4L2_PIX_FMT_NV21M, MEDIA_BUS_FMT_AYUV8_1X32,
-	  VI6_FMT_Y_UV_420, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  2, { 8, 16, 0 }, false, true, 2, 2, false },
-	{ V4L2_PIX_FMT_NV16M, MEDIA_BUS_FMT_AYUV8_1X32,
-	  VI6_FMT_Y_UV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  2, { 8, 16, 0 }, false, false, 2, 1, false },
-	{ V4L2_PIX_FMT_NV61M, MEDIA_BUS_FMT_AYUV8_1X32,
-	  VI6_FMT_Y_UV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  2, { 8, 16, 0 }, false, true, 2, 1, false },
-	{ V4L2_PIX_FMT_YUV420M, MEDIA_BUS_FMT_AYUV8_1X32,
-	  VI6_FMT_Y_U_V_420, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
-	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
-	  3, { 8, 8, 8 }, false, false, 2, 2, false },
-};
-
-/*
- * vsp1_get_format_info - Retrieve format information for a 4CC
- * @fourcc: the format 4CC
- *
- * Return a pointer to the format information structure corresponding to the
- * given V4L2 format 4CC, or NULL if no corresponding format can be found.
- */
-const struct vsp1_format_info *vsp1_get_format_info(u32 fourcc)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(vsp1_video_formats); ++i) {
-		const struct vsp1_format_info *info = &vsp1_video_formats[i];
-
-		if (info->fourcc == fourcc)
-			return info;
-	}
-
-	return NULL;
-}
-
-/* -----------------------------------------------------------------------------
- * Pipeline Management
- */
-
-void vsp1_pipeline_reset(struct vsp1_pipeline *pipe)
-{
-	unsigned int i;
-
-	if (pipe->bru) {
-		struct vsp1_bru *bru = to_bru(&pipe->bru->subdev);
-
-		for (i = 0; i < ARRAY_SIZE(bru->inputs); ++i)
-			bru->inputs[i].rpf = NULL;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(pipe->inputs); ++i)
-		pipe->inputs[i] = NULL;
-
-	INIT_LIST_HEAD(&pipe->entities);
-	pipe->state = VSP1_PIPELINE_STOPPED;
-	pipe->buffers_ready = 0;
-	pipe->num_inputs = 0;
-	pipe->output = NULL;
-	pipe->bru = NULL;
-	pipe->lif = NULL;
-	pipe->uds = NULL;
-}
-
-void vsp1_pipeline_init(struct vsp1_pipeline *pipe)
-{
-	mutex_init(&pipe->lock);
-	spin_lock_init(&pipe->irqlock);
-	init_waitqueue_head(&pipe->wq);
-
-	INIT_LIST_HEAD(&pipe->entities);
-	pipe->state = VSP1_PIPELINE_STOPPED;
-}
-
-void vsp1_pipeline_run(struct vsp1_pipeline *pipe)
-{
-	struct vsp1_device *vsp1 = pipe->output->entity.vsp1;
-
-	if (pipe->state == VSP1_PIPELINE_STOPPED) {
-		vsp1_write(vsp1, VI6_CMD(pipe->output->entity.index),
-			   VI6_CMD_STRCMD);
-		pipe->state = VSP1_PIPELINE_RUNNING;
-	}
-
-	pipe->buffers_ready = 0;
-}
-
-bool vsp1_pipeline_stopped(struct vsp1_pipeline *pipe)
-{
-	unsigned long flags;
-	bool stopped;
-
-	spin_lock_irqsave(&pipe->irqlock, flags);
-	stopped = pipe->state == VSP1_PIPELINE_STOPPED,
-	spin_unlock_irqrestore(&pipe->irqlock, flags);
-
-	return stopped;
-}
-
-int vsp1_pipeline_stop(struct vsp1_pipeline *pipe)
-{
-	struct vsp1_entity *entity;
-	unsigned long flags;
-	int ret;
-
-	if (pipe->dl) {
-		/* When using display lists in continuous frame mode the only
-		 * way to stop the pipeline is to reset the hardware.
-		 */
-		ret = vsp1_reset_wpf(pipe->output->entity.vsp1,
-				     pipe->output->entity.index);
-		if (ret == 0) {
-			spin_lock_irqsave(&pipe->irqlock, flags);
-			pipe->state = VSP1_PIPELINE_STOPPED;
-			spin_unlock_irqrestore(&pipe->irqlock, flags);
-		}
-	} else {
-		/* Otherwise just request a stop and wait. */
-		spin_lock_irqsave(&pipe->irqlock, flags);
-		if (pipe->state == VSP1_PIPELINE_RUNNING)
-			pipe->state = VSP1_PIPELINE_STOPPING;
-		spin_unlock_irqrestore(&pipe->irqlock, flags);
-
-		ret = wait_event_timeout(pipe->wq, vsp1_pipeline_stopped(pipe),
-					 msecs_to_jiffies(500));
-		ret = ret == 0 ? -ETIMEDOUT : 0;
-	}
-
-	list_for_each_entry(entity, &pipe->entities, list_pipe) {
-		if (entity->route && entity->route->reg)
-			vsp1_write(entity->vsp1, entity->route->reg,
-				   VI6_DPR_NODE_UNUSED);
-
-		v4l2_subdev_call(&entity->subdev, video, s_stream, 0);
-	}
-
-	return ret;
-}
-
-bool vsp1_pipeline_ready(struct vsp1_pipeline *pipe)
-{
-	unsigned int mask;
-
-	mask = ((1 << pipe->num_inputs) - 1) << 1;
-	if (!pipe->lif)
-		mask |= 1 << 0;
-
-	return pipe->buffers_ready == mask;
-}
-
-void vsp1_pipeline_display_start(struct vsp1_pipeline *pipe)
-{
-	if (pipe->dl)
-		vsp1_dl_irq_display_start(pipe->dl);
-}
-
-void vsp1_pipeline_frame_end(struct vsp1_pipeline *pipe)
-{
-	enum vsp1_pipeline_state state;
-	unsigned long flags;
-
-	if (pipe == NULL)
-		return;
-
-	if (pipe->dl)
-		vsp1_dl_irq_frame_end(pipe->dl);
-
-	/* Signal frame end to the pipeline handler. */
-	pipe->frame_end(pipe);
-
-	spin_lock_irqsave(&pipe->irqlock, flags);
-
-	state = pipe->state;
-
-	/* When using display lists in continuous frame mode the pipeline is
-	 * automatically restarted by the hardware.
-	 */
-	if (!pipe->dl)
-		pipe->state = VSP1_PIPELINE_STOPPED;
-
-	/* If a stop has been requested, mark the pipeline as stopped and
-	 * return.
-	 */
-	if (state == VSP1_PIPELINE_STOPPING) {
-		wake_up(&pipe->wq);
-		goto done;
-	}
-
-	/* Restart the pipeline if ready. */
-	if (vsp1_pipeline_ready(pipe))
-		vsp1_pipeline_run(pipe);
-
-done:
-	spin_unlock_irqrestore(&pipe->irqlock, flags);
-}
-
-/*
- * Propagate the alpha value through the pipeline.
- *
- * As the UDS has restricted scaling capabilities when the alpha component needs
- * to be scaled, we disable alpha scaling when the UDS input has a fixed alpha
- * value. The UDS then outputs a fixed alpha value which needs to be programmed
- * from the input RPF alpha.
- */
-void vsp1_pipeline_propagate_alpha(struct vsp1_pipeline *pipe,
-				   struct vsp1_entity *input,
-				   unsigned int alpha)
-{
-	struct vsp1_entity *entity;
-	struct media_pad *pad;
-
-	pad = media_entity_remote_pad(&input->pads[RWPF_PAD_SOURCE]);
-
-	while (pad) {
-		if (media_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)
-			break;
-
-		entity = to_vsp1_entity(media_entity_to_v4l2_subdev(pad->entity));
-
-		/* The BRU background color has a fixed alpha value set to 255,
-		 * the output alpha value is thus always equal to 255.
-		 */
-		if (entity->type == VSP1_ENTITY_BRU)
-			alpha = 255;
-
-		if (entity->type == VSP1_ENTITY_UDS) {
-			struct vsp1_uds *uds = to_uds(&entity->subdev);
-
-			vsp1_uds_set_alpha(uds, alpha);
-			break;
-		}
-
-		pad = &entity->pads[entity->source_pad];
-		pad = media_entity_remote_pad(pad);
-	}
-}
-
-void vsp1_pipelines_suspend(struct vsp1_device *vsp1)
-{
-	unsigned long flags;
-	unsigned int i;
-	int ret;
-
-	/* To avoid increasing the system suspend time needlessly, loop over the
-	 * pipelines twice, first to set them all to the stopping state, and
-	 * then to wait for the stop to complete.
-	 */
-	for (i = 0; i < vsp1->info->wpf_count; ++i) {
-		struct vsp1_rwpf *wpf = vsp1->wpf[i];
-		struct vsp1_pipeline *pipe;
-
-		if (wpf == NULL)
-			continue;
-
-		pipe = to_vsp1_pipeline(&wpf->entity.subdev.entity);
-		if (pipe == NULL)
-			continue;
-
-		spin_lock_irqsave(&pipe->irqlock, flags);
-		if (pipe->state == VSP1_PIPELINE_RUNNING)
-			pipe->state = VSP1_PIPELINE_STOPPING;
-		spin_unlock_irqrestore(&pipe->irqlock, flags);
-	}
-
-	for (i = 0; i < vsp1->info->wpf_count; ++i) {
-		struct vsp1_rwpf *wpf = vsp1->wpf[i];
-		struct vsp1_pipeline *pipe;
-
-		if (wpf == NULL)
-			continue;
-
-		pipe = to_vsp1_pipeline(&wpf->entity.subdev.entity);
-		if (pipe == NULL)
-			continue;
-
-		ret = wait_event_timeout(pipe->wq, vsp1_pipeline_stopped(pipe),
-					 msecs_to_jiffies(500));
-		if (ret == 0)
-			dev_warn(vsp1->dev, "pipeline %u stop timeout\n",
-				 wpf->entity.index);
-	}
-}
-
-void vsp1_pipelines_resume(struct vsp1_device *vsp1)
-{
-	unsigned int i;
-
-	/* Resume pipeline all running pipelines. */
-	for (i = 0; i < vsp1->info->wpf_count; ++i) {
-		struct vsp1_rwpf *wpf = vsp1->wpf[i];
-		struct vsp1_pipeline *pipe;
-
-		if (wpf == NULL)
-			continue;
-
-		pipe = to_vsp1_pipeline(&wpf->entity.subdev.entity);
-		if (pipe == NULL)
-			continue;
-
-		if (vsp1_pipeline_ready(pipe))
-			vsp1_pipeline_run(pipe);
-	}
-}
diff --git a/drivers/media/platform/vsp1/vsp1_pipe.h b/drivers/media/platform/vsp1/vsp1_pipe.h
deleted file mode 100644
index b2f3a8a..0000000
--- a/drivers/media/platform/vsp1/vsp1_pipe.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * vsp1_pipe.h  --  R-Car VSP1 Pipeline
- *
- * Copyright (C) 2013-2015 Renesas Electronics Corporation
- *
- * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-#ifndef __VSP1_PIPE_H__
-#define __VSP1_PIPE_H__
-
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/wait.h>
-
-#include <media/media-entity.h>
-
-struct vsp1_dl;
-struct vsp1_rwpf;
-
-/*
- * struct vsp1_format_info - VSP1 video format description
- * @mbus: media bus format code
- * @fourcc: V4L2 pixel format FCC identifier
- * @planes: number of planes
- * @bpp: bits per pixel
- * @hwfmt: VSP1 hardware format
- * @swap_yc: the Y and C components are swapped (Y comes before C)
- * @swap_uv: the U and V components are swapped (V comes before U)
- * @hsub: horizontal subsampling factor
- * @vsub: vertical subsampling factor
- * @alpha: has an alpha channel
- */
-struct vsp1_format_info {
-	u32 fourcc;
-	unsigned int mbus;
-	unsigned int hwfmt;
-	unsigned int swap;
-	unsigned int planes;
-	unsigned int bpp[3];
-	bool swap_yc;
-	bool swap_uv;
-	unsigned int hsub;
-	unsigned int vsub;
-	bool alpha;
-};
-
-enum vsp1_pipeline_state {
-	VSP1_PIPELINE_STOPPED,
-	VSP1_PIPELINE_RUNNING,
-	VSP1_PIPELINE_STOPPING,
-};
-
-/*
- * struct vsp1_pipeline - A VSP1 hardware pipeline
- * @pipe: the media pipeline
- * @irqlock: protects the pipeline state
- * @state: current state
- * @wq: work queue to wait for state change completion
- * @frame_end: frame end interrupt handler
- * @lock: protects the pipeline use count and stream count
- * @use_count: number of video nodes using the pipeline
- * @stream_count: number of streaming video nodes
- * @buffers_ready: bitmask of RPFs and WPFs with at least one buffer available
- * @num_inputs: number of RPFs
- * @inputs: array of RPFs in the pipeline (indexed by RPF index)
- * @output: WPF at the output of the pipeline
- * @bru: BRU entity, if present
- * @lif: LIF entity, if present
- * @uds: UDS entity, if present
- * @uds_input: entity at the input of the UDS, if the UDS is present
- * @entities: list of entities in the pipeline
- * @dl: display list associated with the pipeline
- */
-struct vsp1_pipeline {
-	struct media_pipeline pipe;
-
-	spinlock_t irqlock;
-	enum vsp1_pipeline_state state;
-	wait_queue_head_t wq;
-
-	void (*frame_end)(struct vsp1_pipeline *pipe);
-
-	struct mutex lock;
-	unsigned int use_count;
-	unsigned int stream_count;
-	unsigned int buffers_ready;
-
-	unsigned int num_inputs;
-	struct vsp1_rwpf *inputs[VSP1_MAX_RPF];
-	struct vsp1_rwpf *output;
-	struct vsp1_entity *bru;
-	struct vsp1_entity *lif;
-	struct vsp1_entity *uds;
-	struct vsp1_entity *uds_input;
-
-	struct list_head entities;
-
-	struct vsp1_dl *dl;
-};
-
-static inline struct vsp1_pipeline *to_vsp1_pipeline(struct media_entity *e)
-{
-	if (likely(e->pipe))
-		return container_of(e->pipe, struct vsp1_pipeline, pipe);
-	else
-		return NULL;
-}
-
-void vsp1_pipeline_reset(struct vsp1_pipeline *pipe);
-void vsp1_pipeline_init(struct vsp1_pipeline *pipe);
-
-void vsp1_pipeline_run(struct vsp1_pipeline *pipe);
-bool vsp1_pipeline_stopped(struct vsp1_pipeline *pipe);
-int vsp1_pipeline_stop(struct vsp1_pipeline *pipe);
-bool vsp1_pipeline_ready(struct vsp1_pipeline *pipe);
-
-void vsp1_pipeline_display_start(struct vsp1_pipeline *pipe);
-void vsp1_pipeline_frame_end(struct vsp1_pipeline *pipe);
-
-void vsp1_pipeline_propagate_alpha(struct vsp1_pipeline *pipe,
-				   struct vsp1_entity *input,
-				   unsigned int alpha);
-
-void vsp1_pipelines_suspend(struct vsp1_device *vsp1);
-void vsp1_pipelines_resume(struct vsp1_device *vsp1);
-
-const struct vsp1_format_info *vsp1_get_format_info(u32 fourcc);
-
-#endif /* __VSP1_PIPE_H__ */
diff --git a/drivers/media/platform/vsp1/vsp1_regs.h b/drivers/media/platform/vsp1/vsp1_regs.h
index 069216f..25b4873 100644
--- a/drivers/media/platform/vsp1/vsp1_regs.h
+++ b/drivers/media/platform/vsp1/vsp1_regs.h
@@ -46,7 +46,7 @@
 #define VI6_DISP_IRQ_ENB_LNEE(n)	(1 << (n))

 #define VI6_DISP_IRQ_STA		0x007c
-#define VI6_DISP_IRQ_STA_DST		(1 << 8)
+#define VI6_DISP_IRQ_STA_DSE		(1 << 8)
 #define VI6_DISP_IRQ_STA_MAE		(1 << 5)
 #define VI6_DISP_IRQ_STA_LNE(n)		(1 << (n))

@@ -322,7 +322,7 @@
 #define VI6_DPR_NODE_SRU		16
 #define VI6_DPR_NODE_UDS(n)		(17 + (n))
 #define VI6_DPR_NODE_LUT		22
-#define VI6_DPR_NODE_BRU_IN(n)		(((n) <= 3) ? 23 + (n) : 49)
+#define VI6_DPR_NODE_BRU_IN(n)		(23 + (n))
 #define VI6_DPR_NODE_BRU_OUT		27
 #define VI6_DPR_NODE_CLU		29
 #define VI6_DPR_NODE_HST		30
@@ -504,12 +504,12 @@
 #define VI6_BRU_VIRRPF_COL_BCB_MASK	(0xff << 0)
 #define VI6_BRU_VIRRPF_COL_BCB_SHIFT	0

-#define VI6_BRU_CTRL(n)			(0x2c10 + (n) * 8 + ((n) <= 3 ? 0 : 4))
+#define VI6_BRU_CTRL(n)			(0x2c10 + (n) * 8)
 #define VI6_BRU_CTRL_RBC		(1 << 31)
-#define VI6_BRU_CTRL_DSTSEL_BRUIN(n)	(((n) <= 3 ? (n) : (n)+1) << 20)
+#define VI6_BRU_CTRL_DSTSEL_BRUIN(n)	((n) << 20)
 #define VI6_BRU_CTRL_DSTSEL_VRPF	(4 << 20)
 #define VI6_BRU_CTRL_DSTSEL_MASK	(7 << 20)
-#define VI6_BRU_CTRL_SRCSEL_BRUIN(n)	(((n) <= 3 ? (n) : (n)+1) << 16)
+#define VI6_BRU_CTRL_SRCSEL_BRUIN(n)	((n) << 16)
 #define VI6_BRU_CTRL_SRCSEL_VRPF	(4 << 16)
 #define VI6_BRU_CTRL_SRCSEL_MASK	(7 << 16)
 #define VI6_BRU_CTRL_CROP(rop)		((rop) << 4)
@@ -517,7 +517,7 @@
 #define VI6_BRU_CTRL_AROP(rop)		((rop) << 0)
 #define VI6_BRU_CTRL_AROP_MASK		(0xf << 0)

-#define VI6_BRU_BLD(n)			(0x2c14 + (n) * 8 + ((n) <= 3 ? 0 : 4))
+#define VI6_BRU_BLD(n)			(0x2c14 + (n) * 8)
 #define VI6_BRU_BLD_CBES		(1 << 31)
 #define VI6_BRU_BLD_CCMDX_DST_A		(0 << 28)
 #define VI6_BRU_BLD_CCMDX_255_DST_A	(1 << 28)
@@ -551,7 +551,7 @@
 #define VI6_BRU_BLD_COEFY_SHIFT		0

 #define VI6_BRU_ROP			0x2c30
-#define VI6_BRU_ROP_DSTSEL_BRUIN(n)	(((n) <= 3 ? (n) : (n)+1) << 20)
+#define VI6_BRU_ROP_DSTSEL_BRUIN(n)	((n) << 20)
 #define VI6_BRU_ROP_DSTSEL_VRPF		(4 << 20)
 #define VI6_BRU_ROP_DSTSEL_MASK		(7 << 20)
 #define VI6_BRU_ROP_CROP(rop)		((rop) << 4)
@@ -625,24 +625,6 @@
 #define VI6_SECURITY_CTRL1		0x3d04

 /* -----------------------------------------------------------------------------
- * IP Version Registers
- */
-
-#define VI6_IP_VERSION			0x3f00
-#define VI6_IP_VERSION_MODEL_MASK	(0xff << 8)
-#define VI6_IP_VERSION_MODEL_VSPS_H2	(0x09 << 8)
-#define VI6_IP_VERSION_MODEL_VSPR_H2	(0x0a << 8)
-#define VI6_IP_VERSION_MODEL_VSPD_GEN2	(0x0b << 8)
-#define VI6_IP_VERSION_MODEL_VSPS_M2	(0x0c << 8)
-#define VI6_IP_VERSION_MODEL_VSPI_GEN3	(0x14 << 8)
-#define VI6_IP_VERSION_MODEL_VSPBD_GEN3	(0x15 << 8)
-#define VI6_IP_VERSION_MODEL_VSPBC_GEN3	(0x16 << 8)
-#define VI6_IP_VERSION_MODEL_VSPD_GEN3	(0x17 << 8)
-#define VI6_IP_VERSION_SOC_MASK		(0xff << 0)
-#define VI6_IP_VERSION_SOC_H		(0x01 << 0)
-#define VI6_IP_VERSION_SOC_M		(0x02 << 0)
-
-/* -----------------------------------------------------------------------------
  * RPF CLUT Registers
  */

diff --git a/drivers/media/platform/vsp1/vsp1_rpf.c b/drivers/media/platform/vsp1/vsp1_rpf.c
index 5bc1d15..cd5248a 100644
--- a/drivers/media/platform/vsp1/vsp1_rpf.c
+++ b/drivers/media/platform/vsp1/vsp1_rpf.c
@@ -26,10 +26,16 @@
  * Device Access
  */

+static inline u32 vsp1_rpf_read(struct vsp1_rwpf *rpf, u32 reg)
+{
+	return vsp1_read(rpf->entity.vsp1,
+			 reg + rpf->entity.index * VI6_RPF_OFFSET);
+}
+
 static inline void vsp1_rpf_write(struct vsp1_rwpf *rpf, u32 reg, u32 data)
 {
-	vsp1_mod_write(&rpf->entity, reg + rpf->entity.index * VI6_RPF_OFFSET,
-		       data);
+	vsp1_write(rpf->entity.vsp1,
+		   reg + rpf->entity.index * VI6_RPF_OFFSET, data);
 }

 /* -----------------------------------------------------------------------------
@@ -68,11 +74,9 @@ static const struct v4l2_ctrl_ops rpf_ctrl_ops = {

 static int rpf_s_stream(struct v4l2_subdev *subdev, int enable)
 {
-	struct vsp1_pipeline *pipe = to_vsp1_pipeline(&subdev->entity);
	struct vsp1_rwpf *rpf = to_rwpf(subdev);
-	struct vsp1_device *vsp1 = rpf->entity.vsp1;
-	const struct vsp1_format_info *fmtinfo = rpf->fmtinfo;
-	const struct v4l2_pix_format_mplane *format = &rpf->format;
+	const struct vsp1_format_info *fmtinfo = rpf->video.fmtinfo;
+	const struct v4l2_pix_format_mplane *format = &rpf->video.format;
	const struct v4l2_rect *crop = &rpf->crop;
	u32 pstride;
	u32 infmt;
@@ -150,15 +154,6 @@ static int rpf_s_stream(struct v4l2_subdev *subdev, int enable)
	vsp1_rpf_write(rpf, VI6_RPF_ALPH_SEL, VI6_RPF_ALPH_SEL_AEXT_EXT |
		       (fmtinfo->alpha ? VI6_RPF_ALPH_SEL_ASEL_PACKED
				       : VI6_RPF_ALPH_SEL_ASEL_FIXED));
-
-	if (vsp1->info->uapi)
-		mutex_lock(rpf->ctrls.lock);
-	vsp1_rpf_write(rpf, VI6_RPF_VRTCOL_SET,
-		       rpf->alpha->cur.val << VI6_RPF_VRTCOL_SET_LAYA_SHIFT);
-	vsp1_pipeline_propagate_alpha(pipe, &rpf->entity, rpf->alpha->cur.val);
-	if (vsp1->info->uapi)
-		mutex_unlock(rpf->ctrls.lock);
-
	vsp1_rpf_write(rpf, VI6_RPF_MSK_CTRL, 0);
	vsp1_rpf_write(rpf, VI6_RPF_CKEY_CTRL, 0);

@@ -191,28 +186,30 @@ static struct v4l2_subdev_ops rpf_ops = {
  * Video Device Operations
  */

-static void rpf_set_memory(struct vsp1_rwpf *rpf, struct vsp1_rwpf_memory *mem)
+static void rpf_vdev_queue(struct vsp1_video *video,
+			   struct vsp1_video_buffer *buf)
 {
+	struct vsp1_rwpf *rpf = container_of(video, struct vsp1_rwpf, video);
	unsigned int i;

	for (i = 0; i < 3; ++i)
-		rpf->buf_addr[i] = mem->addr[i];
+		rpf->buf_addr[i] = buf->addr[i];

	if (!vsp1_entity_is_streaming(&rpf->entity))
		return;

	vsp1_rpf_write(rpf, VI6_RPF_SRCM_ADDR_Y,
-		       mem->addr[0] + rpf->offsets[0]);
-	if (mem->num_planes > 1)
+		       buf->addr[0] + rpf->offsets[0]);
+	if (buf->buf.vb2_buf.num_planes > 1)
		vsp1_rpf_write(rpf, VI6_RPF_SRCM_ADDR_C0,
-			       mem->addr[1] + rpf->offsets[1]);
-	if (mem->num_planes > 2)
+			       buf->addr[1] + rpf->offsets[1]);
+	if (buf->buf.vb2_buf.num_planes > 2)
		vsp1_rpf_write(rpf, VI6_RPF_SRCM_ADDR_C1,
-			       mem->addr[2] + rpf->offsets[1]);
+			       buf->addr[2] + rpf->offsets[1]);
 }

-static const struct vsp1_rwpf_operations rpf_vdev_ops = {
-	.set_memory = rpf_set_memory,
+static const struct vsp1_video_operations rpf_vdev_ops = {
+	.queue = rpf_vdev_queue,
 };

 /* -----------------------------------------------------------------------------
@@ -222,6 +219,7 @@ static const struct vsp1_rwpf_operations rpf_vdev_ops = {
 struct vsp1_rwpf *vsp1_rpf_create(struct vsp1_device *vsp1, unsigned int index)
 {
	struct v4l2_subdev *subdev;
+	struct vsp1_video *video;
	struct vsp1_rwpf *rpf;
	int ret;

@@ -229,8 +227,6 @@ struct vsp1_rwpf *vsp1_rpf_create(struct vsp1_device *vsp1, unsigned int index)
	if (rpf == NULL)
		return ERR_PTR(-ENOMEM);

-	rpf->ops = &rpf_vdev_ops;
-
	rpf->max_width = RPF_MAX_WIDTH;
	rpf->max_height = RPF_MAX_HEIGHT;

@@ -245,7 +241,7 @@ struct vsp1_rwpf *vsp1_rpf_create(struct vsp1_device *vsp1, unsigned int index)
	subdev = &rpf->entity.subdev;
	v4l2_subdev_init(subdev, &rpf_ops);

-	subdev->entity.ops = &vsp1->media_ops;
+	subdev->entity.ops = &vsp1_media_ops;
	subdev->internal_ops = &vsp1_subdev_internal_ops;
	snprintf(subdev->name, sizeof(subdev->name), "%s rpf.%u",
		 dev_name(vsp1->dev), index);
@@ -256,9 +252,8 @@ struct vsp1_rwpf *vsp1_rpf_create(struct vsp1_device *vsp1, unsigned int index)

	/* Initialize the control handler. */
	v4l2_ctrl_handler_init(&rpf->ctrls, 1);
-	rpf->alpha = v4l2_ctrl_new_std(&rpf->ctrls, &rpf_ctrl_ops,
-				       V4L2_CID_ALPHA_COMPONENT,
-				       0, 255, 1, 255);
+	v4l2_ctrl_new_std(&rpf->ctrls, &rpf_ctrl_ops, V4L2_CID_ALPHA_COMPONENT,
+			  0, 255, 1, 255);

	rpf->entity.subdev.ctrl_handler = &rpf->ctrls;

@@ -269,6 +264,28 @@ struct vsp1_rwpf *vsp1_rpf_create(struct vsp1_device *vsp1, unsigned int index)
		goto error;
	}

+	/* Initialize the video device. */
+	video = &rpf->video;
+
+	video->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	video->vsp1 = vsp1;
+	video->ops = &rpf_vdev_ops;
+
+	ret = vsp1_video_init(video, &rpf->entity);
+	if (ret < 0)
+		goto error;
+
+	rpf->entity.video = video;
+
+	/* Connect the video device to the RPF. */
+	ret = media_entity_create_link(&rpf->video.video.entity, 0,
+				       &rpf->entity.subdev.entity,
+				       RWPF_PAD_SINK,
+				       MEDIA_LNK_FL_ENABLED |
+				       MEDIA_LNK_FL_IMMUTABLE);
+	if (ret < 0)
+		goto error;
+
	return rpf;

 error:
diff --git a/drivers/media/platform/vsp1/vsp1_rwpf.h b/drivers/media/platform/vsp1/vsp1_rwpf.h
index 8e82356..f452dce 100644
--- a/drivers/media/platform/vsp1/vsp1_rwpf.h
+++ b/drivers/media/platform/vsp1/vsp1_rwpf.h
@@ -19,39 +19,19 @@

 #include "vsp1.h"
 #include "vsp1_entity.h"
+#include "vsp1_video.h"

 #define RWPF_PAD_SINK				0
 #define RWPF_PAD_SOURCE				1

-struct v4l2_ctrl;
-struct vsp1_rwpf;
-struct vsp1_video;
-
-struct vsp1_rwpf_memory {
-	unsigned int num_planes;
-	dma_addr_t addr[3];
-	unsigned int length[3];
-};
-
-struct vsp1_rwpf_operations {
-	void (*set_memory)(struct vsp1_rwpf *rwpf,
-			   struct vsp1_rwpf_memory *mem);
-};
-
 struct vsp1_rwpf {
	struct vsp1_entity entity;
+	struct vsp1_video video;
	struct v4l2_ctrl_handler ctrls;
-	struct v4l2_ctrl *alpha;
-
-	struct vsp1_video *video;
-
-	const struct vsp1_rwpf_operations *ops;

	unsigned int max_width;
	unsigned int max_height;

-	struct v4l2_pix_format_mplane format;
-	const struct vsp1_format_info *fmtinfo;
	struct {
		unsigned int left;
		unsigned int top;
diff --git a/drivers/media/platform/vsp1/vsp1_sru.c b/drivers/media/platform/vsp1/vsp1_sru.c
index cc09efb..6310aca 100644
--- a/drivers/media/platform/vsp1/vsp1_sru.c
+++ b/drivers/media/platform/vsp1/vsp1_sru.c
@@ -151,13 +151,10 @@ static int sru_s_stream(struct v4l2_subdev *subdev, int enable)
	/* Take the control handler lock to ensure that the CTRL0 value won't be
	 * changed behind our back by a set control operation.
	 */
-	if (sru->entity.vsp1->info->uapi)
-		mutex_lock(sru->ctrls.lock);
+	mutex_lock(sru->ctrls.lock);
	ctrl0 |= vsp1_sru_read(sru, VI6_SRU_CTRL0)
	       & (VI6_SRU_CTRL0_PARAM0_MASK | VI6_SRU_CTRL0_PARAM1_MASK);
-	vsp1_sru_write(sru, VI6_SRU_CTRL0, ctrl0);
-	if (sru->entity.vsp1->info->uapi)
-		mutex_unlock(sru->ctrls.lock);
+	mutex_unlock(sru->ctrls.lock);

	vsp1_sru_write(sru, VI6_SRU_CTRL1, VI6_SRU_CTRL1_PARAM5);

@@ -363,7 +360,7 @@ struct vsp1_sru *vsp1_sru_create(struct vsp1_device *vsp1)
	subdev = &sru->entity.subdev;
	v4l2_subdev_init(subdev, &sru_ops);

-	subdev->entity.ops = &vsp1->media_ops;
+	subdev->entity.ops = &vsp1_media_ops;
	subdev->internal_ops = &vsp1_subdev_internal_ops;
	snprintf(subdev->name, sizeof(subdev->name), "%s sru",
		 dev_name(vsp1->dev));
diff --git a/drivers/media/platform/vsp1/vsp1_uds.c b/drivers/media/platform/vsp1/vsp1_uds.c
index bba6777..ccc8243 100644
--- a/drivers/media/platform/vsp1/vsp1_uds.c
+++ b/drivers/media/platform/vsp1/vsp1_uds.c
@@ -29,6 +29,12 @@
  * Device Access
  */

+static inline u32 vsp1_uds_read(struct vsp1_uds *uds, u32 reg)
+{
+	return vsp1_read(uds->entity.vsp1,
+			 reg + uds->entity.index * VI6_UDS_OFFSET);
+}
+
 static inline void vsp1_uds_write(struct vsp1_uds *uds, u32 reg, u32 data)
 {
	vsp1_write(uds->entity.vsp1,
@@ -338,7 +344,7 @@ struct vsp1_uds *vsp1_uds_create(struct vsp1_device *vsp1, unsigned int index)
	subdev = &uds->entity.subdev;
	v4l2_subdev_init(subdev, &uds_ops);

-	subdev->entity.ops = &vsp1->media_ops;
+	subdev->entity.ops = &vsp1_media_ops;
	subdev->internal_ops = &vsp1_subdev_internal_ops;
	snprintf(subdev->name, sizeof(subdev->name), "%s uds.%u",
		 dev_name(vsp1->dev), index);
diff --git a/drivers/media/platform/vsp1/vsp1_video.c b/drivers/media/platform/vsp1/vsp1_video.c
index 682e5b6..5ce88e1 100644
--- a/drivers/media/platform/vsp1/vsp1_video.c
+++ b/drivers/media/platform/vsp1/vsp1_video.c
@@ -30,7 +30,6 @@
 #include "vsp1.h"
 #include "vsp1_bru.h"
 #include "vsp1_entity.h"
-#include "vsp1_pipe.h"
 #include "vsp1_rwpf.h"
 #include "vsp1_uds.h"
 #include "vsp1_video.h"
@@ -48,6 +47,113 @@
  * Helper functions
  */

+static const struct vsp1_format_info vsp1_video_formats[] = {
+	{ V4L2_PIX_FMT_RGB332, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_RGB_332, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  1, { 8, 0, 0 }, false, false, 1, 1, false },
+	{ V4L2_PIX_FMT_ARGB444, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_ARGB_4444, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS,
+	  1, { 16, 0, 0 }, false, false, 1, 1, true },
+	{ V4L2_PIX_FMT_XRGB444, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_XRGB_4444, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS,
+	  1, { 16, 0, 0 }, false, false, 1, 1, true },
+	{ V4L2_PIX_FMT_ARGB555, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_ARGB_1555, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS,
+	  1, { 16, 0, 0 }, false, false, 1, 1, true },
+	{ V4L2_PIX_FMT_XRGB555, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_XRGB_1555, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS,
+	  1, { 16, 0, 0 }, false, false, 1, 1, false },
+	{ V4L2_PIX_FMT_RGB565, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_RGB_565, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS,
+	  1, { 16, 0, 0 }, false, false, 1, 1, false },
+	{ V4L2_PIX_FMT_BGR24, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_BGR_888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  1, { 24, 0, 0 }, false, false, 1, 1, false },
+	{ V4L2_PIX_FMT_RGB24, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_RGB_888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  1, { 24, 0, 0 }, false, false, 1, 1, false },
+	{ V4L2_PIX_FMT_ABGR32, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_ARGB_8888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS,
+	  1, { 32, 0, 0 }, false, false, 1, 1, true },
+	{ V4L2_PIX_FMT_XBGR32, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_ARGB_8888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS,
+	  1, { 32, 0, 0 }, false, false, 1, 1, false },
+	{ V4L2_PIX_FMT_ARGB32, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_ARGB_8888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  1, { 32, 0, 0 }, false, false, 1, 1, true },
+	{ V4L2_PIX_FMT_XRGB32, MEDIA_BUS_FMT_ARGB8888_1X32,
+	  VI6_FMT_ARGB_8888, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  1, { 32, 0, 0 }, false, false, 1, 1, false },
+	{ V4L2_PIX_FMT_UYVY, MEDIA_BUS_FMT_AYUV8_1X32,
+	  VI6_FMT_YUYV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  1, { 16, 0, 0 }, false, false, 2, 1, false },
+	{ V4L2_PIX_FMT_VYUY, MEDIA_BUS_FMT_AYUV8_1X32,
+	  VI6_FMT_YUYV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  1, { 16, 0, 0 }, false, true, 2, 1, false },
+	{ V4L2_PIX_FMT_YUYV, MEDIA_BUS_FMT_AYUV8_1X32,
+	  VI6_FMT_YUYV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  1, { 16, 0, 0 }, true, false, 2, 1, false },
+	{ V4L2_PIX_FMT_YVYU, MEDIA_BUS_FMT_AYUV8_1X32,
+	  VI6_FMT_YUYV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  1, { 16, 0, 0 }, true, true, 2, 1, false },
+	{ V4L2_PIX_FMT_NV12M, MEDIA_BUS_FMT_AYUV8_1X32,
+	  VI6_FMT_Y_UV_420, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  2, { 8, 16, 0 }, false, false, 2, 2, false },
+	{ V4L2_PIX_FMT_NV21M, MEDIA_BUS_FMT_AYUV8_1X32,
+	  VI6_FMT_Y_UV_420, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  2, { 8, 16, 0 }, false, true, 2, 2, false },
+	{ V4L2_PIX_FMT_NV16M, MEDIA_BUS_FMT_AYUV8_1X32,
+	  VI6_FMT_Y_UV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  2, { 8, 16, 0 }, false, false, 2, 1, false },
+	{ V4L2_PIX_FMT_NV61M, MEDIA_BUS_FMT_AYUV8_1X32,
+	  VI6_FMT_Y_UV_422, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  2, { 8, 16, 0 }, false, true, 2, 1, false },
+	{ V4L2_PIX_FMT_YUV420M, MEDIA_BUS_FMT_AYUV8_1X32,
+	  VI6_FMT_Y_U_V_420, VI6_RPF_DSWAP_P_LLS | VI6_RPF_DSWAP_P_LWS |
+	  VI6_RPF_DSWAP_P_WDS | VI6_RPF_DSWAP_P_BTS,
+	  3, { 8, 8, 8 }, false, false, 2, 2, false },
+};
+
+/*
+ * vsp1_get_format_info - Retrieve format information for a 4CC
+ * @fourcc: the format 4CC
+ *
+ * Return a pointer to the format information structure corresponding to the
+ * given V4L2 format 4CC, or NULL if no corresponding format can be found.
+ */
+static const struct vsp1_format_info *vsp1_get_format_info(u32 fourcc)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(vsp1_video_formats); ++i) {
+		const struct vsp1_format_info *info = &vsp1_video_formats[i];
+
+		if (info->fourcc == fourcc)
+			return info;
+	}
+
+	return NULL;
+}
+
+
 static struct v4l2_subdev *
 vsp1_video_remote_subdev(struct media_pad *local, u32 *pad)
 {
@@ -79,9 +185,9 @@ static int vsp1_video_verify_format(struct vsp1_video *video)
	if (ret < 0)
		return ret == -ENOIOCTLCMD ? -EINVAL : ret;

-	if (video->rwpf->fmtinfo->mbus != fmt.format.code ||
-	    video->rwpf->format.height != fmt.format.height ||
-	    video->rwpf->format.width != fmt.format.width)
+	if (video->fmtinfo->mbus != fmt.format.code ||
+	    video->format.height != fmt.format.height ||
+	    video->format.width != fmt.format.width)
		return -EINVAL;

	return 0;
@@ -201,9 +307,9 @@ vsp1_video_format_adjust(struct vsp1_video *video,
  * Pipeline Management
  */

-static int vsp1_video_pipeline_validate_branch(struct vsp1_pipeline *pipe,
-					       struct vsp1_rwpf *input,
-					       struct vsp1_rwpf *output)
+static int vsp1_pipeline_validate_branch(struct vsp1_pipeline *pipe,
+					 struct vsp1_rwpf *input,
+					 struct vsp1_rwpf *output)
 {
	struct vsp1_entity *entity;
	unsigned int entities = 0;
@@ -277,8 +383,29 @@ static int vsp1_video_pipeline_validate_branch(struct vsp1_pipeline *pipe,
	return 0;
 }

-static int vsp1_video_pipeline_validate(struct vsp1_pipeline *pipe,
-					struct vsp1_video *video)
+static void __vsp1_pipeline_cleanup(struct vsp1_pipeline *pipe)
+{
+	if (pipe->bru) {
+		struct vsp1_bru *bru = to_bru(&pipe->bru->subdev);
+		unsigned int i;
+
+		for (i = 0; i < ARRAY_SIZE(bru->inputs); ++i)
+			bru->inputs[i].rpf = NULL;
+	}
+
+	INIT_LIST_HEAD(&pipe->entities);
+	pipe->state = VSP1_PIPELINE_STOPPED;
+	pipe->buffers_ready = 0;
+	pipe->num_video = 0;
+	pipe->num_inputs = 0;
+	pipe->output = NULL;
+	pipe->bru = NULL;
+	pipe->lif = NULL;
+	pipe->uds = NULL;
+}
+
+static int vsp1_pipeline_validate(struct vsp1_pipeline *pipe,
+				  struct vsp1_video *video)
 {
	struct media_entity_graph graph;
	struct media_entity *entity = &video->video.entity;
@@ -296,8 +423,10 @@ static int vsp1_video_pipeline_validate(struct vsp1_pipeline *pipe,
		struct vsp1_rwpf *rwpf;
		struct vsp1_entity *e;

-		if (media_entity_type(entity) != MEDIA_ENT_T_V4L2_SUBDEV)
+		if (media_entity_type(entity) != MEDIA_ENT_T_V4L2_SUBDEV) {
+			pipe->num_video++;
			continue;
+		}

		subdev = media_entity_to_v4l2_subdev(entity);
		e = to_vsp1_entity(subdev);
@@ -305,12 +434,12 @@ static int vsp1_video_pipeline_validate(struct vsp1_pipeline *pipe,

		if (e->type == VSP1_ENTITY_RPF) {
			rwpf = to_rwpf(subdev);
-			pipe->inputs[rwpf->entity.index] = rwpf;
-			rwpf->video->pipe_index = ++pipe->num_inputs;
+			pipe->inputs[pipe->num_inputs++] = rwpf;
+			rwpf->video.pipe_index = pipe->num_inputs;
		} else if (e->type == VSP1_ENTITY_WPF) {
			rwpf = to_rwpf(subdev);
-			pipe->output = rwpf;
-			rwpf->video->pipe_index = 0;
+			pipe->output = to_rwpf(subdev);
+			rwpf->video.pipe_index = 0;
		} else if (e->type == VSP1_ENTITY_LIF) {
			pipe->lif = e;
		} else if (e->type == VSP1_ENTITY_BRU) {
@@ -329,12 +458,9 @@ static int vsp1_video_pipeline_validate(struct vsp1_pipeline *pipe,
	/* Follow links downstream for each input and make sure the graph
	 * contains no loop and that all branches end at the output WPF.
	 */
-	for (i = 0; i < video->vsp1->info->rpf_count; ++i) {
-		if (!pipe->inputs[i])
-			continue;
-
-		ret = vsp1_video_pipeline_validate_branch(pipe, pipe->inputs[i],
-							  pipe->output);
+	for (i = 0; i < pipe->num_inputs; ++i) {
+		ret = vsp1_pipeline_validate_branch(pipe, pipe->inputs[i],
+						    pipe->output);
		if (ret < 0)
			goto error;
	}
@@ -342,12 +468,12 @@ static int vsp1_video_pipeline_validate(struct vsp1_pipeline *pipe,
	return 0;

 error:
-	vsp1_pipeline_reset(pipe);
+	__vsp1_pipeline_cleanup(pipe);
	return ret;
 }

-static int vsp1_video_pipeline_init(struct vsp1_pipeline *pipe,
-				    struct vsp1_video *video)
+static int vsp1_pipeline_init(struct vsp1_pipeline *pipe,
+			      struct vsp1_video *video)
 {
	int ret;

@@ -355,7 +481,7 @@ static int vsp1_video_pipeline_init(struct vsp1_pipeline *pipe,

	/* If we're the first user validate and initialize the pipeline. */
	if (pipe->use_count == 0) {
-		ret = vsp1_video_pipeline_validate(pipe, video);
+		ret = vsp1_pipeline_validate(pipe, video);
		if (ret < 0)
			goto done;
	}
@@ -368,17 +494,75 @@ done:
	return ret;
 }

-static void vsp1_video_pipeline_cleanup(struct vsp1_pipeline *pipe)
+static void vsp1_pipeline_cleanup(struct vsp1_pipeline *pipe)
 {
	mutex_lock(&pipe->lock);

	/* If we're the last user clean up the pipeline. */
	if (--pipe->use_count == 0)
-		vsp1_pipeline_reset(pipe);
+		__vsp1_pipeline_cleanup(pipe);

	mutex_unlock(&pipe->lock);
 }

+static void vsp1_pipeline_run(struct vsp1_pipeline *pipe)
+{
+	struct vsp1_device *vsp1 = pipe->output->entity.vsp1;
+
+	vsp1_write(vsp1, VI6_CMD(pipe->output->entity.index), VI6_CMD_STRCMD);
+	pipe->state = VSP1_PIPELINE_RUNNING;
+	pipe->buffers_ready = 0;
+}
+
+static bool vsp1_pipeline_stopped(struct vsp1_pipeline *pipe)
+{
+	unsigned long flags;
+	bool stopped;
+
+	spin_lock_irqsave(&pipe->irqlock, flags);
+	stopped = pipe->state == VSP1_PIPELINE_STOPPED,
+	spin_unlock_irqrestore(&pipe->irqlock, flags);
+
+	return stopped;
+}
+
+static int vsp1_pipeline_stop(struct vsp1_pipeline *pipe)
+{
+	struct vsp1_entity *entity;
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&pipe->irqlock, flags);
+	if (pipe->state == VSP1_PIPELINE_RUNNING)
+		pipe->state = VSP1_PIPELINE_STOPPING;
+	spin_unlock_irqrestore(&pipe->irqlock, flags);
+
+	ret = wait_event_timeout(pipe->wq, vsp1_pipeline_stopped(pipe),
+				 msecs_to_jiffies(500));
+	ret = ret == 0 ? -ETIMEDOUT : 0;
+
+	list_for_each_entry(entity, &pipe->entities, list_pipe) {
+		if (entity->route && entity->route->reg)
+			vsp1_write(entity->vsp1, entity->route->reg,
+				   VI6_DPR_NODE_UNUSED);
+
+		v4l2_subdev_call(&entity->subdev, video, s_stream, 0);
+	}
+
+	return ret;
+}
+
+static bool vsp1_pipeline_ready(struct vsp1_pipeline *pipe)
+{
+	unsigned int mask;
+
+	mask = ((1 << pipe->num_inputs) - 1) << 1;
+	if (!pipe->lif)
+		mask |= 1 << 0;
+
+	return pipe->buffers_ready == mask;
+}
+
 /*
  * vsp1_video_complete_buffer - Complete the current buffer
  * @video: the video node
@@ -393,12 +577,12 @@ static void vsp1_video_pipeline_cleanup(struct vsp1_pipeline *pipe)
  *
  * Return the next queued buffer or NULL if the queue is empty.
  */
-static struct vsp1_vb2_buffer *
+static struct vsp1_video_buffer *
 vsp1_video_complete_buffer(struct vsp1_video *video)
 {
	struct vsp1_pipeline *pipe = to_vsp1_pipeline(&video->video.entity);
-	struct vsp1_vb2_buffer *next = NULL;
-	struct vsp1_vb2_buffer *done;
+	struct vsp1_video_buffer *next = NULL;
+	struct vsp1_video_buffer *done;
	unsigned long flags;
	unsigned int i;

@@ -410,7 +594,7 @@ vsp1_video_complete_buffer(struct vsp1_video *video)
	}

	done = list_first_entry(&video->irqqueue,
-				struct vsp1_vb2_buffer, queue);
+				struct vsp1_video_buffer, queue);

	/* In DU output mode reuse the buffer if the list is singular. */
	if (pipe->lif && list_is_singular(&video->irqqueue)) {
@@ -422,25 +606,23 @@ vsp1_video_complete_buffer(struct vsp1_video *video)

	if (!list_empty(&video->irqqueue))
		next = list_first_entry(&video->irqqueue,
-					struct vsp1_vb2_buffer, queue);
+					struct vsp1_video_buffer, queue);

	spin_unlock_irqrestore(&video->irqlock, flags);

	done->buf.sequence = video->sequence++;
	v4l2_get_timestamp(&done->buf.timestamp);
	for (i = 0; i < done->buf.vb2_buf.num_planes; ++i)
-		vb2_set_plane_payload(&done->buf.vb2_buf, i,
-				      done->mem.length[i]);
+		vb2_set_plane_payload(&done->buf.vb2_buf, i, done->length[i]);
	vb2_buffer_done(&done->buf.vb2_buf, VB2_BUF_STATE_DONE);

	return next;
 }

 static void vsp1_video_frame_end(struct vsp1_pipeline *pipe,
-				 struct vsp1_rwpf *rwpf)
+				 struct vsp1_video *video)
 {
-	struct vsp1_video *video = rwpf->video;
-	struct vsp1_vb2_buffer *buf;
+	struct vsp1_video_buffer *buf;
	unsigned long flags;

	buf = vsp1_video_complete_buffer(video);
@@ -449,27 +631,155 @@ static void vsp1_video_frame_end(struct vsp1_pipeline *pipe,

	spin_lock_irqsave(&pipe->irqlock, flags);

-	video->rwpf->ops->set_memory(video->rwpf, &buf->mem);
+	video->ops->queue(video, buf);
	pipe->buffers_ready |= 1 << video->pipe_index;

	spin_unlock_irqrestore(&pipe->irqlock, flags);
 }

-static void vsp1_video_pipeline_frame_end(struct vsp1_pipeline *pipe)
+void vsp1_pipeline_frame_end(struct vsp1_pipeline *pipe)
 {
-	struct vsp1_device *vsp1 = pipe->output->entity.vsp1;
+	enum vsp1_pipeline_state state;
+	unsigned long flags;
	unsigned int i;

+	if (pipe == NULL)
+		return;
+
	/* Complete buffers on all video nodes. */
-	for (i = 0; i < vsp1->info->rpf_count; ++i) {
-		if (!pipe->inputs[i])
+	for (i = 0; i < pipe->num_inputs; ++i)
+		vsp1_video_frame_end(pipe, &pipe->inputs[i]->video);
+
+	if (!pipe->lif)
+		vsp1_video_frame_end(pipe, &pipe->output->video);
+
+	spin_lock_irqsave(&pipe->irqlock, flags);
+
+	state = pipe->state;
+	pipe->state = VSP1_PIPELINE_STOPPED;
+
+	/* If a stop has been requested, mark the pipeline as stopped and
+	 * return.
+	 */
+	if (state == VSP1_PIPELINE_STOPPING) {
+		wake_up(&pipe->wq);
+		goto done;
+	}
+
+	/* Restart the pipeline if ready. */
+	if (vsp1_pipeline_ready(pipe))
+		vsp1_pipeline_run(pipe);
+
+done:
+	spin_unlock_irqrestore(&pipe->irqlock, flags);
+}
+
+/*
+ * Propagate the alpha value through the pipeline.
+ *
+ * As the UDS has restricted scaling capabilities when the alpha component needs
+ * to be scaled, we disable alpha scaling when the UDS input has a fixed alpha
+ * value. The UDS then outputs a fixed alpha value which needs to be programmed
+ * from the input RPF alpha.
+ */
+void vsp1_pipeline_propagate_alpha(struct vsp1_pipeline *pipe,
+				   struct vsp1_entity *input,
+				   unsigned int alpha)
+{
+	struct vsp1_entity *entity;
+	struct media_pad *pad;
+
+	pad = media_entity_remote_pad(&input->pads[RWPF_PAD_SOURCE]);
+
+	while (pad) {
+		if (media_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)
+			break;
+
+		entity = to_vsp1_entity(media_entity_to_v4l2_subdev(pad->entity));
+
+		/* The BRU background color has a fixed alpha value set to 255,
+		 * the output alpha value is thus always equal to 255.
+		 */
+		if (entity->type == VSP1_ENTITY_BRU)
+			alpha = 255;
+
+		if (entity->type == VSP1_ENTITY_UDS) {
+			struct vsp1_uds *uds = to_uds(&entity->subdev);
+
+			vsp1_uds_set_alpha(uds, alpha);
+			break;
+		}
+
+		pad = &entity->pads[entity->source_pad];
+		pad = media_entity_remote_pad(pad);
+	}
+}
+
+void vsp1_pipelines_suspend(struct vsp1_device *vsp1)
+{
+	unsigned long flags;
+	unsigned int i;
+	int ret;
+
+	/* To avoid increasing the system suspend time needlessly, loop over the
+	 * pipelines twice, first to set them all to the stopping state, and then
+	 * to wait for the stop to complete.
+	 */
+	for (i = 0; i < vsp1->pdata.wpf_count; ++i) {
+		struct vsp1_rwpf *wpf = vsp1->wpf[i];
+		struct vsp1_pipeline *pipe;
+
+		if (wpf == NULL)
			continue;

-		vsp1_video_frame_end(pipe, pipe->inputs[i]);
+		pipe = to_vsp1_pipeline(&wpf->entity.subdev.entity);
+		if (pipe == NULL)
+			continue;
+
+		spin_lock_irqsave(&pipe->irqlock, flags);
+		if (pipe->state == VSP1_PIPELINE_RUNNING)
+			pipe->state = VSP1_PIPELINE_STOPPING;
+		spin_unlock_irqrestore(&pipe->irqlock, flags);
	}

-	if (!pipe->lif)
-		vsp1_video_frame_end(pipe, pipe->output);
+	for (i = 0; i < vsp1->pdata.wpf_count; ++i) {
+		struct vsp1_rwpf *wpf = vsp1->wpf[i];
+		struct vsp1_pipeline *pipe;
+
+		if (wpf == NULL)
+			continue;
+
+		pipe = to_vsp1_pipeline(&wpf->entity.subdev.entity);
+		if (pipe == NULL)
+			continue;
+
+		ret = wait_event_timeout(pipe->wq, vsp1_pipeline_stopped(pipe),
+					 msecs_to_jiffies(500));
+		if (ret == 0)
+			dev_warn(vsp1->dev, "pipeline %u stop timeout\n",
+				 wpf->entity.index);
+	}
+}
+
+void vsp1_pipelines_resume(struct vsp1_device *vsp1)
+{
+	unsigned int i;
+
+	/* Resume pipeline all running pipelines. */
+	for (i = 0; i < vsp1->pdata.wpf_count; ++i) {
+		struct vsp1_rwpf *wpf = vsp1->wpf[i];
+		struct vsp1_pipeline *pipe;
+
+		if (wpf == NULL)
+			continue;
+
+		pipe = to_vsp1_pipeline(&wpf->entity.subdev.entity);
+		if (pipe == NULL)
+			continue;
+
+		if (vsp1_pipeline_ready(pipe))
+			vsp1_pipeline_run(pipe);
+	}
 }

 /* -----------------------------------------------------------------------------
@@ -496,7 +806,7 @@ vsp1_video_queue_setup(struct vb2_queue *vq, const void *parg,

		format = &pix_mp;
	} else {
-		format = &video->rwpf->format;
+		format = &video->format;
	}

	*nplanes = format->num_planes;
@@ -513,20 +823,18 @@ static int vsp1_video_buffer_prepare(struct vb2_buffer *vb)
 {
	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
	struct vsp1_video *video = vb2_get_drv_priv(vb->vb2_queue);
-	struct vsp1_vb2_buffer *buf = to_vsp1_vb2_buffer(vbuf);
-	const struct v4l2_pix_format_mplane *format = &video->rwpf->format;
+	struct vsp1_video_buffer *buf = to_vsp1_video_buffer(vbuf);
+	const struct v4l2_pix_format_mplane *format = &video->format;
	unsigned int i;

	if (vb->num_planes < format->num_planes)
		return -EINVAL;

-	buf->mem.num_planes = vb->num_planes;
-
	for (i = 0; i < vb->num_planes; ++i) {
-		buf->mem.addr[i] = vb2_dma_contig_plane_dma_addr(vb, i);
-		buf->mem.length[i] = vb2_plane_size(vb, i);
+		buf->addr[i] = vb2_dma_contig_plane_dma_addr(vb, i);
+		buf->length[i] = vb2_plane_size(vb, i);

-		if (buf->mem.length[i] < format->plane_fmt[i].sizeimage)
+		if (buf->length[i] < format->plane_fmt[i].sizeimage)
			return -EINVAL;
	}

@@ -538,7 +846,7 @@ static void vsp1_video_buffer_queue(struct vb2_buffer *vb)
	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
	struct vsp1_video *video = vb2_get_drv_priv(vb->vb2_queue);
	struct vsp1_pipeline *pipe = to_vsp1_pipeline(&video->video.entity);
-	struct vsp1_vb2_buffer *buf = to_vsp1_vb2_buffer(vbuf);
+	struct vsp1_video_buffer *buf = to_vsp1_video_buffer(vbuf);
	unsigned long flags;
	bool empty;

@@ -552,7 +860,7 @@ static void vsp1_video_buffer_queue(struct vb2_buffer *vb)

	spin_lock_irqsave(&pipe->irqlock, flags);

-	video->rwpf->ops->set_memory(video->rwpf, &buf->mem);
+	video->ops->queue(video, buf);
	pipe->buffers_ready |= 1 << video->pipe_index;

	if (vb2_is_streaming(&video->queue) &&
@@ -562,6 +870,18 @@ static void vsp1_video_buffer_queue(struct vb2_buffer *vb)
	spin_unlock_irqrestore(&pipe->irqlock, flags);
 }

+static void vsp1_entity_route_setup(struct vsp1_entity *source)
+{
+	struct vsp1_entity *sink;
+
+	if (source->route->reg == 0)
+		return;
+
+	sink = container_of(source->sink, struct vsp1_entity, subdev.entity);
+	vsp1_write(source->vsp1, source->route->reg,
+		   sink->route->inputs[source->sink_pad]);
+}
+
 static int vsp1_video_start_streaming(struct vb2_queue *vq, unsigned int count)
 {
	struct vsp1_video *video = vb2_get_drv_priv(vq);
@@ -571,7 +891,7 @@ static int vsp1_video_start_streaming(struct vb2_queue *vq, unsigned int count)
	int ret;

	mutex_lock(&pipe->lock);
-	if (pipe->stream_count == pipe->num_inputs) {
+	if (pipe->stream_count == pipe->num_video - 1) {
		if (pipe->uds) {
			struct vsp1_uds *uds = to_uds(&pipe->uds->subdev);

@@ -587,7 +907,7 @@ static int vsp1_video_start_streaming(struct vb2_queue *vq, unsigned int count)
				struct vsp1_rwpf *rpf =
					to_rwpf(&pipe->uds_input->subdev);

-				uds->scale_alpha = rpf->fmtinfo->alpha;
+				uds->scale_alpha = rpf->video.fmtinfo->alpha;
			}
		}

@@ -618,7 +938,7 @@ static void vsp1_video_stop_streaming(struct vb2_queue *vq)
 {
	struct vsp1_video *video = vb2_get_drv_priv(vq);
	struct vsp1_pipeline *pipe = to_vsp1_pipeline(&video->video.entity);
-	struct vsp1_vb2_buffer *buffer;
+	struct vsp1_video_buffer *buffer;
	unsigned long flags;
	int ret;

@@ -631,7 +951,7 @@ static void vsp1_video_stop_streaming(struct vb2_queue *vq)
	}
	mutex_unlock(&pipe->lock);

-	vsp1_video_pipeline_cleanup(pipe);
+	vsp1_pipeline_cleanup(pipe);
	media_entity_pipeline_stop(&video->video.entity);

	/* Remove all buffers from the IRQ queue. */
@@ -691,7 +1011,7 @@ vsp1_video_get_format(struct file *file, void *fh, struct v4l2_format *format)
		return -EINVAL;

	mutex_lock(&video->lock);
-	format->fmt.pix_mp = video->rwpf->format;
+	format->fmt.pix_mp = video->format;
	mutex_unlock(&video->lock);

	return 0;
@@ -731,8 +1051,8 @@ vsp1_video_set_format(struct file *file, void *fh, struct v4l2_format *format)
		goto done;
	}

-	video->rwpf->format = format->fmt.pix_mp;
-	video->rwpf->fmtinfo = info;
+	video->format = format->fmt.pix_mp;
+	video->fmtinfo = info;

 done:
	mutex_unlock(&video->lock);
@@ -772,7 +1092,7 @@ vsp1_video_streamon(struct file *file, void *fh, enum v4l2_buf_type type)
	if (ret < 0)
		goto err_stop;

-	ret = vsp1_video_pipeline_init(pipe, video);
+	ret = vsp1_pipeline_init(pipe, video);
	if (ret < 0)
		goto err_stop;

@@ -784,7 +1104,7 @@ vsp1_video_streamon(struct file *file, void *fh, enum v4l2_buf_type type)
	return 0;

 err_cleanup:
-	vsp1_video_pipeline_cleanup(pipe);
+	vsp1_pipeline_cleanup(pipe);
 err_stop:
	media_entity_pipeline_stop(&video->video.entity);
	return ret;
@@ -870,64 +1190,62 @@ static struct v4l2_file_operations vsp1_video_fops = {
  * Initialization and Cleanup
  */

-struct vsp1_video *vsp1_video_create(struct vsp1_device *vsp1,
-				     struct vsp1_rwpf *rwpf)
+int vsp1_video_init(struct vsp1_video *video, struct vsp1_entity *rwpf)
 {
-	struct vsp1_video *video;
	const char *direction;
	int ret;

-	video = devm_kzalloc(vsp1->dev, sizeof(*video), GFP_KERNEL);
-	if (!video)
-		return ERR_PTR(-ENOMEM);
-
-	rwpf->video = video;
-
-	video->vsp1 = vsp1;
-	video->rwpf = rwpf;
+	switch (video->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+		direction = "output";
+		video->pad.flags = MEDIA_PAD_FL_SINK;
+		break;

-	if (rwpf->entity.type == VSP1_ENTITY_RPF) {
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
		direction = "input";
-		video->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
		video->pad.flags = MEDIA_PAD_FL_SOURCE;
		video->video.vfl_dir = VFL_DIR_TX;
-	} else {
-		direction = "output";
-		video->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
-		video->pad.flags = MEDIA_PAD_FL_SINK;
-		video->video.vfl_dir = VFL_DIR_RX;
+		break;
+
+	default:
+		return -EINVAL;
	}

+	video->rwpf = rwpf;
+
	mutex_init(&video->lock);
	spin_lock_init(&video->irqlock);
	INIT_LIST_HEAD(&video->irqqueue);

-	vsp1_pipeline_init(&video->pipe);
-	video->pipe.frame_end = vsp1_video_pipeline_frame_end;
+	mutex_init(&video->pipe.lock);
+	spin_lock_init(&video->pipe.irqlock);
+	INIT_LIST_HEAD(&video->pipe.entities);
+	init_waitqueue_head(&video->pipe.wq);
+	video->pipe.state = VSP1_PIPELINE_STOPPED;

	/* Initialize the media entity... */
	ret = media_entity_init(&video->video.entity, 1, &video->pad, 0);
	if (ret < 0)
-		return ERR_PTR(ret);
+		return ret;

	/* ... and the format ... */
-	rwpf->fmtinfo = vsp1_get_format_info(VSP1_VIDEO_DEF_FORMAT);
-	rwpf->format.pixelformat = rwpf->fmtinfo->fourcc;
-	rwpf->format.colorspace = V4L2_COLORSPACE_SRGB;
-	rwpf->format.field = V4L2_FIELD_NONE;
-	rwpf->format.width = VSP1_VIDEO_DEF_WIDTH;
-	rwpf->format.height = VSP1_VIDEO_DEF_HEIGHT;
-	rwpf->format.num_planes = 1;
-	rwpf->format.plane_fmt[0].bytesperline =
-		rwpf->format.width * rwpf->fmtinfo->bpp[0] / 8;
-	rwpf->format.plane_fmt[0].sizeimage =
-		rwpf->format.plane_fmt[0].bytesperline * rwpf->format.height;
+	video->fmtinfo = vsp1_get_format_info(VSP1_VIDEO_DEF_FORMAT);
+	video->format.pixelformat = video->fmtinfo->fourcc;
+	video->format.colorspace = V4L2_COLORSPACE_SRGB;
+	video->format.field = V4L2_FIELD_NONE;
+	video->format.width = VSP1_VIDEO_DEF_WIDTH;
+	video->format.height = VSP1_VIDEO_DEF_HEIGHT;
+	video->format.num_planes = 1;
+	video->format.plane_fmt[0].bytesperline =
+		video->format.width * video->fmtinfo->bpp[0] / 8;
+	video->format.plane_fmt[0].sizeimage =
+		video->format.plane_fmt[0].bytesperline * video->format.height;

	/* ... and the video node... */
	video->video.v4l2_dev = &video->vsp1->v4l2_dev;
	video->video.fops = &vsp1_video_fops;
	snprintf(video->video.name, sizeof(video->video.name), "%s %s",
-		 rwpf->entity.subdev.name, direction);
+		 rwpf->subdev.name, direction);
	video->video.vfl_type = VFL_TYPE_GRABBER;
	video->video.release = video_device_release_empty;
	video->video.ioctl_ops = &vsp1_video_ioctl_ops;
@@ -945,7 +1263,7 @@ struct vsp1_video *vsp1_video_create(struct vsp1_device *vsp1,
	video->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
	video->queue.lock = &video->lock;
	video->queue.drv_priv = video;
-	video->queue.buf_struct_size = sizeof(struct vsp1_vb2_buffer);
+	video->queue.buf_struct_size = sizeof(struct vsp1_video_buffer);
	video->queue.ops = &vsp1_video_queue_qops;
	video->queue.mem_ops = &vb2_dma_contig_memops;
	video->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
@@ -963,12 +1281,12 @@ struct vsp1_video *vsp1_video_create(struct vsp1_device *vsp1,
		goto error;
	}

-	return video;
+	return 0;

 error:
	vb2_dma_contig_cleanup_ctx(video->alloc_ctx);
	vsp1_video_cleanup(video);
-	return ERR_PTR(ret);
+	return ret;
 }

 void vsp1_video_cleanup(struct vsp1_video *video)
diff --git a/drivers/media/platform/vsp1/vsp1_video.h b/drivers/media/platform/vsp1/vsp1_video.h
index 64abd39..a929aa8 100644
--- a/drivers/media/platform/vsp1/vsp1_video.h
+++ b/drivers/media/platform/vsp1/vsp1_video.h
@@ -15,34 +15,115 @@

 #include <linux/list.h>
 #include <linux/spinlock.h>
+#include <linux/wait.h>

+#include <media/media-entity.h>
 #include <media/videobuf2-v4l2.h>

-#include "vsp1_pipe.h"
-#include "vsp1_rwpf.h"
+struct vsp1_video;

-struct vsp1_vb2_buffer {
+/*
+ * struct vsp1_format_info - VSP1 video format description
+ * @mbus: media bus format code
+ * @fourcc: V4L2 pixel format FCC identifier
+ * @planes: number of planes
+ * @bpp: bits per pixel
+ * @hwfmt: VSP1 hardware format
+ * @swap_yc: the Y and C components are swapped (Y comes before C)
+ * @swap_uv: the U and V components are swapped (V comes before U)
+ * @hsub: horizontal subsampling factor
+ * @vsub: vertical subsampling factor
+ * @alpha: has an alpha channel
+ */
+struct vsp1_format_info {
+	u32 fourcc;
+	unsigned int mbus;
+	unsigned int hwfmt;
+	unsigned int swap;
+	unsigned int planes;
+	unsigned int bpp[3];
+	bool swap_yc;
+	bool swap_uv;
+	unsigned int hsub;
+	unsigned int vsub;
+	bool alpha;
+};
+
+enum vsp1_pipeline_state {
+	VSP1_PIPELINE_STOPPED,
+	VSP1_PIPELINE_RUNNING,
+	VSP1_PIPELINE_STOPPING,
+};
+
+/*
+ * struct vsp1_pipeline - A VSP1 hardware pipeline
+ * @media: the media pipeline
+ * @irqlock: protects the pipeline state
+ * @lock: protects the pipeline use count and stream count
+ */
+struct vsp1_pipeline {
+	struct media_pipeline pipe;
+
+	spinlock_t irqlock;
+	enum vsp1_pipeline_state state;
+	wait_queue_head_t wq;
+
+	struct mutex lock;
+	unsigned int use_count;
+	unsigned int stream_count;
+	unsigned int buffers_ready;
+
+	unsigned int num_video;
+	unsigned int num_inputs;
+	struct vsp1_rwpf *inputs[VSP1_MAX_RPF];
+	struct vsp1_rwpf *output;
+	struct vsp1_entity *bru;
+	struct vsp1_entity *lif;
+	struct vsp1_entity *uds;
+	struct vsp1_entity *uds_input;
+
+	struct list_head entities;
+};
+
+static inline struct vsp1_pipeline *to_vsp1_pipeline(struct media_entity *e)
+{
+	if (likely(e->pipe))
+		return container_of(e->pipe, struct vsp1_pipeline, pipe);
+	else
+		return NULL;
+}
+
+struct vsp1_video_buffer {
	struct vb2_v4l2_buffer buf;
	struct list_head queue;
-	struct vsp1_rwpf_memory mem;
+
+	dma_addr_t addr[3];
+	unsigned int length[3];
 };

-static inline struct vsp1_vb2_buffer *
-to_vsp1_vb2_buffer(struct vb2_v4l2_buffer *vbuf)
+static inline struct vsp1_video_buffer *
+to_vsp1_video_buffer(struct vb2_v4l2_buffer *vbuf)
 {
-	return container_of(vbuf, struct vsp1_vb2_buffer, buf);
+	return container_of(vbuf, struct vsp1_video_buffer, buf);
 }

+struct vsp1_video_operations {
+	void (*queue)(struct vsp1_video *video, struct vsp1_video_buffer *buf);
+};
+
 struct vsp1_video {
-	struct list_head list;
	struct vsp1_device *vsp1;
-	struct vsp1_rwpf *rwpf;
+	struct vsp1_entity *rwpf;
+
+	const struct vsp1_video_operations *ops;

	struct video_device video;
	enum v4l2_buf_type type;
	struct media_pad pad;

	struct mutex lock;
+	struct v4l2_pix_format_mplane format;
+	const struct vsp1_format_info *fmtinfo;

	struct vsp1_pipeline pipe;
	unsigned int pipe_index;
@@ -59,8 +140,16 @@ static inline struct vsp1_video *to_vsp1_video(struct video_device *vdev)
	return container_of(vdev, struct vsp1_video, video);
 }

-struct vsp1_video *vsp1_video_create(struct vsp1_device *vsp1,
-				     struct vsp1_rwpf *rwpf);
+int vsp1_video_init(struct vsp1_video *video, struct vsp1_entity *rwpf);
 void vsp1_video_cleanup(struct vsp1_video *video);

+void vsp1_pipeline_frame_end(struct vsp1_pipeline *pipe);
+
+void vsp1_pipeline_propagate_alpha(struct vsp1_pipeline *pipe,
+				   struct vsp1_entity *input,
+				   unsigned int alpha);
+
+void vsp1_pipelines_suspend(struct vsp1_device *vsp1);
+void vsp1_pipelines_resume(struct vsp1_device *vsp1);
+
 #endif /* __VSP1_VIDEO_H__ */
diff --git a/drivers/media/platform/vsp1/vsp1_wpf.c b/drivers/media/platform/vsp1/vsp1_wpf.c
index c78d4af..95b62f4 100644
--- a/drivers/media/platform/vsp1/vsp1_wpf.c
+++ b/drivers/media/platform/vsp1/vsp1_wpf.c
@@ -34,8 +34,8 @@ static inline u32 vsp1_wpf_read(struct vsp1_rwpf *wpf, u32 reg)

 static inline void vsp1_wpf_write(struct vsp1_rwpf *wpf, u32 reg, u32 data)
 {
-	vsp1_mod_write(&wpf->entity,
-		       reg + wpf->entity.index * VI6_WPF_OFFSET, data);
+	vsp1_write(wpf->entity.vsp1,
+		   reg + wpf->entity.index * VI6_WPF_OFFSET, data);
 }

 /* -----------------------------------------------------------------------------
@@ -88,8 +88,7 @@ static int wpf_s_stream(struct v4l2_subdev *subdev, int enable)

	if (!enable) {
		vsp1_write(vsp1, VI6_WPF_IRQ_ENB(wpf->entity.index), 0);
-		vsp1_write(vsp1, wpf->entity.index * VI6_WPF_OFFSET +
-			   VI6_WPF_SRCRPF, 0);
+		vsp1_wpf_write(wpf, VI6_WPF_SRCRPF, 0);
		return 0;
	}

@@ -98,12 +97,9 @@ static int wpf_s_stream(struct v4l2_subdev *subdev, int enable)
	 * inputs as sub-layers and select the virtual RPF as the master
	 * layer.
	 */
-	for (i = 0; i < vsp1->info->rpf_count; ++i) {
+	for (i = 0; i < pipe->num_inputs; ++i) {
		struct vsp1_rwpf *input = pipe->inputs[i];

-		if (!input)
-			continue;
-
		srcrpf |= (!pipe->bru && pipe->num_inputs == 1)
			? VI6_WPF_SRCRPF_RPF_ACT_MST(input->entity.index)
			: VI6_WPF_SRCRPF_RPF_ACT_SUB(input->entity.index);
@@ -116,7 +112,7 @@ static int wpf_s_stream(struct v4l2_subdev *subdev, int enable)

	/* Destination stride. */
	if (!pipe->lif) {
-		struct v4l2_pix_format_mplane *format = &wpf->format;
+		struct v4l2_pix_format_mplane *format = &wpf->video.format;

		vsp1_wpf_write(wpf, VI6_WPF_DSTM_STRIDE_Y,
			       format->plane_fmt[0].bytesperline);
@@ -134,7 +130,7 @@ static int wpf_s_stream(struct v4l2_subdev *subdev, int enable)

	/* Format */
	if (!pipe->lif) {
-		const struct vsp1_format_info *fmtinfo = wpf->fmtinfo;
+		const struct vsp1_format_info *fmtinfo = wpf->video.fmtinfo;

		outfmt = fmtinfo->hwfmt << VI6_WPF_OUTFMT_WRFMT_SHIFT;

@@ -155,17 +151,15 @@ static int wpf_s_stream(struct v4l2_subdev *subdev, int enable)
	/* Take the control handler lock to ensure that the PDV value won't be
	 * changed behind our back by a set control operation.
	 */
-	if (vsp1->info->uapi)
-		mutex_lock(wpf->ctrls.lock);
-	outfmt |= wpf->alpha->cur.val << VI6_WPF_OUTFMT_PDV_SHIFT;
+	mutex_lock(wpf->ctrls.lock);
+	outfmt |= vsp1_wpf_read(wpf, VI6_WPF_OUTFMT) & VI6_WPF_OUTFMT_PDV_MASK;
	vsp1_wpf_write(wpf, VI6_WPF_OUTFMT, outfmt);
-	if (vsp1->info->uapi)
-		mutex_unlock(wpf->ctrls.lock);
+	mutex_unlock(wpf->ctrls.lock);

-	vsp1_mod_write(&wpf->entity, VI6_DPR_WPF_FPORCH(wpf->entity.index),
-		       VI6_DPR_WPF_FPORCH_FP_WPFN);
+	vsp1_write(vsp1, VI6_DPR_WPF_FPORCH(wpf->entity.index),
+		   VI6_DPR_WPF_FPORCH_FP_WPFN);

-	vsp1_mod_write(&wpf->entity, VI6_WPF_WRBCK_CTRL, 0);
+	vsp1_write(vsp1, VI6_WPF_WRBCK_CTRL, 0);

	/* Enable interrupts */
	vsp1_write(vsp1, VI6_WPF_IRQ_STA(wpf->entity.index), 0);
@@ -201,17 +195,20 @@ static struct v4l2_subdev_ops wpf_ops = {
  * Video Device Operations
  */

-static void wpf_set_memory(struct vsp1_rwpf *wpf, struct vsp1_rwpf_memory *mem)
+static void wpf_vdev_queue(struct vsp1_video *video,
+			   struct vsp1_video_buffer *buf)
 {
-	vsp1_wpf_write(wpf, VI6_WPF_DSTM_ADDR_Y, mem->addr[0]);
-	if (mem->num_planes > 1)
-		vsp1_wpf_write(wpf, VI6_WPF_DSTM_ADDR_C0, mem->addr[1]);
-	if (mem->num_planes > 2)
-		vsp1_wpf_write(wpf, VI6_WPF_DSTM_ADDR_C1, mem->addr[2]);
+	struct vsp1_rwpf *wpf = container_of(video, struct vsp1_rwpf, video);
+
+	vsp1_wpf_write(wpf, VI6_WPF_DSTM_ADDR_Y, buf->addr[0]);
+	if (buf->buf.vb2_buf.num_planes > 1)
+		vsp1_wpf_write(wpf, VI6_WPF_DSTM_ADDR_C0, buf->addr[1]);
+	if (buf->buf.vb2_buf.num_planes > 2)
+		vsp1_wpf_write(wpf, VI6_WPF_DSTM_ADDR_C1, buf->addr[2]);
 }

-static const struct vsp1_rwpf_operations wpf_vdev_ops = {
-	.set_memory = wpf_set_memory,
+static const struct vsp1_video_operations wpf_vdev_ops = {
+	.queue = wpf_vdev_queue,
 };

 /* -----------------------------------------------------------------------------
@@ -221,15 +218,15 @@ static const struct vsp1_rwpf_operations wpf_vdev_ops = {
 struct vsp1_rwpf *vsp1_wpf_create(struct vsp1_device *vsp1, unsigned int index)
 {
	struct v4l2_subdev *subdev;
+	struct vsp1_video *video;
	struct vsp1_rwpf *wpf;
+	unsigned int flags;
	int ret;

	wpf = devm_kzalloc(vsp1->dev, sizeof(*wpf), GFP_KERNEL);
	if (wpf == NULL)
		return ERR_PTR(-ENOMEM);

-	wpf->ops = &wpf_vdev_ops;
-
	wpf->max_width = WPF_MAX_WIDTH;
	wpf->max_height = WPF_MAX_HEIGHT;

@@ -244,7 +241,7 @@ struct vsp1_rwpf *vsp1_wpf_create(struct vsp1_device *vsp1, unsigned int index)
	subdev = &wpf->entity.subdev;
	v4l2_subdev_init(subdev, &wpf_ops);

-	subdev->entity.ops = &vsp1->media_ops;
+	subdev->entity.ops = &vsp1_media_ops;
	subdev->internal_ops = &vsp1_subdev_internal_ops;
	snprintf(subdev->name, sizeof(subdev->name), "%s wpf.%u",
		 dev_name(vsp1->dev), index);
@@ -255,9 +252,8 @@ struct vsp1_rwpf *vsp1_wpf_create(struct vsp1_device *vsp1, unsigned int index)

	/* Initialize the control handler. */
	v4l2_ctrl_handler_init(&wpf->ctrls, 1);
-	wpf->alpha = v4l2_ctrl_new_std(&wpf->ctrls, &wpf_ctrl_ops,
-				       V4L2_CID_ALPHA_COMPONENT,
-				       0, 255, 1, 255);
+	v4l2_ctrl_new_std(&wpf->ctrls, &wpf_ctrl_ops, V4L2_CID_ALPHA_COMPONENT,
+			  0, 255, 1, 255);

	wpf->entity.subdev.ctrl_handler = &wpf->ctrls;

@@ -268,6 +264,34 @@ struct vsp1_rwpf *vsp1_wpf_create(struct vsp1_device *vsp1, unsigned int index)
		goto error;
	}

+	/* Initialize the video device. */
+	video = &wpf->video;
+
+	video->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	video->vsp1 = vsp1;
+	video->ops = &wpf_vdev_ops;
+
+	ret = vsp1_video_init(video, &wpf->entity);
+	if (ret < 0)
+		goto error;
+
+	wpf->entity.video = video;
+
+	/* Connect the video device to the WPF. All connections are immutable
+	 * except for the WPF0 source link if a LIF is present.
+	 */
+	flags = MEDIA_LNK_FL_ENABLED;
+	if (!(vsp1->pdata.features & VSP1_HAS_LIF) || index != 0)
+		flags |= MEDIA_LNK_FL_IMMUTABLE;
+
+	ret = media_entity_create_link(&wpf->entity.subdev.entity,
+				       RWPF_PAD_SOURCE,
+				       &wpf->video.video.entity, 0, flags);
+	if (ret < 0)
+		goto error;
+
+	wpf->entity.sink = &wpf->video.video.entity;
+
	return wpf;

 error:
diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h
index 5646485..3f0c690 100644
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@ -992,7 +992,7 @@ struct drm_mode_set {
 struct drm_mode_config_funcs {
	struct drm_framebuffer *(*fb_create)(struct drm_device *dev,
					     struct drm_file *file_priv,
-					     const struct drm_mode_fb_cmd2 *mode_cmd);
+					     struct drm_mode_fb_cmd2 *mode_cmd);
	void (*output_poll_changed)(struct drm_device *dev);

	int (*atomic_check)(struct drm_device *dev,
@@ -1183,13 +1183,11 @@ struct drm_prop_enum_list {
	char *name;
 };

-extern __printf(6, 7)
-int drm_crtc_init_with_planes(struct drm_device *dev,
-			      struct drm_crtc *crtc,
-			      struct drm_plane *primary,
-			      struct drm_plane *cursor,
-			      const struct drm_crtc_funcs *funcs,
-			      const char *name, ...);
+extern int drm_crtc_init_with_planes(struct drm_device *dev,
+				     struct drm_crtc *crtc,
+				     struct drm_plane *primary,
+				     struct drm_plane *cursor,
+				     const struct drm_crtc_funcs *funcs);
 extern void drm_crtc_cleanup(struct drm_crtc *crtc);
 extern unsigned int drm_crtc_index(struct drm_crtc *crtc);

@@ -1235,11 +1233,10 @@ void drm_bridge_mode_set(struct drm_bridge *bridge,
 void drm_bridge_pre_enable(struct drm_bridge *bridge);
 void drm_bridge_enable(struct drm_bridge *bridge);

-extern __printf(5, 6)
-int drm_encoder_init(struct drm_device *dev,
-		     struct drm_encoder *encoder,
-		     const struct drm_encoder_funcs *funcs,
-		     int encoder_type, const char *name, ...);
+extern int drm_encoder_init(struct drm_device *dev,
+			    struct drm_encoder *encoder,
+			    const struct drm_encoder_funcs *funcs,
+			    int encoder_type);

 /**
  * drm_encoder_crtc_ok - can a given crtc drive a given encoder?
@@ -1254,15 +1251,13 @@ static inline bool drm_encoder_crtc_ok(struct drm_encoder *encoder,
	return !!(encoder->possible_crtcs & drm_crtc_mask(crtc));
 }

-extern __printf(8, 9)
-int drm_universal_plane_init(struct drm_device *dev,
-			     struct drm_plane *plane,
-			     unsigned long possible_crtcs,
-			     const struct drm_plane_funcs *funcs,
-			     const uint32_t *formats,
-			     unsigned int format_count,
-			     enum drm_plane_type type,
-			     const char *name, ...);
+extern int drm_universal_plane_init(struct drm_device *dev,
+				    struct drm_plane *plane,
+				    unsigned long possible_crtcs,
+				    const struct drm_plane_funcs *funcs,
+				    const uint32_t *formats,
+				    unsigned int format_count,
+				    enum drm_plane_type type);
 extern int drm_plane_init(struct drm_device *dev,
			  struct drm_plane *plane,
			  unsigned long possible_crtcs,
diff --git a/include/drm/drm_crtc_helper.h b/include/drm/drm_crtc_helper.h
index e22ab29..3febb4b 100644
--- a/include/drm/drm_crtc_helper.h
+++ b/include/drm/drm_crtc_helper.h
@@ -197,7 +197,7 @@ extern int drm_helper_connector_dpms(struct drm_connector *connector, int mode);
 extern void drm_helper_move_panel_connectors_to_head(struct drm_device *);

 extern void drm_helper_mode_fill_fb_struct(struct drm_framebuffer *fb,
-					   const struct drm_mode_fb_cmd2 *mode_cmd);
+					   struct drm_mode_fb_cmd2 *mode_cmd);

 static inline void drm_crtc_helper_add(struct drm_crtc *crtc,
				       const struct drm_crtc_helper_funcs *funcs)
diff --git a/include/drm/drm_encoder_slave.h b/include/drm/drm_encoder_slave.h
index 82cdf61..8b9cc36 100644
--- a/include/drm/drm_encoder_slave.h
+++ b/include/drm/drm_encoder_slave.h
@@ -95,7 +95,7 @@ struct drm_encoder_slave_funcs {
 struct drm_encoder_slave {
	struct drm_encoder base;

-	const struct drm_encoder_slave_funcs *slave_funcs;
+	struct drm_encoder_slave_funcs *slave_funcs;
	void *slave_priv;
	void *bus_priv;
 };
diff --git a/include/drm/drm_fb_cma_helper.h b/include/drm/drm_fb_cma_helper.h
index be62bd3..c54cf3d 100644
--- a/include/drm/drm_fb_cma_helper.h
+++ b/include/drm/drm_fb_cma_helper.h
@@ -18,7 +18,7 @@ void drm_fbdev_cma_restore_mode(struct drm_fbdev_cma *fbdev_cma);
 void drm_fbdev_cma_hotplug_event(struct drm_fbdev_cma *fbdev_cma);

 struct drm_framebuffer *drm_fb_cma_create(struct drm_device *dev,
-	struct drm_file *file_priv, const struct drm_mode_fb_cmd2 *mode_cmd);
+	struct drm_file *file_priv, struct drm_mode_fb_cmd2 *mode_cmd);

 struct drm_gem_cma_object *drm_fb_cma_get_gem_obj(struct drm_framebuffer *fb,
	unsigned int plane);
diff --git a/include/media/vsp1.h b/include/media/vsp1.h
deleted file mode 100644
index cc54175..0000000
--- a/include/media/vsp1.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * vsp1.h  --  R-Car VSP1 API
- *
- * Copyright (C) 2015 Renesas Electronics Corporation
- *
- * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-#ifndef __MEDIA_VSP1_H__
-#define __MEDIA_VSP1_H__
-
-#include <linux/types.h>
-
-struct device;
-struct v4l2_rect;
-
-int vsp1_du_init(struct device *dev);
-
-int vsp1_du_setup_lif(struct device *dev, unsigned int width,
-		      unsigned int height);
-
-int vsp1_du_atomic_begin(struct device *dev);
-int vsp1_du_atomic_update(struct device *dev, unsigned int rpf, u32 pixelformat,
-			  unsigned int pitch, dma_addr_t mem[2],
-			  const struct v4l2_rect *src,
-			  const struct v4l2_rect *dst);
-int vsp1_du_atomic_flush(struct device *dev);
-
-#endif /* __MEDIA_VSP1_H__ */
--
1.9.1
