From 598735934bc3cb39268ebb739a24cd6387a34a14 Mon Sep 17 00:00:00 2001
From: Binh Nguyen <binh.nguyen.uw@rvc.renesas.com>
Date: Fri, 6 Nov 2015 15:29:49 +0700
Subject: [PATCH 2/2] qtmultimedia: Fix wrong display color for Full HD video

page alignment is needed when display directly from omxh264dec output

Signed-off-by: Binh Nguyen <binh.nguyen.uw@rvc.renesas.com>
---
 src/qtmultimediaquicktools/qsgvideonode_yuv.cpp | 37 ++++++++++++++++++++++++-
 1 file changed, 36 insertions(+), 1 deletion(-)

diff --git a/src/qtmultimediaquicktools/qsgvideonode_yuv.cpp b/src/qtmultimediaquicktools/qsgvideonode_yuv.cpp
index 07d5119..2e0d72a 100755
--- a/src/qtmultimediaquicktools/qsgvideonode_yuv.cpp
+++ b/src/qtmultimediaquicktools/qsgvideonode_yuv.cpp
@@ -197,6 +197,7 @@ public:
 
     void bind();
     void bindTexture(int id, int w, int h, const uchar *bits, GLenum format, int re_texture);
+    int get_uv_offset_aligned_to_page(int page_size, int stride, int height);
 
     QVideoSurfaceFormat m_format;
     QSize m_textureSize;
@@ -294,11 +295,18 @@ void QSGVideoMaterial_YUV::bind()
                     || m_format.pixelFormat() == QVideoFrame::Format_NV21) {
                 const int y = 0;
                 const int uv = 1;
+                int uv_offset;
+
+                if ((m_frame.bytesPerLine(y) * fh) & (4096 - 1)) {
+                  uv_offset = get_uv_offset_aligned_to_page (4096, m_frame.bytesPerLine(y), fh);
+                } else {
+                  uv_offset = m_frame.bytesPerLine(y) * fh;
+                }
 
                 m_planeWidth[0] = m_planeWidth[1] = qreal(fw) / m_frame.bytesPerLine(y);
 
                 functions->glActiveTexture(GL_TEXTURE1);
-                bindTexture(m_textureIds[1], m_frame.bytesPerLine(uv) / 2, fh / 2, m_frame.bits(uv), GL_LUMINANCE_ALPHA, re_texture);
+                bindTexture(m_textureIds[1], m_frame.bytesPerLine(uv) / 2, fh / 2, m_frame.bits(y) + uv_offset, GL_LUMINANCE_ALPHA, re_texture);
                 functions->glActiveTexture(GL_TEXTURE0); // Finish with 0 as default texture unit
                 bindTexture(m_textureIds[0], m_frame.bytesPerLine(y), fh, m_frame.bits(y), GL_LUMINANCE, re_texture);
 
@@ -348,6 +356,33 @@ void QSGVideoMaterial_YUV::bindTexture(int id, int w, int h, const uchar *bits,
     functions->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 }
 
+int QSGVideoMaterial_YUV::get_uv_offset_aligned_to_page(int page_size, int stride, int height)
+{
+  int a, b, r;
+  int lcm;
+
+  /*
+   * The following implementation uses the Euclidean Algorithm to obtain
+   * the least common multiple of stride and page size.
+   */
+
+  /* nStride is set to width, to achieve 4K aligned by adjusting
+     the nSliceHeight. */
+  /* (1) Calculate the GCD of stride and alignment */
+  b = stride;
+  a = page_size;
+  while ((r = a % b) != 0) {
+    a = b;
+    b = r;
+  }
+
+  /* (2) Calculate the LCM of stride and alignment */
+  lcm = stride * page_size / b;
+
+  /* (3) Calculate the offset of UV plane */
+  return (((stride * height) / lcm) + 1) * lcm;
+}
+
 QSGVideoNode_YUV::QSGVideoNode_YUV(const QVideoSurfaceFormat &format) :
     m_format(format)
 {
-- 
1.9.1

