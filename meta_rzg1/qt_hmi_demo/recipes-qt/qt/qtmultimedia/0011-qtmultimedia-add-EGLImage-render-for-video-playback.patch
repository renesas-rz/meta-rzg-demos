From ebbb3f984cf3e3faa9f3577fb6878734a4ad5fc3 Mon Sep 17 00:00:00 2001
From: Binh Nguyen <binh.nguyen.uw@rvc.renesas.com>
Date: Fri, 18 Mar 2016 10:58:58 +0700
Subject: [PATCH 1/3] qtmultimedia : add EGLImage render for video playback

Improve video playback peformance by creating EGLImage which wrap the
video buffer.
texturing by glEGLImageTargetTexture2DOES() can prvent buffer copy

Signed-off-by: Binh Nguyen <binh.nguyen.uw@rvc.renesas.com>
---
 src/gsttools/qgstutils.cpp                         |  10 +-
 .../qsgvideonode_p.h                               |   8 +-
 .../mediaplayer/qgstreamerplayersession.cpp        |   2 +-
 src/plugins/videonode/egl/qsgvideonode_egl.h       |   8 +-
 .../qdeclarativevideooutput_render.cpp             |  13 ++
 .../qdeclarativevideooutput_render_p.h             |   7 +
 src/qtmultimediaquicktools/qsgvideonode_rgb.cpp    | 147 ++++++++++++++++++++-
 src/qtmultimediaquicktools/qsgvideonode_rgb.h      |   8 +-
 src/qtmultimediaquicktools/qsgvideonode_texture.h  |   8 +-
 src/qtmultimediaquicktools/qsgvideonode_yuv.h      |   8 +-
 .../qtmultimediaquicktools.pro                     |   5 +-
 11 files changed, 213 insertions(+), 11 deletions(-)
 mode change 100644 => 100755 src/qtmultimediaquicktools/qsgvideonode_rgb.cpp

diff --git a/src/gsttools/qgstutils.cpp b/src/gsttools/qgstutils.cpp
index 3265cb9..6dced36 100644
--- a/src/gsttools/qgstutils.cpp
+++ b/src/gsttools/qgstutils.cpp
@@ -57,6 +57,10 @@ template<typename T, int N> static int lengthOf(const T (&)[N]) { return N; }
 
 #include "qgstreamervideoinputdevicecontrol_p.h"
 
+#ifndef EGLIMAGE_USING
+#   define EGLIMAGE_USING
+#endif
+
 QT_BEGIN_NAMESPACE
 
 //internal
@@ -913,8 +917,11 @@ struct VideoFormat
 
 static const VideoFormat qt_videoFormatLookup[] =
 {
+#ifdef EGLIMAGE_USING
+    { QVideoFrame::Format_BGRA32,  GST_VIDEO_FORMAT_BGRA }
+#else
     { QVideoFrame::Format_NV12   , GST_VIDEO_FORMAT_NV12 },
-    // { QVideoFrame::Format_YUV420P, GST_VIDEO_FORMAT_I420 },
+    { QVideoFrame::Format_YUV420P, GST_VIDEO_FORMAT_I420 },
     { QVideoFrame::Format_YV12   , GST_VIDEO_FORMAT_YV12 },
     { QVideoFrame::Format_UYVY   , GST_VIDEO_FORMAT_UYVY },
     { QVideoFrame::Format_YUYV   , GST_VIDEO_FORMAT_YUY2 },
@@ -934,6 +941,7 @@ static const VideoFormat qt_videoFormatLookup[] =
     { QVideoFrame::Format_RGB24 ,  GST_VIDEO_FORMAT_RGB },
     { QVideoFrame::Format_BGR24 ,  GST_VIDEO_FORMAT_BGR },
     { QVideoFrame::Format_RGB565,  GST_VIDEO_FORMAT_RGB16 }
+#endif
 };
 
 static int indexOfVideoFormat(QVideoFrame::PixelFormat format)
diff --git a/src/multimedia/qtmultimediaquicktools_headers/qsgvideonode_p.h b/src/multimedia/qtmultimediaquicktools_headers/qsgvideonode_p.h
index 11d76f6..c391ed4 100644
--- a/src/multimedia/qtmultimediaquicktools_headers/qsgvideonode_p.h
+++ b/src/multimedia/qtmultimediaquicktools_headers/qsgvideonode_p.h
@@ -41,6 +41,10 @@
 #include <QtMultimedia/qvideosurfaceformat.h>
 #include <QtGui/qopenglfunctions.h>
 
+#ifndef EGLIMAGE_USING
+#   define EGLIMAGE_USING
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class Q_MULTIMEDIAQUICK_EXPORT QSGVideoNode : public QSGGeometryNode
@@ -58,7 +62,9 @@ public:
     virtual QAbstractVideoBuffer::HandleType handleType() const = 0;
 
     void setTexturedRectGeometry(const QRectF &boundingRect, const QRectF &textureRect, int orientation);
-
+#ifdef EGLIMAGE_USING
+    virtual void destroyEglImage() = 0;
+#endif
 private:
     QRectF m_rect;
     QRectF m_textureRect;
diff --git a/src/plugins/gstreamer/mediaplayer/qgstreamerplayersession.cpp b/src/plugins/gstreamer/mediaplayer/qgstreamerplayersession.cpp
index 11e14ff..fe3c01b 100644
--- a/src/plugins/gstreamer/mediaplayer/qgstreamerplayersession.cpp
+++ b/src/plugins/gstreamer/mediaplayer/qgstreamerplayersession.cpp
@@ -153,7 +153,7 @@ QGstreamerPlayerSession::QGstreamerPlayerSession(QObject *parent)
         int flags = GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO |
                     GST_PLAY_FLAG_NATIVE_VIDEO | GST_PLAY_FLAG_NATIVE_AUDIO;
 #else
-        int flags = GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_NATIVE_VIDEO;
+        int flags = GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO;
         QByteArray envFlags = qgetenv("QT_GSTREAMER_PLAYBIN_FLAGS");
         if (!envFlags.isEmpty()) {
             flags |= envFlags.toInt();
diff --git a/src/plugins/videonode/egl/qsgvideonode_egl.h b/src/plugins/videonode/egl/qsgvideonode_egl.h
index b721c67..7b203e6 100644
--- a/src/plugins/videonode/egl/qsgvideonode_egl.h
+++ b/src/plugins/videonode/egl/qsgvideonode_egl.h
@@ -46,6 +46,10 @@
 #  undef Bool
 #endif
 
+#ifndef EGLIMAGE_USING
+#   define EGLIMAGE_USING
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QSGVideoMaterial_EGL : public QSGMaterial
@@ -77,7 +81,9 @@ public:
     void setCurrentFrame(const QVideoFrame &frame, FrameFlags flags);
     QVideoFrame::PixelFormat pixelFormat() const;
     QAbstractVideoBuffer::HandleType handleType() const;
-
+#ifdef EGLIMAGE_USING
+    virtual void destroyEglImage(){};
+#endif
 private:
     QSGVideoMaterial_EGL m_material;
     QVideoFrame::PixelFormat m_pixelFormat;
diff --git a/src/qtmultimediaquicktools/qdeclarativevideooutput_render.cpp b/src/qtmultimediaquicktools/qdeclarativevideooutput_render.cpp
index 70d48dd..16fb62b 100644
--- a/src/qtmultimediaquicktools/qdeclarativevideooutput_render.cpp
+++ b/src/qtmultimediaquicktools/qdeclarativevideooutput_render.cpp
@@ -80,6 +80,9 @@ QDeclarativeVideoRendererBackend::QDeclarativeVideoRendererBackend(QDeclarativeV
     m_videoNodeFactories.append(&m_i420Factory);
     m_videoNodeFactories.append(&m_rgbFactory);
     m_videoNodeFactories.append(&m_textureFactory);
+#ifdef EGLIMAGE_USING
+    m_videoNode = NULL;
+#endif
 }
 
 QDeclarativeVideoRendererBackend::~QDeclarativeVideoRendererBackend()
@@ -366,7 +369,11 @@ QSGNode *QDeclarativeVideoRendererBackend::updatePaintNode(QSGNode *oldNode,
         //don't keep the frame for more than really necessary
         m_frameChanged = false;
         m_frame = QVideoFrame();
+#ifdef EGLIMAGE_USING
+        m_videoNode = videoNode;
+#endif
     }
+
     return videoNode;
 }
 
@@ -409,6 +416,12 @@ void QDeclarativeVideoRendererBackend::present(const QVideoFrame &frame)
 void QDeclarativeVideoRendererBackend::stop()
 {
     present(QVideoFrame());
+#ifdef EGLIMAGE_USING
+    if(m_videoNode != NULL) {
+        m_videoNode->destroyEglImage();
+        m_videoNode = NULL;
+    }
+#endif
 }
 
 QSGVideoItemSurface::QSGVideoItemSurface(QDeclarativeVideoRendererBackend *backend, QObject *parent)
diff --git a/src/qtmultimediaquicktools/qdeclarativevideooutput_render_p.h b/src/qtmultimediaquicktools/qdeclarativevideooutput_render_p.h
index cb1168e..bf67670 100644
--- a/src/qtmultimediaquicktools/qdeclarativevideooutput_render_p.h
+++ b/src/qtmultimediaquicktools/qdeclarativevideooutput_render_p.h
@@ -43,6 +43,10 @@
 #include <QtCore/qmutex.h>
 #include <QtMultimedia/qabstractvideosurface.h>
 
+#ifndef EGLIMAGE_USING
+#   define EGLIMAGE_USING
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QSGVideoItemSurface;
@@ -100,6 +104,9 @@ private:
         QVideoFilterRunnable *runnable;
     };
     QList<Filter> m_filters;
+#ifdef EGLIMAGE_USING
+    QSGVideoNode *m_videoNode;
+#endif
 };
 
 class QSGVideoItemSurface : public QAbstractVideoSurface
diff --git a/src/qtmultimediaquicktools/qsgvideonode_rgb.cpp b/src/qtmultimediaquicktools/qsgvideonode_rgb.cpp
old mode 100644
new mode 100755
index 5093acb..69ac00a
--- a/src/qtmultimediaquicktools/qsgvideonode_rgb.cpp
+++ b/src/qtmultimediaquicktools/qsgvideonode_rgb.cpp
@@ -37,6 +37,31 @@
 #include <QtGui/QOpenGLContext>
 #include <QtGui/QOpenGLFunctions>
 #include <QtGui/QOpenGLShaderProgram>
+#include <QtPlatformHeaders/QEGLNativeContext>
+#include <QApplication>
+#include <qpa/qplatformintegration.h>
+#include <qpa/qplatformnativeinterface.h>
+#include "private/qguiapplication_p.h"
+#include <sys/time.h>
+extern "C"
+{
+#include "GLES2/gl2.h"
+#include "GLES2/gl2ext.h"
+#include "EGL/egl.h"
+#include "EGL/eglext.h"
+#include "EGL/eglext_REL.h"
+}
+static int re_texture;
+
+#ifdef EGLIMAGE_USING
+struct EGLImage_arr {
+    struct EGLImage_arr * next;
+    EGLImageKHR eglimage;
+    EGLNativePixmapTypeREL  sNativePixmap;
+    NativePixmapType eglPixmap;
+    void * buffer;
+};
+#endif
 
 QT_BEGIN_NAMESPACE
 
@@ -58,6 +83,7 @@ QList<QVideoFrame::PixelFormat> QSGVideoNodeFactory_RGB::supportedPixelFormats(
 
 QSGVideoNode *QSGVideoNodeFactory_RGB::createNode(const QVideoSurfaceFormat &format)
 {
+    re_texture = 1;
     if (supportedPixelFormats(format.handleType()).contains(format.pixelFormat()))
         return new QSGVideoNode_RGB(format);
 
@@ -125,6 +151,17 @@ public:
         m_width(1.0)
     {
         setFlag(Blending, false);
+#ifdef EGLIMAGE_USING
+        QPlatformNativeInterface* nativeInterface = QGuiApplicationPrivate::platformIntegration()->nativeInterface();
+        Q_ASSERT(nativeInterface);
+        eglCreateImageKHR  = (EGLCREATEIMAGEKHR)eglGetProcAddress("eglCreateImageKHR");
+        eglDestroyImageKHR = (EGLDESTROYIMAGEKHR)eglGetProcAddress("eglDestroyImageKHR");
+        glEGLImageTargetTexture2D = (GLEGLIMAGETARGETRENDERBUFFERSTORAGEOES)eglGetProcAddress("glEGLImageTargetTexture2DOES");
+        eglDisplay = nativeInterface->nativeResourceForIntegration("egldisplay");
+        if(eglDisplay == EGL_NO_DISPLAY) printf("eglGetDisplay failed.\n");
+
+        eglimage_arr = NULL;
+#endif
     }
 
     ~QSGVideoMaterial_RGB()
@@ -160,7 +197,63 @@ public:
         QMutexLocker lock(&m_frameMutex);
         m_frame = frame;
     }
+#ifdef EGLIMAGE_USING
+    struct EGLImage_arr * set_current_eglimage(struct EGLImage_arr * top)
+    {
+        struct EGLImage_arr *cur = top;
+        struct EGLImage_arr *tmp;
+
+        while (cur != NULL) {
+            if(cur->buffer == m_frame.bits()) {
+                eglimage = cur->eglimage;
+                return top;
+            }
+            cur = cur->next;
+        }
+
+        tmp = (struct EGLImage_arr *)malloc(sizeof (struct EGLImage_arr));
+        memset(tmp,0,sizeof (struct EGLImage_arr));
+        tmp->sNativePixmap.width    = m_textureSize.width();
+        tmp->sNativePixmap.height   = m_textureSize.height();
+        tmp->sNativePixmap.stride   = m_frame.bytesPerLine() / 4;
+        tmp->sNativePixmap.usage    = 0;
+        tmp->sNativePixmap.pixelData    = (void*)m_frame.bits();
+        tmp->sNativePixmap.format   = EGL_NATIVE_PIXFORMAT_ARGB8888_REL;
+        tmp->eglPixmap = (NativeWindowType)&tmp->sNativePixmap;
+        tmp->eglimage = eglCreateImageKHR(eglDisplay,
+                                            EGL_NO_CONTEXT,
+                                            EGL_NATIVE_PIXMAP_KHR,
+                                            tmp->eglPixmap, NULL);
+        tmp->buffer = tmp->sNativePixmap.pixelData;
+
+        if (tmp->eglimage == EGL_NO_IMAGE_KHR)
+        {
+            printf ("eglCreateImageKHR failed. %x\n", eglGetError());
+            free(tmp);
+            eglimage = top != NULL ? top->eglimage : EGL_NO_IMAGE_KHR;
+            return top;
+        }
+
+        eglimage = tmp->eglimage;
+        tmp->next = top;
+
+        return tmp;
+    }
+
+    void destroyEglImage()
+    {
+        struct EGLImage_arr *tmp;
 
+        while (eglimage_arr != NULL) {
+            if(eglimage_arr->eglimage) {
+                eglDestroyImageKHR(eglDisplay, eglimage_arr->eglimage);
+            }
+            tmp = eglimage_arr;
+            eglimage_arr = eglimage_arr->next;
+            free (tmp);
+        }
+    }
+#endif
     void bind()
     {
         QOpenGLFunctions *functions = QOpenGLContext::currentContext()->functions();
@@ -187,8 +280,22 @@ public:
                         functions->glDeleteTextures(1, &m_textureId);
                     functions->glGenTextures(1, &m_textureId);
                     m_textureSize = textureSize;
+#ifdef EGLIMAGE_USING
+                    eglimage_arr = set_current_eglimage(eglimage_arr);
+#endif
                 }
-
+#ifdef EGLIMAGE_USING
+                if (eglimage_arr != NULL) {
+                    eglimage_arr = set_current_eglimage(eglimage_arr);
+                    functions->glActiveTexture(GL_TEXTURE0);
+                    functions->glBindTexture(GL_TEXTURE_2D, m_textureId);
+
+                    glEGLImageTargetTexture2D(GL_TEXTURE_2D, eglimage);
+                    GLint glerr = glGetError();
+                    if(glerr) printf("<ERROR name=\"CreateTextureEGLImage\" glerr=\"0x%x\"/>\n", glerr);
+
+                } else {
+#endif
                 GLint dataType = GL_UNSIGNED_BYTE;
                 GLint dataFormat = GL_RGBA;
 
@@ -203,12 +310,26 @@ public:
 
                 functions->glActiveTexture(GL_TEXTURE0);
                 functions->glBindTexture(GL_TEXTURE_2D, m_textureId);
-                functions->glTexImage2D(GL_TEXTURE_2D, 0, dataFormat,
+
+                if (re_texture) {
+                    functions->glTexImage2D(GL_TEXTURE_2D, 0, dataFormat,
+                                        m_textureSize.width(), m_textureSize.height(),
+                                        0, dataFormat, dataType, m_frame.bits());
+                    re_texture = 0;
+                } else {
+                    functions->glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0,
+                                        m_textureSize.width(), m_textureSize.height(),
+                                        dataFormat, dataType, m_frame.bits());
+                    if (GL_NO_ERROR != functions->glGetError())
+                        functions->glTexImage2D(GL_TEXTURE_2D, 0, dataFormat,
                                         m_textureSize.width(), m_textureSize.height(),
                                         0, dataFormat, dataType, m_frame.bits());
+                }
 
                 functions->glPixelStorei(GL_UNPACK_ALIGNMENT, previousAlignment);
-
+#ifdef EGLIMAGE_USING
+                }
+#endif
                 functions->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                 functions->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                 functions->glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
@@ -236,6 +357,21 @@ private:
         return m_format.pixelFormat() == QVideoFrame::Format_RGB32
                 || m_format.pixelFormat() == QVideoFrame::Format_ARGB32;
     }
+#ifdef EGLIMAGE_USING
+    EGLImageKHR	eglimage = EGL_NO_IMAGE_KHR;
+    EGLDisplay	eglDisplay;
+    QPlatformNativeInterface* nativeInterface;
+
+    // /* EGL image function */
+    typedef EGLImageKHR (*EGLCREATEIMAGEKHR)(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, EGLint* attr_list);
+    typedef EGLBoolean (*EGLDESTROYIMAGEKHR)(EGLDisplay dpy, EGLImageKHR image);
+    EGLCREATEIMAGEKHR eglCreateImageKHR;
+    EGLDESTROYIMAGEKHR eglDestroyImageKHR;
+    // /* EGL image to texture image function */
+    typedef void (*GLEGLIMAGETARGETRENDERBUFFERSTORAGEOES)(GLenum target, GLeglImageOES image);
+    GLEGLIMAGETARGETRENDERBUFFERSTORAGEOES glEGLImageTargetTexture2D;
+    struct EGLImage_arr *eglimage_arr;
+#endif
 };
 
 
@@ -257,6 +393,11 @@ void QSGVideoNode_RGB::setCurrentFrame(const QVideoFrame &frame, FrameFlags)
     markDirty(DirtyMaterial);
 }
 
+void QSGVideoNode_RGB::destroyEglImage()
+{
+    m_material->destroyEglImage();
+}
+
 void QSGVideoMaterialShader_RGB::updateState(const RenderState &state,
                                                 QSGMaterial *newMaterial,
                                                 QSGMaterial *oldMaterial)
diff --git a/src/qtmultimediaquicktools/qsgvideonode_rgb.h b/src/qtmultimediaquicktools/qsgvideonode_rgb.h
index 77d11b6..b07ab59 100644
--- a/src/qtmultimediaquicktools/qsgvideonode_rgb.h
+++ b/src/qtmultimediaquicktools/qsgvideonode_rgb.h
@@ -37,6 +37,10 @@
 #include <private/qsgvideonode_p.h>
 #include <QtMultimedia/qvideosurfaceformat.h>
 
+#ifndef EGLIMAGE_USING
+#   define EGLIMAGE_USING
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QSGVideoMaterial_RGB;
@@ -54,7 +58,9 @@ public:
         return QAbstractVideoBuffer::NoHandle;
     }
     void setCurrentFrame(const QVideoFrame &frame, FrameFlags flags);
-
+#ifdef EGLIMAGE_USING
+    void destroyEglImage();
+#endif
 private:
     QVideoSurfaceFormat m_format;
     QSGVideoMaterial_RGB *m_material;
diff --git a/src/qtmultimediaquicktools/qsgvideonode_texture.h b/src/qtmultimediaquicktools/qsgvideonode_texture.h
index 0849c57..019bb45 100644
--- a/src/qtmultimediaquicktools/qsgvideonode_texture.h
+++ b/src/qtmultimediaquicktools/qsgvideonode_texture.h
@@ -37,6 +37,10 @@
 #include <private/qsgvideonode_p.h>
 #include <QtMultimedia/qvideosurfaceformat.h>
 
+#ifndef EGLIMAGE_USING
+#   define EGLIMAGE_USING
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QSGVideoMaterial_Texture;
@@ -54,7 +58,9 @@ public:
         return QAbstractVideoBuffer::GLTextureHandle;
     }
     void setCurrentFrame(const QVideoFrame &frame, FrameFlags flags);
-
+#ifdef EGLIMAGE_USING
+    virtual void destroyEglImage(){};
+#endif
 private:
     QVideoSurfaceFormat m_format;
     QSGVideoMaterial_Texture *m_material;
diff --git a/src/qtmultimediaquicktools/qsgvideonode_yuv.h b/src/qtmultimediaquicktools/qsgvideonode_yuv.h
index 776f0a5..e59955a 100644
--- a/src/qtmultimediaquicktools/qsgvideonode_yuv.h
+++ b/src/qtmultimediaquicktools/qsgvideonode_yuv.h
@@ -37,6 +37,10 @@
 #include <private/qsgvideonode_p.h>
 #include <QtMultimedia/qvideosurfaceformat.h>
 
+#ifndef EGLIMAGE_USING
+#   define EGLIMAGE_USING
+#endif
+
 QT_BEGIN_NAMESPACE
 
 class QSGVideoMaterial_YUV;
@@ -53,7 +57,9 @@ public:
         return QAbstractVideoBuffer::NoHandle;
     }
     void setCurrentFrame(const QVideoFrame &frame, FrameFlags flags);
-
+#ifdef EGLIMAGE_USING
+    virtual void destroyEglImage(){};
+#endif
 private:
     void bindTexture(int id, int unit, int w, int h, const uchar *bits);
 
diff --git a/src/qtmultimediaquicktools/qtmultimediaquicktools.pro b/src/qtmultimediaquicktools/qtmultimediaquicktools.pro
index 61c5f7b..cd7ba1f 100644
--- a/src/qtmultimediaquicktools/qtmultimediaquicktools.pro
+++ b/src/qtmultimediaquicktools/qtmultimediaquicktools.pro
@@ -1,7 +1,8 @@
 TARGET = QtMultimediaQuick_p
-QT = core quick multimedia-private
+QT = core core-private quick quick-private multimedia-private widgets widgets-private gui gui-private
 CONFIG += internal_module
 
+
 load(qt_module)
 
 DEFINES += QT_BUILD_QTMM_QUICK_LIB
@@ -46,3 +47,5 @@ OTHER_FILES += \
     shaders/biplanaryuvvideo_swizzle.frag \
     shaders/triplanaryuvvideo.vert \
     shaders/triplanaryuvvideo.frag
+
+LIBS += -lEGL -lEGL-pvr -lGLESv2
\ No newline at end of file
-- 
1.9.1

