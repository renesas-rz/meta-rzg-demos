From 9c17755ab1b8d8de9781dcd6f9a2026b1cc4f0d8 Mon Sep 17 00:00:00 2001
From: HungTran <hung.tran.jy@rvc.renesas.com>
Date: Fri, 16 Oct 2015 21:53:48 +0700
Subject: [PATCH] qtmultimedia: Add services for Doorphone demo

These are services for Doorphone demo (simple-player-qml)
Note that this patch is used with upstream meta-qt5, revision
51b4620392aa9041d8512549bfa554bea368c5ea
---
 qtmultimedia.pro                                   |   28 +-
 src/imports/multimedia/BAR/qdeclarativebar.cpp     |  196 +++
 src/imports/multimedia/BAR/qdeclarativebar_p.h     |   41 +
 src/imports/multimedia/GRAPH/qdeclarativegraph.cpp |  204 +++
 src/imports/multimedia/GRAPH/qdeclarativegraph_p.h |   41 +
 .../PERFORMANCE/dataQuery/cpudataquery.cpp         |   34 +
 .../PERFORMANCE/dataQuery/cpudataquery.h           |   44 +
 .../multimedia/PERFORMANCE/dataQuery/dataquery.cpp |   21 +
 .../multimedia/PERFORMANCE/dataQuery/dataquery.h   |   46 +
 .../PERFORMANCE/dataQuery/queryresource.cpp        |  326 +++++
 .../PERFORMANCE/dataQuery/queryresource.h          |  211 +++
 .../PERFORMANCE/dataQuery/ramdataquery.cpp         |   19 +
 .../PERFORMANCE/dataQuery/ramdataquery.h           |   32 +
 .../PERFORMANCE/painters/barspainter.cpp           |   61 +
 .../multimedia/PERFORMANCE/painters/barspainter.h  |   38 +
 .../painters/graphmulticolorpainter.cpp            |  110 ++
 .../PERFORMANCE/painters/graphmulticolorpainter.h  |   49 +
 .../PERFORMANCE/painters/graphpainter.cpp          |   57 +
 .../multimedia/PERFORMANCE/painters/graphpainter.h |   35 +
 .../PERFORMANCE/painters/painterutils.cpp          |  102 ++
 .../multimedia/PERFORMANCE/painters/painterutils.h |   58 +
 .../PERFORMANCE/painters/performancepainter.cpp    |  112 ++
 .../PERFORMANCE/painters/performancepainter.h      |  102 ++
 .../multimedia/PERFORMANCE/qdeclarativecpu.cpp     |  117 ++
 .../multimedia/PERFORMANCE/qdeclarativecpu_p.h     |  121 ++
 .../multimedia/PERFORMANCE/qdeclarativemem.cpp     |  105 ++
 .../multimedia/PERFORMANCE/qdeclarativemem_p.h     |   78 +
 .../PERFORMANCE/widgets/performancewidget.cpp      |   87 ++
 .../PERFORMANCE/widgets/performancewidget.h        |   86 ++
 src/imports/multimedia/multimedia.cpp              |   18 +
 src/imports/multimedia/multimedia.pro              |   31 +-
 .../multimedia/qdeclarativeH264Streaming.cpp       |  697 +++++++++
 .../multimedia/qdeclarativeH264Streaming_p.h       |  315 +++++
 src/imports/multimedia/qdeclarativeMP4Playback.cpp |  147 ++
 src/imports/multimedia/qdeclarativeMP4Playback_p.h |   62 +
 src/imports/multimedia/qdeclarativeMP4Recorder.cpp |  156 ++
 src/imports/multimedia/qdeclarativeMP4Recorder_p.h |  172 +++
 .../multimedia/qdeclarativeaudiostreaming.cpp      |  247 ++++
 .../multimedia/qdeclarativeaudiostreaming_p.h      |  120 ++
 src/imports/multimedia/qdeclarativeaxistat.cpp     |  565 ++++++++
 src/imports/multimedia/qdeclarativeaxistat_p.h     |  156 ++
 src/multimedia/audio/audio.pri                     |    4 +-
 src/multimedia/audio/qaudiostreaming.cpp           |  257 ++++
 src/multimedia/audio/qaudiostreaming.h             |   92 ++
 src/multimedia/controls/controls.pri               |   12 +-
 src/multimedia/controls/qH264Streamingcontrol.cpp  |  371 +++++
 src/multimedia/controls/qH264Streamingcontrol.h    |  141 ++
 src/multimedia/controls/qMP4Playbackcontrol.cpp    |    1 +
 src/multimedia/controls/qMP4Playbackcontrol.h      |    1 +
 src/multimedia/controls/qMP4Recordercontrol.cpp    |   54 +
 src/multimedia/controls/qMP4Recordercontrol.h      |   93 ++
 src/multimedia/controls/qaudiostreamingcontrol.cpp |   17 +
 src/multimedia/controls/qaudiostreamingcontrol.h   |   48 +
 src/multimedia/playback/playback.pri               |    8 +-
 src/multimedia/playback/qH264Streaming.cpp         | 1496 ++++++++++++++++++++
 src/multimedia/playback/qH264Streaming.h           |  245 ++++
 src/multimedia/playback/qMP4Playback.cpp           |  176 +++
 src/multimedia/playback/qMP4Playback.h             |   86 ++
 src/multimedia/qmediaserviceproviderplugin.h       |   10 +
 src/multimedia/recording/qMP4Recorder.cpp          |  259 ++++
 src/multimedia/recording/qMP4Recorder.h            |  134 ++
 src/multimedia/recording/recording.pri             |    4 +-
 src/plugins/alsa/asoundlib.h                       |    2 +
 .../gstreamer/H264Streaming/H264Streaming.json     |    4 +
 .../gstreamer/H264Streaming/H264Streaming.pro      |   24 +
 .../qgstreamerH264Streamingcontrol.cpp             |  492 +++++++
 .../H264Streaming/qgstreamerH264Streamingcontrol.h |  147 ++
 .../qgstreamerH264Streamingservice.cpp             |   73 +
 .../H264Streaming/qgstreamerH264Streamingservice.h |   68 +
 .../qgstreamerH264Streamingserviceplugin.cpp       |  195 +++
 .../qgstreamerH264Streamingserviceplugin.h         |   72 +
 .../qgstreamerH264Streamingsession.cpp             | 1271 +++++++++++++++++
 .../H264Streaming/qgstreamerH264Streamingsession.h |  341 +++++
 src/plugins/gstreamer/MP4Playback/MP4Playback.json |    4 +
 src/plugins/gstreamer/MP4Playback/MP4Playback.pro  |   25 +
 .../MP4Playback/qgstreamerMP4Playbackcontrol.cpp   |   79 ++
 .../MP4Playback/qgstreamerMP4Playbackcontrol.h     |   39 +
 .../MP4Playback/qgstreamerMP4Playbackservice.cpp   |   54 +
 .../MP4Playback/qgstreamerMP4Playbackservice.h     |   35 +
 .../qgstreamerMP4Playbackserviceplugin.cpp         |   32 +
 .../qgstreamerMP4Playbackserviceplugin.h           |   26 +
 .../MP4Playback/qgstreamerMP4Playbacksession.cpp   |  223 +++
 .../MP4Playback/qgstreamerMP4Playbacksession.h     |   55 +
 src/plugins/gstreamer/MP4Recorder/MP4Recorder.json |    4 +
 src/plugins/gstreamer/MP4Recorder/MP4Recorder.pro  |   25 +
 .../MP4Recorder/qgstreamerMP4Recordercontrol.cpp   |  173 +++
 .../MP4Recorder/qgstreamerMP4Recordercontrol.h     |   63 +
 .../MP4Recorder/qgstreamerMP4Recorderservice.cpp   |   76 +
 .../MP4Recorder/qgstreamerMP4Recorderservice.h     |   68 +
 .../qgstreamerMP4Recorderserviceplugin.cpp         |   62 +
 .../qgstreamerMP4Recorderserviceplugin.h           |   60 +
 .../MP4Recorder/qgstreamerMP4Recordersession.cpp   |  225 +++
 .../MP4Recorder/qgstreamerMP4Recordersession.h     |  112 ++
 .../gstreamer/audiostreaming/audiostreaming.json   |    4 +
 .../gstreamer/audiostreaming/audiostreaming.pro    |   25 +
 .../qgstreameraudiostreamingcontrol.cpp            |  149 ++
 .../qgstreameraudiostreamingcontrol.h              |   50 +
 .../qgstreameraudiostreamingservice.cpp            |   87 ++
 .../qgstreameraudiostreamingservice.h              |   68 +
 .../qgstreameraudiostreamingserviceplugin.cpp      |   65 +
 .../qgstreameraudiostreamingserviceplugin.h        |   60 +
 .../qgstreameraudiostreamingsession.cpp            |  299 ++++
 .../qgstreameraudiostreamingsession.h              |   73 +
 src/plugins/gstreamer/common.pri                   |    1 +
 src/plugins/gstreamer/gstreamer.json               |    2 +-
 src/plugins/gstreamer/gstreamer.pro                |    6 +-
 106 files changed, 13749 insertions(+), 25 deletions(-)
 create mode 100644 src/imports/multimedia/BAR/qdeclarativebar.cpp
 create mode 100644 src/imports/multimedia/BAR/qdeclarativebar_p.h
 create mode 100644 src/imports/multimedia/GRAPH/qdeclarativegraph.cpp
 create mode 100644 src/imports/multimedia/GRAPH/qdeclarativegraph_p.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/dataQuery/cpudataquery.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/dataQuery/cpudataquery.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/dataQuery/dataquery.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/dataQuery/dataquery.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/dataQuery/queryresource.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/dataQuery/queryresource.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/dataQuery/ramdataquery.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/dataQuery/ramdataquery.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/painters/barspainter.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/painters/barspainter.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/painters/graphmulticolorpainter.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/painters/graphmulticolorpainter.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/painters/graphpainter.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/painters/graphpainter.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/painters/painterutils.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/painters/painterutils.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/painters/performancepainter.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/painters/performancepainter.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/qdeclarativecpu.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/qdeclarativecpu_p.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/qdeclarativemem.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/qdeclarativemem_p.h
 create mode 100644 src/imports/multimedia/PERFORMANCE/widgets/performancewidget.cpp
 create mode 100644 src/imports/multimedia/PERFORMANCE/widgets/performancewidget.h
 create mode 100755 src/imports/multimedia/qdeclarativeH264Streaming.cpp
 create mode 100755 src/imports/multimedia/qdeclarativeH264Streaming_p.h
 create mode 100755 src/imports/multimedia/qdeclarativeMP4Playback.cpp
 create mode 100755 src/imports/multimedia/qdeclarativeMP4Playback_p.h
 create mode 100755 src/imports/multimedia/qdeclarativeMP4Recorder.cpp
 create mode 100755 src/imports/multimedia/qdeclarativeMP4Recorder_p.h
 create mode 100755 src/imports/multimedia/qdeclarativeaudiostreaming.cpp
 create mode 100755 src/imports/multimedia/qdeclarativeaudiostreaming_p.h
 create mode 100644 src/imports/multimedia/qdeclarativeaxistat.cpp
 create mode 100644 src/imports/multimedia/qdeclarativeaxistat_p.h
 create mode 100755 src/multimedia/audio/qaudiostreaming.cpp
 create mode 100755 src/multimedia/audio/qaudiostreaming.h
 create mode 100755 src/multimedia/controls/qH264Streamingcontrol.cpp
 create mode 100755 src/multimedia/controls/qH264Streamingcontrol.h
 create mode 100755 src/multimedia/controls/qMP4Playbackcontrol.cpp
 create mode 100755 src/multimedia/controls/qMP4Playbackcontrol.h
 create mode 100755 src/multimedia/controls/qMP4Recordercontrol.cpp
 create mode 100755 src/multimedia/controls/qMP4Recordercontrol.h
 create mode 100755 src/multimedia/controls/qaudiostreamingcontrol.cpp
 create mode 100755 src/multimedia/controls/qaudiostreamingcontrol.h
 create mode 100755 src/multimedia/playback/qH264Streaming.cpp
 create mode 100755 src/multimedia/playback/qH264Streaming.h
 create mode 100755 src/multimedia/playback/qMP4Playback.cpp
 create mode 100755 src/multimedia/playback/qMP4Playback.h
 create mode 100755 src/multimedia/recording/qMP4Recorder.cpp
 create mode 100755 src/multimedia/recording/qMP4Recorder.h
 create mode 100644 src/plugins/alsa/asoundlib.h
 create mode 100755 src/plugins/gstreamer/H264Streaming/H264Streaming.json
 create mode 100755 src/plugins/gstreamer/H264Streaming/H264Streaming.pro
 create mode 100755 src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingcontrol.cpp
 create mode 100755 src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingcontrol.h
 create mode 100755 src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingservice.cpp
 create mode 100755 src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingservice.h
 create mode 100755 src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingserviceplugin.cpp
 create mode 100755 src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingserviceplugin.h
 create mode 100755 src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingsession.cpp
 create mode 100755 src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingsession.h
 create mode 100755 src/plugins/gstreamer/MP4Playback/MP4Playback.json
 create mode 100755 src/plugins/gstreamer/MP4Playback/MP4Playback.pro
 create mode 100755 src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackcontrol.cpp
 create mode 100755 src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackcontrol.h
 create mode 100755 src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackservice.cpp
 create mode 100755 src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackservice.h
 create mode 100755 src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackserviceplugin.cpp
 create mode 100755 src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackserviceplugin.h
 create mode 100755 src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbacksession.cpp
 create mode 100755 src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbacksession.h
 create mode 100755 src/plugins/gstreamer/MP4Recorder/MP4Recorder.json
 create mode 100755 src/plugins/gstreamer/MP4Recorder/MP4Recorder.pro
 create mode 100755 src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordercontrol.cpp
 create mode 100755 src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordercontrol.h
 create mode 100755 src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderservice.cpp
 create mode 100755 src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderservice.h
 create mode 100755 src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderserviceplugin.cpp
 create mode 100755 src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderserviceplugin.h
 create mode 100755 src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordersession.cpp
 create mode 100755 src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordersession.h
 create mode 100755 src/plugins/gstreamer/audiostreaming/audiostreaming.json
 create mode 100755 src/plugins/gstreamer/audiostreaming/audiostreaming.pro
 create mode 100755 src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingcontrol.cpp
 create mode 100755 src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingcontrol.h
 create mode 100755 src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingservice.cpp
 create mode 100755 src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingservice.h
 create mode 100755 src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingserviceplugin.cpp
 create mode 100755 src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingserviceplugin.h
 create mode 100755 src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingsession.cpp
 create mode 100755 src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingsession.h

diff --git a/qtmultimedia.pro b/qtmultimedia.pro
index 4f675fe..7663fa2 100644
--- a/qtmultimedia.pro
+++ b/qtmultimedia.pro
@@ -17,23 +17,21 @@ win32 {
 } else:!android {
     contains(QT_CONFIG, alsa):qtCompileTest(alsa)
     contains(QT_CONFIG, pulseaudio):qtCompileTest(pulseaudio)
-
-    !done_config_gstreamer {
-        isEmpty(GST_VERSION) {
-            contains(QT_CONFIG, gstreamer-0.10) {
-                GST_VERSION = 0.10
-            } else: contains(QT_CONFIG, gstreamer-1.0) {
-                GST_VERSION = 1.0
-            }
-        }
-        cache(GST_VERSION, set)
-        !isEmpty(GST_VERSION):qtCompileTest(gstreamer) {
-            qtCompileTest(gstreamer_photography)
-            qtCompileTest(gstreamer_encodingprofiles)
-            qtCompileTest(gstreamer_appsrc)
-            qtCompileTest(linux_v4l)
+	 GST_VERSION = 1.0
+    isEmpty(GST_VERSION) {
+        contains(QT_CONFIG, gstreamer-0.10) {
+            GST_VERSION = 0.10
+        } else: contains(QT_CONFIG, gstreamer-1.0) {
+            GST_VERSION = 1.0
         }
     }
+    cache(GST_VERSION, set)
+    !isEmpty(GST_VERSION):qtCompileTest(gstreamer) {
+        qtCompileTest(gstreamer_photography)
+        qtCompileTest(gstreamer_encodingprofiles)
+        qtCompileTest(gstreamer_appsrc)
+        qtCompileTest(linux_v4l)
+    }
 
     qtCompileTest(resourcepolicy)
     qtCompileTest(gpu_vivante)
diff --git a/src/imports/multimedia/BAR/qdeclarativebar.cpp b/src/imports/multimedia/BAR/qdeclarativebar.cpp
new file mode 100644
index 0000000..9601748
--- /dev/null
+++ b/src/imports/multimedia/BAR/qdeclarativebar.cpp
@@ -0,0 +1,196 @@
+#include "qdeclarativebar_p.h"
+#include <QPainter>
+#include <iostream>
+
+QT_BEGIN_NAMESPACE
+QDeclarativeBar::QDeclarativeBar(QQuickItem *parent)
+    : QQuickPaintedItem(parent)
+    ,data(20,0)
+{
+}
+
+// QString QDeclarativeBar::name() const
+// {
+    // return m_name;
+// }
+
+// void QDeclarativeBar::setName(const QString &name)
+// {
+    // m_name = name;
+// }
+
+float QDeclarativeBar::read_value() const
+{
+    return m_value;
+}
+
+void QDeclarativeBar::set_value(const float &value)
+{
+    m_value = value;
+    for (int i=0; i<19; i++)
+    {
+        data[i]=data[i+1];
+    }
+    data[19]=value;
+    update();
+}
+
+
+
+// QColor QDeclarativeBar::color() const
+// {
+    // return m_color;
+// }
+
+// void QDeclarativeBar::setColor(const QColor &color)
+// {
+    // m_color = color;
+// }
+
+//![1]
+void QDeclarativeBar::paint(QPainter *painter)
+{
+/*Graph*/
+/*
+    //background
+      QPen pen(QColor(100,100,100,255), 2);
+      painter->setPen(pen);
+      painter->setBrush(QColor(40,40,40,255));
+      painter->drawRoundedRect(0,0,(width()-1),(height()-1),
+                               3,3,Qt::AbsoluteSize);
+      pen.setWidth(1);
+
+      painter->setPen(pen);
+
+    //Grid
+      int stepm_height = height()/15;
+      int stepm_width = width() /15;
+
+      //Draw horizontal lines
+      for (int i = 0; i < stepm_width +1; i++)
+        {
+          painter->drawLine(15*i+2,1
+                        ,15*i+2, height()-1);
+        }
+
+      //Draw vertical lines
+      for (int i = 0; i < stepm_height +1; i++)
+        {
+           painter->drawLine(4,15*i+2,width()-4,
+                        15*i+2);
+        }
+    //Get the size of the data
+        QColor lineColor = (QColor(0,255,0,255));
+        QColor bodyColor = (QColor(0,180,0,120));
+
+
+        int cacheSize = 20;
+        //Calculating the step size between each sample of the data (uniform distribution)
+        float step = float(width()-3)/(cacheSize-1);
+
+        //Setup the colors
+        painter->setPen(lineColor);
+        painter->setBrush(bodyColor);
+
+        //Create a polygon shape
+        QPolygonF poly;
+        int x,y;
+        //Fill in the points to the polygon
+        //Remeber that the height is relative to top left corner so needs to be reversed
+        for( int i = 0; i<cacheSize;i++)
+        {
+            if (i==0)
+            {
+                //The first one is the base , same value of the x but with minimum height value
+                poly.append(QPoint( 0+(i*step+2),height()-1));
+            }
+
+            //Init to min height value
+            y = (height()-1);
+            //convert data in range 0-1 and use it to multiply the height  ( with a small offset)
+            y -= (data[i]/100*(height()-5));
+            //Init value to start position
+            x = 0;
+            //Add the correct positon based on the number of steps taken ( plus  a small offset)
+            x +=(i*step+2);
+            //Append the point
+            poly.append(QPoint(x,y));
+            if(i== cacheSize -1)
+            {
+             //append last point
+             poly.append(QPoint(x,height()-1));
+            }
+        }
+        //Draw the polygon
+        painter->drawPolygon(poly);
+painter->drawText(0 + (width()/2),height()/2,QString::number(int(m_value)) + " %");
+*/
+
+
+
+/* Bar */
+    //background
+      QPen pen(QColor(100,100,100,255), 4);
+      painter->setPen(pen);
+      painter->setBrush(QColor(40,40,40,255));
+      painter->drawRoundedRect(0,0,(width()-1),(height()-1),
+                               3,3,Qt::AbsoluteSize);
+      pen.setWidth(1);
+      pen.setColor(QColor(100,100,100,255));
+      painter->setPen(pen);
+
+    //Grid
+      int stepm_height = height()/10;
+      int stepm_width = width() /10;
+      //Draw horizontal lines
+      for (int i = 0; i < stepm_width +1; i++)
+        {
+          painter->drawLine(10*i+2,1
+                        ,10*i+2, height()-1);
+        }
+      //Draw vertical lines
+      for (int i = 0; i < stepm_height +1; i++)
+        {
+           painter->drawLine(4,10*i+2,width()-4,
+                        10*i+2);
+        }
+
+      //Gradient
+      int pixToCover = height() * m_value/100.0f ;
+      QColor color1 = (QColor(0,255,0,255));
+      QColor color2 = (QColor(255,0,0,255));
+          //Lets build the backaground rectangle
+         // QRect myQRect = QRect(QPoint(2,3) , QSize(pixToCover-5,height()-6));
+          QRect myQRect = QRect(QPoint(2,3) , QSize(width()-4,pixToCover-5));
+          myQRect.moveBottomLeft(QPoint(2,height()-3));
+
+          //Lets build the gradient
+ //         QLinearGradient gradient(myQRect.topLeft(), myQRect.topRight()); // diagonal gradient from top-left to bottom-right
+          QLinearGradient gradient(myQRect.bottomLeft(), myQRect.topLeft()); // diagonal gradient from top-left to bottom-right
+
+          //Lets set the color for the start positon
+          gradient.setColorAt(0, color1);
+          float r =(255*m_value/100.0f);
+          if (r<0)
+              r=0;
+          if (r>255)
+              r=255;
+          r /= 255;
+          //Lets interpolate the second color based on the percentage value
+          gradient.setColorAt(1, QColor(color1.red()* (1-r) + color2.red()*r,
+                                        color1.green()* (1-r) + color2.green()*r,
+                                        color1.blue()* (1-r) + color2.blue()*r,
+                                        255));
+          //Lets draw the gradient
+          painter->fillRect(myQRect, gradient);
+          pen.setColor(QColor(255,255,255,255));
+          QFont font;
+          font.setPointSize(10);
+          painter->setFont(font);
+          painter->setPen(pen);
+  //        painter->drawText(0 + (width()/2),height()/2,QString::number(int(m_value)) + " %");
+          painter->drawText(0,0,width()-1,height()-1,Qt::AlignCenter,QString::number(int(m_value)) + " %");
+}
+
+QT_END_NAMESPACE
+//#include "moc_qdeclarativecpu_p.cpp"
\ No newline at end of file
diff --git a/src/imports/multimedia/BAR/qdeclarativebar_p.h b/src/imports/multimedia/BAR/qdeclarativebar_p.h
new file mode 100644
index 0000000..530c123
--- /dev/null
+++ b/src/imports/multimedia/BAR/qdeclarativebar_p.h
@@ -0,0 +1,41 @@
+#ifndef QDECLARATIVEBAR_P_H
+#define QDECLARATIVEBAR_P_H
+#include <QtQuick/QQuickPaintedItem>
+#include <QColor>
+#include <vector>
+
+
+QT_BEGIN_NAMESPACE
+class QDeclarativeBar : public QQuickPaintedItem
+{
+    Q_OBJECT
+//    Q_PROPERTY(QString name READ name WRITE setName)
+//    Q_PROPERTY(QColor color READ color WRITE setColor)
+    Q_PROPERTY(float value READ read_value WRITE set_value)
+
+public:
+    QDeclarativeBar(QQuickItem *parent = 0);
+
+//    QString name() const;
+//    void setName(const QString &name);
+
+//    QColor color() const;
+//    void setColor(const QColor &color);
+
+    float read_value() const;
+    void set_value (const float &value);
+
+    void paint(QPainter *painter);
+
+private:
+//    QString m_name;
+//    QColor m_color;
+    float m_value;
+    std::vector<float> data;
+};
+
+QT_END_NAMESPACE
+
+//Q_DECLARE_METATYPE(QDeclarativeAxistat::AxistatState)
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativeBar))
+#endif // QDECLARATIVEBAR_P_H
diff --git a/src/imports/multimedia/GRAPH/qdeclarativegraph.cpp b/src/imports/multimedia/GRAPH/qdeclarativegraph.cpp
new file mode 100644
index 0000000..c8e17cf
--- /dev/null
+++ b/src/imports/multimedia/GRAPH/qdeclarativegraph.cpp
@@ -0,0 +1,204 @@
+#include "qdeclarativegraph_p.h"
+#include <QPainter>
+#include <iostream>
+
+QT_BEGIN_NAMESPACE
+QDeclarativeGraph::QDeclarativeGraph(QQuickItem *parent)
+    : QQuickPaintedItem(parent)
+    ,data(20,0)
+{
+}
+
+// QString QDeclarativeGraph::name() const
+// {
+    // return m_name;
+// }
+
+// void QDeclarativeGraph::setName(const QString &name)
+// {
+    // m_name = name;
+// }
+
+float QDeclarativeGraph::read_value() const
+{
+    return m_value;
+}
+
+void QDeclarativeGraph::set_value(const float &value)
+{
+    m_value = value;
+    for (int i=0; i<19; i++)
+    {
+        data[i]=data[i+1];
+    }
+    data[19]=value;
+    update();
+}
+
+
+
+// QColor QDeclarativeGraph::color() const
+// {
+    // return m_color;
+// }
+
+// void QDeclarativeGraph::setColor(const QColor &color)
+// {
+    // m_color = color;
+// }
+
+//![1]
+void QDeclarativeGraph::paint(QPainter *painter)
+{
+/*Graph*/
+    //background
+      QPen pen(QColor(100,100,100,255), 4);
+      painter->setPen(pen);
+      painter->setBrush(QColor(40,40,40,255));
+      painter->drawRoundedRect(0,0,(width()-1),(height()-1),
+                               3,3,Qt::AbsoluteSize);
+      pen.setWidth(1);
+
+      painter->setPen(pen);
+
+    //Grid
+      int stepm_height = height()/15;
+      int stepm_width = width() /15;
+
+      //Draw horizontal lines
+      for (int i = 0; i < stepm_width +1; i++)
+        {
+          painter->drawLine(15*i+2,1
+                        ,15*i+2, height()-1);
+        }
+
+      //Draw vertical lines
+      for (int i = 0; i < stepm_height +1; i++)
+        {
+           painter->drawLine(4,15*i+2,width()-4,
+                        15*i+2);
+        }
+    //Get the size of the data
+        QColor lineColor = (QColor(0,255,0,255));
+        QColor bodyColor = (QColor(0,180,0,120));
+
+
+        int cacheSize = 20;
+        //Calculating the step size between each sample of the data (uniform distribution)
+        float step = float(width()-3)/(cacheSize-1);
+
+        //Setup the colors
+        painter->setPen(lineColor);
+        painter->setBrush(bodyColor);
+
+        //Create a polygon shape
+        QPolygonF poly;
+        int x,y;
+        //Fill in the points to the polygon
+        //Remeber that the height is relative to top left corner so needs to be reversed
+        for( int i = 0; i<cacheSize;i++)
+        {
+            if (i==0)
+            {
+                //The first one is the base , same value of the x but with minimum height value
+                poly.append(QPoint( 0+(i*step+2),height()-2));
+            }
+
+            //Init to min height value
+            y = (height()-2);
+            //convert data in range 0-1 and use it to multiply the height  ( with a small offset)
+            y -= (data[i]/100*(height()-4));
+            //Init value to start position
+            x = 0;
+            //Add the correct positon based on the number of steps taken ( plus  a small offset)
+            if (i == cacheSize -1) 
+            {
+              x+=(i*step);
+            }
+            else 
+            {
+              x +=(i*step+2);
+            }
+            //Append the point
+            poly.append(QPoint(x,y));
+            if(i== cacheSize -1)
+            {
+             //append last point
+             poly.append(QPoint(x,height()-1));
+            }
+        }
+        //Draw the polygon
+        painter->drawPolygon(poly);
+//painter->drawText(0 + (width()/2),height()/2,QString::number(int(m_value)) + " %");
+
+
+
+
+/* Bar */
+/*
+    //background
+      QPen pen(QColor(100,100,100,255), 4);
+      painter->setPen(pen);
+      painter->setBrush(QColor(40,40,40,255));
+      painter->drawRoundedRect(0,0,(width()-1),(height()-1),
+                               3,3,Qt::AbsoluteSize);
+      pen.setWidth(1);
+      pen.setColor(QColor(100,100,100,255));
+      painter->setPen(pen);
+
+    //Grid
+      int stepm_height = height()/10;
+      int stepm_width = width() /10;
+      //Draw horizontal lines
+      for (int i = 0; i < stepm_width +1; i++)
+        {
+          painter->drawLine(10*i+2,1
+                        ,10*i+2, height()-1);
+        }
+      //Draw vertical lines
+      for (int i = 0; i < stepm_height +1; i++)
+        {
+           painter->drawLine(4,10*i+2,width()-4,
+                        10*i+2);
+        }
+
+      //Gradient
+      int pixToCover = height() * m_value/100.0f ;
+      QColor color1 = (QColor(0,255,0,255));
+      QColor color2 = (QColor(255,0,0,255));
+          //Lets build the backaground rectangle
+         // QRect myQRect = QRect(QPoint(2,3) , QSize(pixToCover-5,height()-6));
+          QRect myQRect = QRect(QPoint(2,3) , QSize(width()-4,pixToCover-5));
+          myQRect.moveBottomLeft(QPoint(2,height()-3));
+
+          //Lets build the gradient
+ //         QLinearGradient gradient(myQRect.topLeft(), myQRect.topRight()); // diagonal gradient from top-left to bottom-right
+          QLinearGradient gradient(myQRect.bottomLeft(), myQRect.topLeft()); // diagonal gradient from top-left to bottom-right
+
+          //Lets set the color for the start positon
+          gradient.setColorAt(0, color1);
+          float r =(255*m_value/100.0f);
+          if (r<0)
+              r=0;
+          if (r>255)
+              r=255;
+          r /= 255;
+          //Lets interpolate the second color based on the percentage value
+          gradient.setColorAt(1, QColor(color1.red()* (1-r) + color2.red()*r,
+                                        color1.green()* (1-r) + color2.green()*r,
+                                        color1.blue()* (1-r) + color2.blue()*r,
+                                        255));
+          //Lets draw the gradient
+          painter->fillRect(myQRect, gradient);
+          pen.setColor(QColor(255,255,255,255));
+          QFont font;
+          font.setPointSize(10);
+          painter->setFont(font);
+          painter->setPen(pen);
+  //        painter->drawText(0 + (width()/2),height()/2,QString::number(int(m_value)) + " %");
+          painter->drawText(0,0,width()-1,height()-1,Qt::AlignCenter,QString::number(int(m_value)) + " %");
+*/
+}
+
+QT_END_NAMESPACE
+//#include "moc_qdeclarativecpu_p.cpp"
\ No newline at end of file
diff --git a/src/imports/multimedia/GRAPH/qdeclarativegraph_p.h b/src/imports/multimedia/GRAPH/qdeclarativegraph_p.h
new file mode 100644
index 0000000..977edf0
--- /dev/null
+++ b/src/imports/multimedia/GRAPH/qdeclarativegraph_p.h
@@ -0,0 +1,41 @@
+#ifndef QDECLARATIVEGRAPH_P_H
+#define QDECLARATIVEGRAPH_P_H
+#include <QtQuick/QQuickPaintedItem>
+#include <QColor>
+#include <vector>
+
+
+QT_BEGIN_NAMESPACE
+class QDeclarativeGraph : public QQuickPaintedItem
+{
+    Q_OBJECT
+//    Q_PROPERTY(QString name READ name WRITE setName)
+//    Q_PROPERTY(QColor color READ color WRITE setColor)
+    Q_PROPERTY(float value READ read_value WRITE set_value)
+
+public:
+    QDeclarativeGraph(QQuickItem *parent = 0);
+
+//    QString name() const;
+//    void setName(const QString &name);
+
+//    QColor color() const;
+//    void setColor(const QColor &color);
+
+    float read_value() const;
+    void set_value (const float &value);
+
+    void paint(QPainter *painter);
+
+private:
+//    QString m_name;
+//    QColor m_color;
+    float m_value;
+    std::vector<float> data;
+};
+
+QT_END_NAMESPACE
+
+//Q_DECLARE_METATYPE(QDeclarativeAxistat::AxistatState)
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativeGraph))
+#endif // QDECLARATIVEGRAPH_P_H
diff --git a/src/imports/multimedia/PERFORMANCE/dataQuery/cpudataquery.cpp b/src/imports/multimedia/PERFORMANCE/dataQuery/cpudataquery.cpp
new file mode 100644
index 0000000..701f618
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/dataQuery/cpudataquery.cpp
@@ -0,0 +1,34 @@
+#include "cpudataquery.h"
+#include <QtCore>
+CpuDataQuery::CpuDataQuery() : DataQuery()
+{ 
+//   qDebug() << Q_FUNC_INFO;
+}
+
+
+void CpuDataQuery::getData()
+{
+    m_cpu.getCPUs();
+
+    //if we draw a single graph we only get the cache for the
+    //current cpu and store it in m_singleCache
+    if (m_multi == 0)
+    {
+        m_cpu.getOrderedCpuCache(m_index, m_cache);
+    }
+    //if we draw a cache for all cpus then we grab all the cpu caches
+    //and store the result in m_cache
+    else
+    {
+        m_cpu.getOrderedCpusCache(m_cache);
+
+    }
+
+}
+
+
+int CpuDataQuery::getNumberOfCores()
+{
+    return m_cpu.getNumberOfCores();
+
+}
diff --git a/src/imports/multimedia/PERFORMANCE/dataQuery/cpudataquery.h b/src/imports/multimedia/PERFORMANCE/dataQuery/cpudataquery.h
new file mode 100644
index 0000000..4a324b1
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/dataQuery/cpudataquery.h
@@ -0,0 +1,44 @@
+#ifndef CPUDATAQUERY_H
+#define CPUDATAQUERY_H
+#include "dataquery.h"
+#include "queryresource.h"
+
+/** @brief This class is used to read cpu data for the widget
+  *
+  * This class subclass DataQuery absatract class, it specialize it in order
+  * to read the cpu data.
+  * This class performs different queryies based on two values sets in the class
+  * which are L
+  * \li index : defines which cpu to read if multi is off , ranges for the number
+                of cores
+  * \li multi : If set to on it will generate data for all the different cores plus
+                the average of the cpus
+                Meaning if set to on the size of the  cache will be numberOfCores +1
+                the average cpus is stored at index 0
+  */
+
+class CpuDataQuery : public DataQuery
+{
+public:
+    /// The constructor
+    CpuDataQuery();
+    /// The destructor
+    ~CpuDataQuery(){}
+    /// This function gather all the data needed and stores it internally in the
+    /// cache attribute
+    void getData();
+    /**
+     * @brief This procedure returns the number of cores
+     * @return int, number of cores
+     */
+    int getNumberOfCores();
+
+
+
+private :
+    /// The class used for general cpu query
+    CpuQuery m_cpu;
+
+};
+
+#endif // CPUDATAQUERY_H
diff --git a/src/imports/multimedia/PERFORMANCE/dataQuery/dataquery.cpp b/src/imports/multimedia/PERFORMANCE/dataQuery/dataquery.cpp
new file mode 100644
index 0000000..5add40b
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/dataQuery/dataquery.cpp
@@ -0,0 +1,21 @@
+#include "dataquery.h"
+#include <QtCore>
+DataQuery::DataQuery():m_index(0), m_multi(0)
+{
+//qDebug() << Q_FUNC_INFO;
+}
+
+
+
+void DataQuery::setIndex(int index)
+{
+
+    m_index = index;
+
+}
+
+void DataQuery::setMulti( bool value)
+{
+    m_multi = value;
+}
+
diff --git a/src/imports/multimedia/PERFORMANCE/dataQuery/dataquery.h b/src/imports/multimedia/PERFORMANCE/dataQuery/dataquery.h
new file mode 100644
index 0000000..284a49c
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/dataQuery/dataquery.h
@@ -0,0 +1,46 @@
+#ifndef DATAQUERY_H
+#define DATAQUERY_H
+#include <iostream>
+#include <stdio.h>
+#include <vector>
+/**
+  *@brief This class is an abstract class used to generate classes for data fetching
+  *
+  *This class is is used as a base for implementing different type of
+  *classes used to query different type of data.
+  *You will need to reimplement the virtual fucntions getData and destructor
+  *The data you will fetch will need to be stored in the m_cache member
+  * which is a 2D std::vector<float> matrix.
+  * You also have a couplw of variables you can use in your computation
+  * if needed :
+  *  \li m_index
+  *  \li m_multi
+  */
+
+class DataQuery
+{
+public:
+    /// The constructor
+    DataQuery();
+    /// The destructor
+    virtual ~DataQuery(){}
+    /// The virtual fucntion to reimplement used to gather the data
+    virtual void getData(){}
+    /** Setter function for the index
+    * @param index : the value at which you want to set the index
+    */
+    void setIndex(int index);
+    /** Setter funtcion for the multi variable
+    * @param value : wheter or not to set the multi attribute to on or off
+    */
+    void setMulti(bool value);
+
+
+public :
+    int m_index;
+    int m_multi;
+    /// The cache used to store all the data
+    std::vector<std::vector<float> > m_cache;
+};
+
+#endif // DATAQUERY_H
diff --git a/src/imports/multimedia/PERFORMANCE/dataQuery/queryresource.cpp b/src/imports/multimedia/PERFORMANCE/dataQuery/queryresource.cpp
new file mode 100644
index 0000000..9a09c6f
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/dataQuery/queryresource.cpp
@@ -0,0 +1,326 @@
+#include "queryresource.h"
+#include <stdio.h>
+#include <iostream>
+#include <unistd.h>
+#include <sstream>
+#include <QtCore>
+
+CpuQuery::CpuQuery():m_percent(0.0),m_cacheSize(30),
+    m_cacheStartIndex(0)
+{
+//qDebug() << Q_FUNC_INFO;
+    //Initializing number of cores
+     m_numberOfCores = sysconf(_SC_NPROCESSORS_ONLN);
+
+     //Initializing cache vectors
+     m_lastTotalUser = std::vector<int>(m_numberOfCores +1,0);
+     m_lastTotalUserLow = std::vector<int>(m_numberOfCores +1,0);
+     m_lastTotalSys = std::vector<int>(m_numberOfCores +1,0);
+     m_lastTotalIdle = std::vector<int>(m_numberOfCores +1,0);
+
+     m_percentages = std::vector<std::vector<float> >
+             (m_numberOfCores +1, std::vector<float>(m_cacheSize,0));
+
+     //Init data
+     getCPUs();
+
+}
+
+
+
+void CpuQuery::getCPUs()
+{
+        //Initialize if stram
+        std::ifstream filess("/proc/stat");
+        std::string line;
+        i=0;
+        while (std::getline(filess, line))
+        {
+
+                //loop the cores
+                if (i <= (m_numberOfCores))
+                {
+
+                //storing the cache index
+                int currCacheIndex = m_cacheStartIndex-1;
+//                std::cout<<"DEBUG: CpuQuery "<<currCacheIndex<<std::endl;
+//                std::cout<<"DEBUG: CpuQuery "<<m_cacheStartIndex<<std::endl;
+
+                if (currCacheIndex < 0)
+                {
+                    currCacheIndex = m_cacheSize -1;
+                }
+//                std::cout<<currCacheIndex<<std::endl;
+
+                    std::stringstream ss;
+                    //get the cpu name
+                    ss <<line;
+                    //Get different data usage
+                    ss >>m_tempStr;
+                    ss>>m_totalUser;
+                    ss>>m_totalUserLow;
+                    ss>>m_totalSys;
+                    ss>>m_totalIdle;
+
+                    //Compute the percentage
+                    if (m_totalUser < m_lastTotalUser[i] ||
+                        m_totalUserLow < m_lastTotalUserLow[i] ||
+                        m_totalSys < m_lastTotalSys[i] ||
+                        m_totalIdle < m_lastTotalIdle[i])
+                    {
+                        //Overflow detection. Just skip this value.
+                        m_percent = -1.0;
+                        m_percentages[i][currCacheIndex]=m_percent;
+                    }
+                    else
+                    {
+                        m_total = (m_totalUser -m_lastTotalUser[i]) +
+                                (m_totalUserLow - m_lastTotalUserLow[i]) +
+                            (m_totalSys - m_lastTotalSys[i]);
+                        m_percent = m_total;
+                        m_total += (m_totalIdle - m_lastTotalIdle[i]);
+
+                        //Check if we got a valid result
+                        if (m_total > 0 )
+                        {
+                            m_percent /= m_total;
+                        m_percent *= 100;
+                        }
+                        else
+                        {
+                            m_percent =0;
+                        }
+                        //store the data in correct cache index
+                        m_percentages[i][currCacheIndex]=m_percent;
+                    }
+
+                    //store the data in the cache for next iteration
+                    m_lastTotalUser[i] = m_totalUser;
+                    m_lastTotalUserLow[i] = m_totalUserLow;
+                    m_lastTotalSys[i] = m_totalSys;
+                    m_lastTotalIdle[i] = m_totalIdle;
+
+
+
+
+                }
+                else
+                {break;}
+                i++;
+        }
+
+        //loop the cache index
+        m_cacheStartIndex++;
+        if ( m_cacheStartIndex > (m_cacheSize -1))
+        {
+            m_cacheStartIndex = 0;
+        }
+
+
+  }
+
+void CpuQuery::getInstantCPU(const int &coreIDx ,
+                             std::vector<std::vector<float> > &cache)
+{
+    //resize incoming cache
+    cache.resize(1);
+    cache[0].resize(1);
+    //store the data in the cache if ithe core idx is a valid index
+    if (coreIDx <= m_numberOfCores +1)
+        cache[0][0] = m_percentages[coreIDx][m_cacheStartIndex];
+
+    else
+        cache[0][0] = -1;
+}
+
+void CpuQuery::getAllInstantCPUs(std::vector<std::vector<float> > &cache)
+{
+    //resize incoming cache
+    cache.resize(1);
+    cache[0].resize(m_numberOfCores +1);
+
+    //store correct data
+    for (int i = 0; i <m_numberOfCores +1;i++)
+    {
+        cache[0][i] = m_percentages[i][m_cacheStartIndex];
+
+    }
+
+
+}
+
+const std::vector<float>& CpuQuery::getCpuCache(const int &coreIDx)
+{
+
+    return m_percentages[coreIDx];
+
+}
+
+void CpuQuery::getOrderedCpuCache(const int &coreIDx , std::vector<std::vector<float> > &cache )
+{
+    //resize incoming cache
+    cache.resize(1);
+    cache[0].resize(m_cacheSize);
+    //reorder wanted cache and store it correctly in the target cache
+    reorderCache(m_percentages[coreIDx] , cache[0]);
+
+
+
+}
+
+void CpuQuery::getOrderedCpusCache(std::vector<std::vector<float> > &cache)
+{
+
+    //resize incoming cache
+    cache.resize(m_numberOfCores +1);
+    for (int j = 0 ;j < m_numberOfCores +1; j++)
+    {
+        cache[j].resize(m_cacheSize);
+        reorderCache(m_percentages[j] , cache[j]);
+
+    }
+
+
+
+}
+
+void CpuQuery::reorderCache(std::vector<float> &source, std::vector<float> &target)
+{
+    //let s make a copy of the internal start index so we can use it to loop it
+    int tempIndex = int(m_cacheStartIndex)-1;
+    //loop cache size
+    for (i =0 ; i < m_cacheSize ;i++)
+    {
+
+        target[i]= source[tempIndex];
+        tempIndex ++;
+        if ( tempIndex > (m_cacheSize-1 ))
+        {
+            tempIndex = 0;
+        }
+    }
+
+
+}
+
+int CpuQuery::getNumberOfCores()
+{
+    return sysconf(_SC_NPROCESSORS_ONLN);
+}
+
+
+MemoryQuery::MemoryQuery() : m_memoryUnit(GIGA_BYTE) ,
+                             m_cacheSize(30),
+                             m_cacheStartIndex(0)
+
+{
+    m_cache.resize(m_cacheSize);
+
+}
+
+float MemoryQuery::getTotalMem()
+{
+
+    long bytes =    sysconf( _SC_PHYS_PAGES) * sysconf( _SC_PAGESIZE );
+    return convertMemory(bytes);
+
+}
+
+
+
+float MemoryQuery::getUsedMem()
+{
+    long bytes =  (sysconf( _SC_PHYS_PAGES) * sysconf( _SC_PAGESIZE ))-
+            sysconf( _SC_AVPHYS_PAGES) * sysconf( _SC_PAGESIZE );
+    return convertMemory(bytes);
+
+
+}
+
+
+float MemoryQuery::getFreeMemory()
+{
+    long bytes =sysconf( _SC_AVPHYS_PAGES) * sysconf( _SC_PAGESIZE );
+    return convertMemory(bytes);
+
+}
+
+
+float MemoryQuery::getMemoryUsage()
+{
+    float percentage = float(getUsedMem())/getTotalMem()*100.0f;
+    int currCacheIndex = m_cacheStartIndex-1;
+    if (currCacheIndex < 0)
+    {
+        currCacheIndex = m_cacheSize -1;
+    }
+    m_cache[currCacheIndex] =   percentage;
+
+
+    //loop the cache index
+    m_cacheStartIndex++;
+    if ( m_cacheStartIndex > (m_cacheSize -1))
+    {
+        m_cacheStartIndex = 0;
+    }
+
+
+    return percentage;
+
+}
+
+float MemoryQuery::convertMemory( long bytes)
+{
+
+    float toReturn = 0 ;
+    switch(m_memoryUnit)
+    {
+    case 0 :
+
+        toReturn= float(bytes)/MEGA_BYTE_MULT;
+        break;
+    case 1 :
+        toReturn= float(bytes)/GIGA_BYTE_MULT;
+        break;
+
+    }
+
+    return toReturn;
+
+}
+
+
+const std::vector<float>&  MemoryQuery::getMemoryUsageCache()
+{
+        return m_cache;
+}
+
+void MemoryQuery::getOrderedMemoryUsageCache(std::vector<float>  &cache)
+{
+
+    //resize incoming cache
+    cache.resize(m_cacheSize);
+//    cache[0].resize(m_cacheSize);
+    //reorder wanted cache and store it correctly in the target cache
+    reorderCache(m_cache , cache);
+
+}
+
+void MemoryQuery::reorderCache(std::vector<float> &source, std::vector<float> &target)
+{
+    //let s make a copy of the internal start index so we can use it to loop it
+    int tempIndex = int(m_cacheStartIndex)-1;
+    //loop cache size
+    for (int i =0 ; i < m_cacheSize ;i++)
+    {
+
+        target[i]= source[tempIndex];
+        tempIndex ++;
+        if ( tempIndex > (m_cacheSize-1 ))
+        {
+            tempIndex = 0;
+        }
+    }
+
+
+}
diff --git a/src/imports/multimedia/PERFORMANCE/dataQuery/queryresource.h b/src/imports/multimedia/PERFORMANCE/dataQuery/queryresource.h
new file mode 100644
index 0000000..924547d
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/dataQuery/queryresource.h
@@ -0,0 +1,211 @@
+#ifndef QUERYRESOURSCE_H
+#define QUERYRESOURSCE_H
+
+
+#include "stdlib.h"
+#include "stdio.h"
+#include "string.h"
+#include <fstream>
+#include <iostream>
+#include <vector>
+
+/** @brief General querying cpus data class
+*/
+
+class CpuQuery
+{
+public:
+    /**
+    This is the constructor
+    */
+    CpuQuery();
+
+    /**
+    This procedure parse the "/proc/stat" file
+    to query the cpu data, then you can query the
+    the data stored internally in the class with one
+    of the method below
+    */
+    void getCPUs();
+
+    /**
+    *This procedrue get the instant cpu usage of the cpu index
+    *provided
+    *@param coreIDx : the index of the cpu you want to query,
+    *                it ranges from zero to numberOfCores included
+    *                where the zero index is an average of all cpus.\n
+    *               Example : if you have an 8 core cpu in order to get
+    *               the value for the 8th cpu you need to query for the
+    *               8 index and not the 7th as you might have expected
+    *@param cache : where to store the data, the cache is dinamically resized
+    *              to a 1D matrix with one row and number of columns equal to the
+    *              private attribute m_cacheSize
+    */
+    void getInstantCPU(const int &coreIDx ,
+                       std::vector<std::vector<float> > &cache);
+    /** This procedure returns a vector containing the cache for the given cpu
+      * index
+      * @param coreIDx : which core to query
+    */
+    const std::vector<float>& getCpuCache(const int &coreIDx);
+
+    /**
+      * This procedure gets an ordered cpu for the given core index
+      * the cache internally is not ordered, in order to save in memory copies
+      * the start index of the cache is looping trough the lenght of the cache
+      * meaning that when you acces the data , the start of the cache wont be at
+      * index 0.
+      * This procedure reoders the cache and stores it in the provided vector
+      * @param coreIDx : which core to query
+      * @param cache : the structure in which to store the data
+      */
+    void  getOrderedCpuCache(const int &coreIDx , std::vector<std::vector<float> > &cache );
+
+    /**
+      *This procedure gathers all the ordered caches for all cpus
+      * @param cache : the structure in which to store the data
+      */
+    void  getOrderedCpusCache( std::vector<std::vector<float> > &cache );
+
+    /**
+      *This procedure generate a 1D matrix with all the current cpu value,
+      * it wont generate a cache but only istant value, the structure of
+      * the data will be as many columns as cores + 1 and one row
+      * @param cache : the structure in which to store the data
+      */
+    void getAllInstantCPUs(std::vector<std::vector<float> > &cache);
+
+    /**
+     * This procedure returns the number of core of our cpu
+     * @return int : The number of cores
+     */
+    int getNumberOfCores();
+private :
+    /** This procedure reorders an input cache into the target cache
+      * The two data structure should have the same size
+      * no check performed internally so far
+    * @param souce : the source data to reorder
+    * @param target : the target structure in which we will store the re-ordered
+                      data
+    */
+    void reorderCache( std::vector<float> &source,
+                       std::vector<float> &target);
+
+private :
+    /// Internal variable storing the number of cores
+    int m_numberOfCores;
+    /// Working variable used to store the percentage of the core
+    float m_percent;
+    int m_totalUser;
+    int m_totalUserLow;
+    int m_totalSys;
+    int m_totalIdle;
+    int m_total;
+
+    /// Internal working data holding the cache for partial core usage
+    std::vector<int>m_lastTotalUser;
+    std::vector<int>m_lastTotalUserLow;
+    std::vector<int>m_lastTotalSys;
+    std::vector<int>m_lastTotalIdle;
+
+    /// Internal working variable
+    std::string m_tempStr;
+    int i;
+
+    /// Attribute holding the size of the internal cache
+    int m_cacheSize;
+    /// Attribute holding the start index of the cache
+    int m_cacheStartIndex;
+    /// Internal 2D matrix holding all the percentage computed (up to cache size)
+    std::vector<std::vector<float> >m_percentages;
+
+
+};
+/** @brief General querying memory/RAM data class
+*/
+class MemoryQuery
+{
+    /// Megabyte size used internally
+    static const long MEGA_BYTE_MULT = 1048576;
+    /// Gigabyte size used internally
+    static const long GIGA_BYTE_MULT = 1073741824;
+
+
+public :
+    /// Constructor
+    MemoryQuery();
+    /**
+      @brief Returns the system total memory
+      @return float, the size of the system memory, the unit is defined by
+                memory unit attribute, you can set it with the setter function
+                setMemoryUnit(memoryUnit unit);
+    */
+    float getTotalMem();
+
+    /**
+      @brief Returns the system used memory
+      @return float, the size of the system memory, the unit is defined by
+                memory unit attribute, you can set it with the setter function
+                setMemoryUnit(memoryUnit unit);
+    */
+    float getUsedMem();
+    /**
+      @brief Returns the system free memory
+      @return float, the size of the system memory, the unit is defined by
+                memory unit attribute, you can set it with the setter function
+                setMemoryUnit(memoryUnit unit);
+    */
+    float getFreeMemory();
+    /**
+      @brief Returns the system used memory
+      @return float, a percentage of the used memory
+    */
+    float getMemoryUsage();
+    const std::vector<float>& getMemoryUsageCache();
+    /**
+      @brief Returns the system used memory percentages ad a cache,
+            cache is not ordered
+      @param cache : the cache to be filled, dont worry about the size,
+                    cache is gonna be riesized to fit
+      @return , the size of the cache is defined internally
+    */
+    void getOrderedMemoryUsageCache(std::vector<float>  &cache);
+
+private:
+    /**
+      @brief This procedure reorders a cache
+      @param source : the source cache to be reordered
+      @param target : where to put the ordered cache , the operation is not in
+      place means the source is not modified
+*/
+    void reorderCache(std::vector<float> &source, std::vector<float> &target);
+
+    /// Define wheter to use mega or gigabye for the memory size,
+    /// default of the class is GIGA_BYTE
+    enum memoryUnit
+    {
+        MEGA_BYTE = 0,
+        GIGA_BYTE = 1
+    };
+
+private :
+    /**
+      @brief This procedure returns the memory converted based
+      on the setting of the class
+      */
+    float convertMemory( long bytes);
+    /// Current internal memory unit
+    memoryUnit m_memoryUnit;
+    /// Attribute holding the size of the internal cache
+    int m_cacheSize;
+    /// Attribute holding the start index of the cache
+    int m_cacheStartIndex;
+    std::vector<float> m_cache;
+
+
+};
+#endif // QUERYRESOURSCE_H
+
+
+
+
diff --git a/src/imports/multimedia/PERFORMANCE/dataQuery/ramdataquery.cpp b/src/imports/multimedia/PERFORMANCE/dataQuery/ramdataquery.cpp
new file mode 100644
index 0000000..01e3796
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/dataQuery/ramdataquery.cpp
@@ -0,0 +1,19 @@
+#include "ramdataquery.h"
+
+RamDataQuery::RamDataQuery()
+{
+    m_cache.resize(1);
+
+}
+
+
+void RamDataQuery::getData()
+{
+    //Update the data in the cache , this function also returns
+    //the instant memory usage but we discard it since we actually
+    // need the cache
+    m_mem.getMemoryUsage();
+    //Get the ordered data
+    m_mem.getOrderedMemoryUsageCache(m_cache[0]);
+
+}
diff --git a/src/imports/multimedia/PERFORMANCE/dataQuery/ramdataquery.h b/src/imports/multimedia/PERFORMANCE/dataQuery/ramdataquery.h
new file mode 100644
index 0000000..d7efe4c
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/dataQuery/ramdataquery.h
@@ -0,0 +1,32 @@
+#ifndef RAMDATAQUERY_H
+#define RAMDATAQUERY_H
+#include "queryresource.h"
+#include "dataquery.h"
+
+
+/**
+  @brief This class is used to query the ram data for the performance widge
+ */
+
+class RamDataQuery : public DataQuery
+{
+public:
+    /// The constructor
+    RamDataQuery();
+    /// The destructor
+    ~RamDataQuery(){}
+    /// This function gather all the data needed and stores it internally in the
+    /// cache attribute
+    void getData();
+
+
+
+
+private :
+    /// The class used for general memory query
+    MemoryQuery m_mem;
+
+};
+
+
+#endif // RAMDATAQUERY_H
diff --git a/src/imports/multimedia/PERFORMANCE/painters/barspainter.cpp b/src/imports/multimedia/PERFORMANCE/painters/barspainter.cpp
new file mode 100644
index 0000000..d907e3f
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/painters/barspainter.cpp
@@ -0,0 +1,61 @@
+#include "barspainter.h"
+#include "painterutils.h"
+#include <iostream>
+BarsPainter::BarsPainter(QPaintDevice * widget) :
+    PerformancePainter(widget)
+
+{
+    // Initializing colors
+    m_color1 =(QColor(0,255,0,255));
+    m_color2 = (QColor(255,0,0,255));
+//    m_color1 =(QColor(0,255,255,255));
+//    m_color2 = (QColor(127,128,0,255));
+}
+
+void BarsPainter::paint()
+{
+    //Create a new painter
+    QPainter qpN(m_widget);
+    //Draw gird and BG
+    drawBackground(qpN);
+    drawGrid(qpN);
+
+    //Set a white color for the main rectangle
+    qpN.setPen(QColor(255,255,255,255));
+
+
+    //Compute size of the data and step size
+    int size = m_cache.size();
+    if (size <= 0)
+    {
+        std::cout<<"ERROR : NO DATA PROVIDED, CACHE SIZE IS 0"<<std::endl;
+        return;
+    }
+    float steps = (m_width-size ) / (size);
+
+    int subSize = m_cache[0].size();
+
+    //Lets loop for each bar needed to be drawn
+    for(int i = 0 ; i < size;i++)
+    {
+        //Let set the background color (zero alpha is transparent)
+        qpN.setBrush(QColor(100,100,100,0));
+
+        //Lets draw the container rectangle
+        qpN.drawRoundedRect((steps*(i))+(i*2) ,0,(steps),m_height-1,
+                         3,3,Qt::AbsoluteSize);
+
+        //Lets theck if the size is big enough to contain the percentage value
+        //Then lets draw the actual rectangle
+        if (steps > 80)
+            painterUtils::drawRectangleBar(qpN ,i*steps+3 + i*2,steps,
+                                           m_height,m_cache[i][subSize-1], true,
+                                           m_color1,
+                                           m_color2);
+        else
+            painterUtils::drawRectangleBar(qpN ,i*steps+3 + i*2,steps,
+                                           m_height,m_cache[i][subSize-1], false,
+                                           m_color1,
+                                           m_color2);
+    }
+}
diff --git a/src/imports/multimedia/PERFORMANCE/painters/barspainter.h b/src/imports/multimedia/PERFORMANCE/painters/barspainter.h
new file mode 100644
index 0000000..23c3179
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/painters/barspainter.h
@@ -0,0 +1,38 @@
+#ifndef BARSPAINTER_H
+#define BARSPAINTER_H
+#include "performancepainter.h"
+
+/**
+ * @brief This class is draws bar graphs
+ *
+ * This class is a subclass of the abstract class PerformancePainter.
+ * It implements a draw of bars graphs of which we have an example here
+ *
+ * \li \c Single Bar:
+ * if the data contains just one value it s going to draw something like this
+ * @image html performanceSingleBar.png "Single bar view"
+ *
+ * \li \c Multiple Bar:
+ * if the data is an array, is going to draw one bar for each value in the
+ * array and will look something like this.
+ *@image html performanceMultiBar.png "Multi bar view"
+ */
+
+class BarsPainter : public PerformancePainter
+{
+public:
+    /**
+     * @brief The constructor
+     * @param widget : This is a paintable widget at wich the painter is associated
+     */
+    BarsPainter(QPaintDevice * widget);
+    ///Destructor
+    ~BarsPainter(){}
+    ///Reimplemented paint function
+    void paint();
+
+};
+
+
+#endif // BARSPAINTER_H
+
diff --git a/src/imports/multimedia/PERFORMANCE/painters/graphmulticolorpainter.cpp b/src/imports/multimedia/PERFORMANCE/painters/graphmulticolorpainter.cpp
new file mode 100644
index 0000000..6c0018f
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/painters/graphmulticolorpainter.cpp
@@ -0,0 +1,110 @@
+#include "graphmulticolorpainter.h"
+#include "painterutils.h"
+#include <stdio.h>
+#include <iostream>
+
+
+GraphMultiColorPainter::GraphMultiColorPainter(QPaintDevice * widget):
+PerformancePainter(widget)
+
+{
+    // Initializing colors
+    m_color1 =(QColor(0,255,0,255));
+    m_color2 = (QColor(0,180,0,0));
+
+    //init colors
+    m_colors.clear();
+    m_colors.push_back(QColor(  255, 255, 0));
+    m_colors.push_back(QColor( 255, 127, 0));
+    m_colors.push_back(QColor( 255, 0, 0));
+    m_colors.push_back(QColor( 127, 255, 0));
+
+    m_colors.push_back(QColor(  0, 255, 0));
+    m_colors.push_back(QColor( 0, 255, 127));
+    m_colors.push_back(QColor( 0, 255, 255));
+    m_colors.push_back(QColor(  0, 127, 255));
+
+    m_colors.push_back(QColor( 0, 0, 255));
+    m_colors.push_back(QColor( 127, 0, 255));
+    m_colors.push_back(QColor( 255, 0, 255));
+    m_colors.push_back(QColor( 255, 0, 127));
+}
+
+
+
+
+
+void GraphMultiColorPainter::checkColors( )
+{
+    //Lets check if we have enough color for all the data
+    int currSize = m_colors.size();
+    int  numberOfColors = m_cache.size();
+
+    //if the color we need are less then the current available colors lets get out
+    if (numberOfColors <= currSize)
+        return;
+
+    //if not lets create random colors
+    for(int i = 0; i < (numberOfColors - currSize) ; i++)
+    {
+
+
+        QColor temp(int(rand() * float(COLOR_RANGE) / RAND_MAX),
+                    int(rand() * float(COLOR_RANGE) / RAND_MAX),
+                    int(rand() * float(COLOR_RANGE) / RAND_MAX),
+                    255);
+
+        m_colors.push_back(temp);
+
+    }
+
+}
+
+
+void GraphMultiColorPainter::paint()
+{
+
+    //checkColors
+    checkColors();
+
+
+    QColor m_back = QColor(0,180,0,0);
+
+    //Create a new painter
+    QPainter qpN(m_widget);
+    //Draw gird and BG
+    drawBackground(qpN);
+    drawGrid(qpN);
+    //Compute size of the data and step size
+    int size = m_cache.size();
+    qpN.setBrush(m_back);
+    qpN.drawRoundedRect(0 ,0,m_width -2 ,m_height-1,
+                     3,3,Qt::AbsoluteSize);
+
+    bool legendOnOff = (MIN_LEGEND_WIDTH * size) <= m_width;
+
+
+    for(int i = 0 ; i < (size);i++)
+    {
+       //lets use our utils to draw the graph
+       m_back = m_colors[size-i-1];
+       m_back.setAlpha(80);
+       painterUtils:: drawRectangleGraph(qpN,0,
+                                         m_width,m_height,m_cache[size-i-1],
+                                         m_colors[size-i-1],m_back);
+
+       //paint legend
+       if (legendOnOff )
+       {
+                QString text = QString("#") + QString::number(size-i-1);
+                qpN.drawText(MIN_LEGEND_WIDTH *(size-i-1) +5,15,text);
+
+
+
+       }
+    }
+
+
+}
+
+
diff --git a/src/imports/multimedia/PERFORMANCE/painters/graphmulticolorpainter.h b/src/imports/multimedia/PERFORMANCE/painters/graphmulticolorpainter.h
new file mode 100644
index 0000000..a571c04
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/painters/graphmulticolorpainter.h
@@ -0,0 +1,49 @@
+#ifndef GRAPHMULTICOLORPAINTER_H
+#define GRAPHMULTICOLORPAINTER_H
+
+#include "performancepainter.h"
+
+/**
+ * @brief This class is draws one graph with multiples lines
+ *
+ * This class is a subclass of the abstract class PerformancePainter.
+ * It implements a draw just one graph but with all the data in it rappresented as multiple line,
+ *  of which we have an example here :
+ *
+ * each row in the 2D matrix/array is going to be agraph and each column of that row is going to be a value
+ * of the graph
+ * @image html performanceMultiColorGraph.png "Mulit Color Graph"
+ */
+class GraphMultiColorPainter : public PerformancePainter
+{
+public:
+    /**
+     * @brief The constructor
+     * @param widget : This is a paintable widget at wich the painter is associated
+     */
+    GraphMultiColorPainter(QPaintDevice * widget);
+    /// Destructor
+    ~GraphMultiColorPainter(){}
+    /// Reimplemented paint function
+    void paint();
+
+private:
+    ///This procedrue checks that we have enough color to produce the graph
+    void checkColors();
+
+
+private :
+    //List of colors used for the graph
+    std::vector<QColor> m_colors;
+    //Constant for the color range
+    static const int COLOR_RANGE = 255;
+    //Constant for the minimum legend with, this is whats the minimum space required for each
+    // number of the legend
+    static const int MIN_LEGEND_WIDTH = 30;
+
+
+};
+
+
+
+#endif // GRAPHMULTICOLORPAINTER_H
diff --git a/src/imports/multimedia/PERFORMANCE/painters/graphpainter.cpp b/src/imports/multimedia/PERFORMANCE/painters/graphpainter.cpp
new file mode 100644
index 0000000..fb23f5e
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/painters/graphpainter.cpp
@@ -0,0 +1,57 @@
+#include "graphpainter.h"
+#include "painterutils.h"
+#include <stdio.h>
+#include <iostream>
+GraphPainter::GraphPainter(QPaintDevice * widget):
+PerformancePainter(widget)
+
+{
+    // Initializing colors
+    m_color1 =(QColor(0,255,0,255));
+    m_color2 = (QColor(0,180,0,120));
+
+}
+
+
+
+void GraphPainter::paint()
+{
+    //Create a new painter
+    QPainter qpN(m_widget);
+    //Draw gird and BG
+    drawBackground(qpN);
+    drawGrid(qpN);
+
+    //Set a white color for the main rectangle
+    qpN.setPen(QColor(255,255,255,255));
+
+    //Compute size of the data and step size
+    int size = m_cache.size();
+    int sizeLess  = size -1;
+
+    if (sizeLess <= 0)
+    {
+        sizeLess = 1;
+
+    }
+    float steps = (m_width- m_cache.size() ) / (size);
+    for(int i = 0 ; i < (size);i++)
+    {
+        //Let set needed colors for the background and borer
+        qpN.setPen(QColor(244,244,244,255));
+        qpN.setBrush(QColor(100,100,100,0));
+        qpN.drawRoundedRect((steps*(i))+(i*2) ,0,(steps),m_height-1,
+                         3,3,Qt::AbsoluteSize);
+
+       //lets use our utils to draw the graph
+       painterUtils:: drawRectangleGraph(qpN,(steps*(i))+(i*2)-1,
+                                         steps,m_height,m_cache[i],
+                                         m_color1,m_color2);
+
+
+        }
+
+
+}
+
+
diff --git a/src/imports/multimedia/PERFORMANCE/painters/graphpainter.h b/src/imports/multimedia/PERFORMANCE/painters/graphpainter.h
new file mode 100644
index 0000000..6ac2d15
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/painters/graphpainter.h
@@ -0,0 +1,35 @@
+#ifndef GRAPHPAINTER_H
+#define GRAPHPAINTER_H
+#include "performancepainter.h"
+
+/**
+ * @brief This class is draws regular one line graphs
+ *
+ * This class is a subclass of the abstract class PerformancePainter.
+ * It implements a draw of regular one line graphs of which we have an example here
+ *
+ * \li \c Single Graph:
+ * if the matrix/2D array contains just one row it s going to draw something like this
+ * @image html performanceSingleGraph.png "Single Graph view"
+ *
+ * \li \c Multiple Graph:
+ * if the data is a 2D array (vector of vectors), is going to draw one graph for each row in the
+ * matrix/array and will look something like this.
+ *@image html performanceMultiGraph.png "Multi Graph view"
+ */
+class GraphPainter : public PerformancePainter
+{
+public:
+    /**
+     * @brief The constructor
+     * @param widget : This is a paintable widget at wich the painter is associated
+     */
+    GraphPainter(QPaintDevice * widget);
+    /// Destructor
+    ~GraphPainter(){}
+    ///Reimplemented paint function
+    void paint();
+
+};
+
+#endif // GRAPHPAINTER_H
diff --git a/src/imports/multimedia/PERFORMANCE/painters/painterutils.cpp b/src/imports/multimedia/PERFORMANCE/painters/painterutils.cpp
new file mode 100644
index 0000000..f0bc5af
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/painters/painterutils.cpp
@@ -0,0 +1,102 @@
+#include "painterutils.h"
+
+painterUtils::painterUtils()
+{
+}
+
+
+void painterUtils::drawRectangleGraph(QPainter &qp ,int const &startPos,
+                                      int const &width,int const &height,
+                                      std::vector<float>  &data,
+                                      QColor &lineColor , QColor &bodyColor)
+
+
+{
+    //Get the size of the data
+    int cacheSize = data.size();
+    //Calculating the step size between each sample of the data (uniform distribution)
+    float step = float(width-3)/(cacheSize-1);
+
+    //Setup the colors
+    qp.setPen(lineColor);
+    qp.setBrush(bodyColor);
+
+    //Create a polygon shape
+    QPolygonF poly;
+    int x,y;
+    //Fill in the points to the polygon
+    //Remeber that the height is relative to top left corner so needs to be reversed
+    for( int i =0; i<cacheSize;i++)
+    {
+        if (i==0)
+        {
+            //The first one is the base , same value of the x but with minimum height value
+            poly.append(QPoint( startPos+(i*step+2),height-1));
+        }
+
+        //Init to min height value
+        y = (height-1);
+        //convert data in range 0-1 and use it to multiply the height  ( with a small offset)
+        y -= (data[i]/100*(height-5));
+        //Init value to start position
+        x = startPos;
+        //Add the correct positon based on the number of steps taken ( plus  a small offset)
+        x +=(i*step+2);
+        //Append the point
+        poly.append(QPoint(x,y));
+        if(i== cacheSize -1)
+        {
+         //append last point
+         poly.append(QPoint(x,height-1));
+        }
+    }
+    //Draw the polygon
+    qp.drawPolygon(poly);
+
+
+}
+
+void painterUtils::drawRectangleBar(QPainter &qp ,int const &startPos,int const &width,
+                                    int const &height
+                                 ,const float value, bool drawText ,
+                                    QColor &color1 , QColor &color2)
+
+{
+    //Calculate how many pixel our rectangle will cover in width, we base the computation on the current input value
+    // which should be a percentage
+    int pixToCover = width * value/100.0f ;
+    //Lets check the result iis not too small
+    if ( value < 1.0 || pixToCover < 0 )
+    {
+      pixToCover =4;
+    }
+    //or too big
+    if (pixToCover >= width)
+    {
+      pixToCover = width - 4;
+    }
+    //Lets build the backaground rectangle
+    QRect myQRect = QRect(QPoint(startPos,3) , QSize(pixToCover-1,height-6));
+    //Lets build the gradient
+    QLinearGradient gradient(myQRect.topLeft(), myQRect.topRight()); // diagonal gradient from top-left to bottom-right
+    //Lets set the color for the start positon
+    gradient.setColorAt(0, color1);
+    float r =(255*value/100.0f);
+    if (r<0)
+        r=0;
+    if (r>255)
+        r=255;
+    r /= 255;
+    //Lets interpolate the second color based on the percentage value
+    gradient.setColorAt(1, QColor(color1.red()* (1-r) + color2.red()*r,
+                                  color1.green()* (1-r) + color2.green()*r,
+                                  color1.blue()* (1-r) + color2.blue()*r,
+                                  255));
+    //Lets draw the gradient
+    qp.fillRect(myQRect, gradient);
+    //Lets draw the text in the center of the triangle if needed
+    if (drawText == true)
+        qp.drawText(startPos + (width/2),height/2,QString::number(int(value)) + " %");
+
+}
+
diff --git a/src/imports/multimedia/PERFORMANCE/painters/painterutils.h b/src/imports/multimedia/PERFORMANCE/painters/painterutils.h
new file mode 100644
index 0000000..3cb822e
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/painters/painterutils.h
@@ -0,0 +1,58 @@
+#ifndef PAINTERUTILS_H
+#define PAINTERUTILS_H
+#include <QPainter>
+
+/** @brief This class is used to facilitate the paints of different graphs
+  *
+  * This class defines some usefull procedures for some basic standard drawings,
+  * all the functios in this class are static meanings that can be called without the need
+  * to make an instance of the class itself
+  *
+  */
+
+
+class painterUtils
+{
+public:
+    ///The constructor
+    painterUtils();
+    /**
+     * @brief This procedure draws a uniform spaced line graph
+     * @param qp : the painter you want to use for the drawing
+     * @param startPos : the start position of the rectangle (left top corner)
+     * @param width : the width of the rectangle
+     * @param height : the height of the rectangle
+     * @param data : the data to be displayed, this is a vector of floats rapresentings the y
+     *               coordinates of our points ( which are uniformely distribuited on the x)
+     * @param lineColor : the color we want to use for the line
+     * @param bodyColor : the color we want to use for the body delimited by the graph (below)
+     *
+     * Example of possible graph :
+     * @image html performanceSingleGraph.png "Regular Graph"
+    */
+    static void drawRectangleGraph(QPainter &qp ,int const &startPos,
+                                   int const &width,int const &height,
+                                   std::vector<float>  &data,
+                                   QColor &lineColor , QColor &bodyColor);
+    /**
+     * @brief This procedure draws a single bar graph
+     * @param qp : the painter you want to use for the drawing
+     * @param startPos : the start position of the rectangle (left top corner)
+     * @param width : the width of the rectangle
+     * @param height : the height of the rectangle
+     * @param value : the value in percentage of the width for the lenght of the bar
+     * @param drawText : Whether or not to draw the text percentage
+     * @param color1 : The starting color of the bar (color gets interpolated with color2)
+     * @param color2 : The ending color of the bar (color gets interpolated with color1)
+     *
+     * Example of possible graph :
+     * @image html performanceSingleBar.png "Bar Graph"
+    */
+    static void drawRectangleBar(QPainter &qp ,int const &startPos,
+                          int const &width,int const &height ,const float value
+                          , bool drawText,QColor &color1 , QColor &color2);
+
+
+};
+
+#endif // PAINTERUTILS_H
diff --git a/src/imports/multimedia/PERFORMANCE/painters/performancepainter.cpp b/src/imports/multimedia/PERFORMANCE/painters/performancepainter.cpp
new file mode 100644
index 0000000..4f5b9d6
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/painters/performancepainter.cpp
@@ -0,0 +1,112 @@
+#include "performancepainter.h"
+#include <iostream>
+
+PerformancePainter::PerformancePainter(QPaintDevice * widget) :
+    m_width(100),
+    m_height(100), m_gridHeightStep(15), m_gridWidthStep(30),
+    m_drawGrid(true),
+    m_gridColor(QColor(180,180,180,180)),
+    m_backgroundColor(QColor(40,40,40,255)),
+    m_color1(QColor(0,230,0,255)),
+    m_color2(QColor(0,230,0,255)),
+    m_widget(widget)
+
+{
+
+
+}
+
+
+void PerformancePainter::drawBackground(QPainter &qp)
+{
+    //  //Declare a painter and a pen used for drawing
+    //  QPainter qp(this);
+      qp.setPen(QColor(255,255,255,255));
+      qp.setBrush(m_backgroundColor);
+
+      //Draw the background
+      qp.drawRoundedRect(0,0,m_width-1,m_height-1,
+                           3,3
+                           ,Qt::AbsoluteSize);
+
+
+}
+
+
+void PerformancePainter::drawGrid(QPainter &qp)
+{
+    //Draw grid
+    if (m_drawGrid == false)
+        return;
+    //Set pen color
+    qp.setPen(m_gridColor);
+
+    //Compute height and width steps
+    int stepm_height = m_height/m_gridHeightStep;
+    int stepm_width = m_width / m_gridWidthStep;
+
+    //Draw horizontal lines
+    for (int i = 0; i < stepm_width +1; i++)
+    {
+      qp.drawLine(m_gridWidthStep*i+2,1
+                  ,m_gridWidthStep*i+2, m_height-1);
+    }
+
+    //Draw vertical lines
+    for (int i = 0; i < stepm_height +1; i++)
+    {
+      qp.drawLine(4,m_gridHeightStep*i+2,m_width-4,
+                  m_gridHeightStep*i+2);
+    }
+
+}
+
+
+void PerformancePainter::setGridColor(QColor color)
+{
+
+    m_gridColor = color;
+
+}
+
+void PerformancePainter::setColor1(QColor color)
+{
+
+    m_color1 = color;
+
+}
+
+
+void PerformancePainter::setColor2(QColor color)
+{
+
+    m_color2 = color;
+
+}
+
+void PerformancePainter::setBackgroundColor(QColor color)
+{
+    m_backgroundColor = color;
+
+}
+void PerformancePainter::setGeometry(const int width, const int height)
+{
+    m_width = width;
+    m_height = height;
+
+}
+
+
+
+
+void PerformancePainter::setData(std::vector<std::vector<float> > cache)
+{
+    m_cache = cache;
+}
+
+
+void PerformancePainter::setDrawGrid(const bool value)
+{
+    m_drawGrid = value;
+
+}
diff --git a/src/imports/multimedia/PERFORMANCE/painters/performancepainter.h b/src/imports/multimedia/PERFORMANCE/painters/performancepainter.h
new file mode 100644
index 0000000..e5efe49
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/painters/performancepainter.h
@@ -0,0 +1,102 @@
+#ifndef PERFORMANCEPAINTER_H
+#define PERFORMANCEPAINTER_H
+
+#include <QPainter>
+/**
+ * @brief This is an abstract painter
+ *
+ * This class define an abstract painter that can be subclassed to generate different type of paintings
+ * for the performance widget
+ *
+ * In order to provide a little bit of flexibility this class implements a couple of generic attriutes and relative
+ * setter functions , this attributes can be used or not from the subclasses to try to give a bit of customizzation
+ * Those attributes are :
+ * \li m_color1
+ * \li m_color2
+
+ */
+class PerformancePainter
+{
+
+public:
+    /**
+     * @brief This is the constructor, for the painter in order to works needs to be initialized with a QPaintDevice
+     * object or any of its child
+     * @param widget : The widget we want to draw on
+     */
+    PerformancePainter( QPaintDevice * widget);
+    ///The virtual destructor
+    virtual ~PerformancePainter(){}
+    ///The virtual paint method that needs to be reimplemented in the subclasses
+    virtual void paint(){}
+    /**
+     * @brief This functon is used to set the width and height of the widget to be used internally.
+     * @param width : The current width of the widget
+     * @param height : The current height of the widget
+     */
+    void setGeometry(const int width, const int height);
+    /**
+     * @brief This function is used to set the data that needs to be displayed in by the painter
+     * @param cache : The array of values to draw
+     */
+    void setData(std::vector<std::vector<float> > cache);
+    /**
+     * @brief Set whether or not to drawa the grid
+     * @param value : The bool value to set the gird on off
+     */
+    void setDrawGrid(const bool value);
+    /** This method lets the user set the background color
+      * @param color : The QColor for the background
+    */
+    void setBackgroundColor(QColor color);
+    /**
+     * @brief Set whether or not to drawa the background color
+     * @param qp
+     */
+    void drawBackground(QPainter &qp);
+
+    void drawGrid(QPainter &qp );
+    /** This method lets the user set the grid color
+      * @param color : The QColor for the grid
+    */
+    void setGridColor(QColor color);
+
+    /**
+     * @brief This procedure lets you set the color1 you can use in the widget
+     * @param color : The color value
+     */
+    void setColor1(QColor color);
+    /**
+     * @brief This procedure lets you set the color2 you can use in the widget
+     * @param color : The color value
+     */
+    void setColor2(QColor color);
+protected :
+
+protected :
+    /// The width of the widget
+    int m_width;
+    /// The height of the widget
+    int m_height;
+    /// The vertical resolution of the grid
+    int m_gridHeightStep;
+    /// The horizontal resolution of the grid
+    int m_gridWidthStep;
+    /// The drawGrid attriute
+    int m_drawGrid;
+    /// The color value for the grid
+    QColor m_gridColor;
+    /// The color value for the background
+    QColor m_backgroundColor;
+    /// The generic color value 1
+    QColor m_color1;
+    /// The generic color value 2
+    QColor m_color2;
+    /// The associated widget to paint on
+    QPaintDevice * m_widget;
+    /// The internal data to be painted
+    std::vector<std::vector<float> >  m_cache;
+
+};
+
+#endif // PERFORMANCEPAINTER_H
diff --git a/src/imports/multimedia/PERFORMANCE/qdeclarativecpu.cpp b/src/imports/multimedia/PERFORMANCE/qdeclarativecpu.cpp
new file mode 100644
index 0000000..8e79ee5
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/qdeclarativecpu.cpp
@@ -0,0 +1,117 @@
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <stdio.h>
+//#include <QtQml/qqmlinfo.h>
+//#include <qmediaservice.h>
+//#include <private/qmediaserviceprovider_p.h>
+//#include <qmetadatareadercontrol.h>
+//#include <qmediaavailabilitycontrol.h>
+//#include "qdeclarativemediametadata_p.h"
+#include "qdeclarativecpu_p.h"
+
+QT_BEGIN_NAMESPACE
+
+// static void qRegisterAxistatMetaTypes()
+// {
+    // qRegisterMetaType<QDeclarativeAxistat::AxistatState>("QDeclarativeAxistat::AxistatState");
+// }
+// Q_CONSTRUCTOR_FUNCTION(qRegisterAxistatMetaTypes)
+
+QDeclarativeCPU::QDeclarativeCPU(QObject *parent) 
+  : QObject(parent)
+  , m_dataQuery(CpuDataQuery())
+  , m_multi(true)
+  , m_index(0)
+{
+//    qDebug() << Q_FUNC_INFO;
+    //Set what data quary we want
+//    setDataQuery(&m_dataQuery);
+
+    //set data query default config
+    m_dataQuery.setMulti(m_multi);
+    m_dataQuery.setIndex(m_index);
+
+    //Initialize painter
+//    setDisplayMode(DRAW_GRAPH_MULTI_COLOR);
+    //Setup the timer
+    m_timer = new QTimer (this);
+    connect(m_timer, SIGNAL(timeout()),this,  SLOT(updateData()));
+//    connect(m_timer, SIGNAL(timeout()),this,  SLOT(repaint()));
+    m_timer->start(SLOW_UPDATE);
+    
+    
+}
+
+void QDeclarativeCPU::setSpeed(const speedType speed)
+{
+    m_timer->stop();
+    m_timer->start(speed);
+}
+
+// void CpuWidget::setDisplayMode(const drawMode mode)
+// {
+        // m_displayMode = mode;
+
+        // switch (m_displayMode) {
+        // case 0:
+        // {
+            // setPainter(m_barsP);
+            // break;
+        // }
+        // case 1:
+        // {
+            // setPainter(m_graphP);
+            // break;
+        // }
+        // case 2:
+        // {
+            // setPainter(m_multiP);
+            // break;
+        // }
+
+        // }
+
+
+// }
+
+void QDeclarativeCPU::setMulti(bool value)
+{
+    m_multi = value;
+    m_dataQuery.setMulti(m_multi);
+
+}
+
+void QDeclarativeCPU::setIndex(int value)
+{
+    if (value <= m_dataQuery.getNumberOfCores())
+    {
+        m_index = value;
+        m_dataQuery.setIndex(value);
+    }
+    else
+        std::cout<<"ERROR : value exiding number of cores .... skipping"<<std::endl;
+
+
+}
+
+void QDeclarativeCPU::updateData()
+{
+    if (&m_dataQuery != NULL)
+        m_dataQuery.getData();
+    else
+        std::cout<<"ERROR : NO DATA QUERY DEVICE PROVIDED"<<std::endl;
+    emit cpuUsageChanged();
+//    qDebug() << Q_FUNC_INFO;
+}
+
+QDeclarativeCPU::~QDeclarativeCPU()
+{
+    // delete m_graphP;
+    // delete m_barsP;
+    // delete m_multiP;
+    delete m_timer;
+    qDebug() << Q_FUNC_INFO;
+
+}
+QT_END_NAMESPACE
+#include "moc_qdeclarativecpu_p.cpp"
\ No newline at end of file
diff --git a/src/imports/multimedia/PERFORMANCE/qdeclarativecpu_p.h b/src/imports/multimedia/PERFORMANCE/qdeclarativecpu_p.h
new file mode 100644
index 0000000..ae72915
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/qdeclarativecpu_p.h
@@ -0,0 +1,121 @@
+#ifndef QDECLARATIVECPU_P_H
+#define QDECLARATIVECPU_P_H
+
+#include <unistd.h>
+#include "dataQuery/cpudataquery.h"
+#include "dataQuery/queryresource.h"
+//#include <QtCore/qbasictimer.h>
+//#include <QtQml/qqmlparserstatus.h>
+#include <QtQml/qqml.h>
+#include <QtCore>
+//#include <QtMultimedia/qmediaobject.h>
+#include <QTimer>
+
+ QT_BEGIN_NAMESPACE
+ 
+//class QDeclarativeCPU : public QMediaObject, public QQmlParserStatus, public PerformanceWidget
+class QDeclarativeCPU :  public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(int allCpuUsage READ readAllCpu NOTIFY cpuUsageChanged)
+    Q_PROPERTY(int Cpu1Usage READ readCpu1 NOTIFY cpuUsageChanged)
+    Q_PROPERTY(int Cpu2Usage READ readCpu2 NOTIFY cpuUsageChanged)
+    Q_PROPERTY(int Cpu3Usage READ readCpu3 NOTIFY cpuUsageChanged)
+    Q_PROPERTY(int Cpu4Usage READ readCpu4 NOTIFY cpuUsageChanged)
+    Q_PROPERTY(int numberOfCore READ readCore)
+
+//    Q_INTERFACES(QQmlParserStatus)
+
+public :
+    /// Constants defining the update's speed
+    enum speedType
+    {
+      /// Fast update 250 ms
+      FAST_UPDATE = 250,
+      /// Medium update 500 ms
+      MEDIUM_UPDATE = 500,
+      /// Slow update 1000 ms
+      SLOW_UPDATE = 1000
+    } ;
+
+public :
+
+    int readAllCpu () {
+      return int(m_dataQuery.m_cache[0][29]) ;
+    }
+    int readCpu1 () {
+      return int(m_dataQuery.m_cache[1][29]) ;
+    }
+    int readCpu2 () {
+      return int(m_dataQuery.m_cache[2][29]) ;
+    }
+    int readCpu3 () {
+      return int(m_dataQuery.m_cache[3][29]) ;
+    }
+    int readCpu4 () {
+      return int(m_dataQuery.m_cache[4][29]) ;
+    }
+    int readCore () {
+      qDebug() << Q_FUNC_INFO;
+      return sysconf(_SC_NPROCESSORS_ONLN);
+    }
+    
+    /// Constants defining the draw mode
+/*    enum drawMode
+    {
+        /// Draw the data as bar/s
+        DRAW_BARS = 0,
+        /// Draw the data as graph/s
+        DRAW_GRAPH = 1,
+        /// Draw the data as single multicolor graph
+        DRAW_GRAPH_MULTI_COLOR = 2
+
+    };*/
+
+    QDeclarativeCPU(QObject *parent=0);
+    ~QDeclarativeCPU();
+    
+//    void classBegin(){};
+//    void componentComplete(){};
+    /** This method lets the user set the display mode for the widget
+    *   @param mode : what mode to draw the widget, available options : \li DRAW_BARS
+    *                 \li DRAW_GRAPH
+    */
+//    void setDisplayMode(const drawMode mode);
+    /**
+     * @brief Set whether to show all the cpus or just a specific one
+     * (defined by the index)
+     * @param value : set multi value on off
+     */
+    void setMulti(bool value);
+    /**
+     * @brief If in draw single mode , which cpu data to show, the attribute range between
+     * 0 - number of cpus, if we have 8 cpus , we can use 9 indexs, index zero will means the average
+     * of all cpus, then from 1 on it will define the index of the singles cpus.
+     * @param value : The index of the cpu to show
+     */
+    void setIndex(int value);
+    void setSpeed( const speedType speed);
+
+Q_SIGNALS:
+   void cpuUsageChanged();
+
+private slots:
+    ///This function is used to fetch the data from the data class
+    void updateData();
+    
+private :
+    Q_DISABLE_COPY(QDeclarativeCPU)
+    CpuDataQuery m_dataQuery;
+    bool m_multi;
+    int m_index;
+    ///The internal timer for the repaint
+    QTimer * m_timer;
+    int i;
+};
+
+QT_END_NAMESPACE
+
+//Q_DECLARE_METATYPE(QDeclarativeAxistat::AxistatState)
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativeCPU))
+#endif // QDECLARATIVECPU_P_H
diff --git a/src/imports/multimedia/PERFORMANCE/qdeclarativemem.cpp b/src/imports/multimedia/PERFORMANCE/qdeclarativemem.cpp
new file mode 100644
index 0000000..dd7f8cd
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/qdeclarativemem.cpp
@@ -0,0 +1,105 @@
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <stdio.h>
+#include "qdeclarativemem_p.h"
+
+QT_BEGIN_NAMESPACE
+
+// static void qRegisterAxistatMetaTypes()
+// {
+    // qRegisterMetaType<QDeclarativeAxistat::AxistatState>("QDeclarativeAxistat::AxistatState");
+// }
+// Q_CONSTRUCTOR_FUNCTION(qRegisterAxistatMetaTypes)
+
+QDeclarativeMem::QDeclarativeMem(QObject *parent) 
+  : QObject(parent)
+  , m_dataQuery(RamDataQuery())
+{
+//    qDebug() << Q_FUNC_INFO;
+    //Set what data quary we want
+//    setDataQuery(&m_dataQuery);
+
+
+    //Initialize painter
+//    setDisplayMode(DRAW_GRAPH_MULTI_COLOR);
+    //Setup the timer
+    m_timer = new QTimer (this);
+    connect(m_timer, SIGNAL(timeout()),this,  SLOT(updateData()));
+//    connect(m_timer, SIGNAL(timeout()),this,  SLOT(repaint()));
+    m_timer->start(SLOW_UPDATE);
+    
+}
+
+// void QDeclarativeMem::setSpeed(const speedType speed)
+// {
+    // m_timer->stop();
+    // m_timer->start(speed);
+// }
+
+// void CpuWidget::setDisplayMode(const drawMode mode)
+// {
+        // m_displayMode = mode;
+
+        // switch (m_displayMode) {
+        // case 0:
+        // {
+            // setPainter(m_barsP);
+            // break;
+        // }
+        // case 1:
+        // {
+            // setPainter(m_graphP);
+            // break;
+        // }
+        // case 2:
+        // {
+            // setPainter(m_multiP);
+            // break;
+        // }
+
+        // }
+
+
+// }
+
+// void QDeclarativeMem::setMulti(bool value)
+// {
+    // m_multi = value;
+    // m_dataQuery.setMulti(m_multi);
+
+// }
+
+// void QDeclarativeMem::setIndex(int value)
+// {
+    // if (value <= m_dataQuery.getNumberOfCores())
+    // {
+        // m_index = value;
+        // m_dataQuery.setIndex(value);
+    // }
+    // else
+        // std::cout<<"ERROR : value exiding number of cores .... skipping"<<std::endl;
+
+
+// }
+
+void QDeclarativeMem::updateData()
+{
+    if (&m_dataQuery != NULL)
+        m_dataQuery.getData();
+    else
+        std::cout<<"ERROR : NO DATA QUERY DEVICE PROVIDED"<<std::endl;
+    emit memUsageChanged();
+//    qDebug() << Q_FUNC_INFO;
+}
+
+QDeclarativeMem::~QDeclarativeMem()
+{
+    // delete m_graphP;
+    // delete m_barsP;
+    // delete m_multiP;
+    delete m_timer;
+//    qDebug() << Q_FUNC_INFO;
+
+}
+QT_END_NAMESPACE
+#include "moc_qdeclarativemem_p.cpp"
\ No newline at end of file
diff --git a/src/imports/multimedia/PERFORMANCE/qdeclarativemem_p.h b/src/imports/multimedia/PERFORMANCE/qdeclarativemem_p.h
new file mode 100644
index 0000000..bf91e82
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/qdeclarativemem_p.h
@@ -0,0 +1,78 @@
+#ifndef QDECLARATIVEMEM_P_H
+#define QDECLARATIVEMEM_P_H
+
+#include <unistd.h>
+#include "dataQuery/ramdataquery.h"
+#include "dataQuery/queryresource.h"
+#include <QtQml/qqml.h>
+#include <QtCore>
+#include <QTimer>
+
+QT_BEGIN_NAMESPACE
+ 
+class QDeclarativeMem :  public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(int memUsage READ readMemUsage NOTIFY memUsageChanged)
+
+//    Q_INTERFACES(QQmlParserStatus)
+
+public:
+    /// Constants defining the update's speed
+    enum speedType
+    {
+      /// Fast update 250 ms
+      FAST_UPDATE = 250,
+      /// Medium update 500 ms
+      MEDIUM_UPDATE = 500,
+      /// Slow update 1000 ms
+      SLOW_UPDATE = 1000
+    } ;
+
+public :
+
+    int readMemUsage () {
+      return int(m_dataQuery.m_cache[0][29]) ;
+    }
+
+    
+    /// Constants defining the draw mode
+/*    enum drawMode
+    {
+        /// Draw the data as bar/s
+        DRAW_BARS = 0,
+        /// Draw the data as graph/s
+        DRAW_GRAPH = 1,
+        /// Draw the data as single multicolor graph
+        DRAW_GRAPH_MULTI_COLOR = 2
+
+    };*/
+
+    QDeclarativeMem(QObject *parent=0);
+    ~QDeclarativeMem();
+    
+//    void classBegin(){};
+//    void componentComplete(){};
+
+//    void setSpeed( const speedType speed);
+
+Q_SIGNALS:
+   void memUsageChanged();
+
+private slots:
+    ///This function is used to fetch the data from the data class
+    void updateData();
+    
+private :
+    Q_DISABLE_COPY(QDeclarativeMem)
+    RamDataQuery m_dataQuery;
+    ///The internal timer for the repaint
+    QTimer * m_timer;
+
+};
+
+QT_END_NAMESPACE
+
+//Q_DECLARE_METATYPE(QDeclarativeAxistat::AxistatState)
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativeMem))
+#endif // QDECLARATIVEMEM_P_H
diff --git a/src/imports/multimedia/PERFORMANCE/widgets/performancewidget.cpp b/src/imports/multimedia/PERFORMANCE/widgets/performancewidget.cpp
new file mode 100644
index 0000000..430a063
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/widgets/performancewidget.cpp
@@ -0,0 +1,87 @@
+//#include <QPainter>
+//#include <QLinearGradient>
+//#include "../painters/painterutils.h"
+#include "performancewidget.h"
+#include <QtCore>
+
+PerformanceWidget::PerformanceWidget(QWidget *parent) :
+    QWidget(parent),
+    m_timer(NULL),
+//    m_painter(NULL),
+    m_dataQuery(NULL)
+
+{
+qDebug() << Q_FUNC_INFO;
+    //Setup the timer
+    m_timer = new QTimer (this);
+    connect(m_timer, SIGNAL(timeout()),this,  SLOT(updateData()));
+//    connect(m_timer, SIGNAL(timeout()),this,  SLOT(repaint()));
+    m_timer->start(SLOW_UPDATE);
+}
+
+
+// void PerformanceWidget::paintEvent(QPaintEvent *e)
+// {
+
+
+//  Just silancing the waring about the event not being used
+  // (void)e;
+    // if (m_dataQuery == NULL)
+        // return;
+    // m_painter->setData(m_dataQuery->m_cache);
+    // m_painter->paint();
+
+
+// }
+
+
+void PerformanceWidget::setSpeed(const speedType speed)
+{
+    m_timer->stop();
+    m_timer->start(speed);
+}
+
+
+PerformanceWidget::~PerformanceWidget()
+{
+    delete m_timer;
+
+}
+
+
+void PerformanceWidget::setDataQuery(DataQuery *dataQ)
+{
+    m_dataQuery = dataQ;
+
+}
+
+// void PerformanceWidget::resizeEvent(QResizeEvent *e)
+// {
+
+    // (void)e;
+    // if (m_painter != NULL)
+    // {
+        // m_painter->setGeometry(width(),height());
+
+    // }
+
+// }
+
+
+void PerformanceWidget::updateData()
+{
+    if (m_dataQuery != NULL)
+        m_dataQuery->getData();
+    else
+        std::cout<<"ERROR : NO DATA QUERY DEVICE PROVIDED"<<std::endl;
+}
+
+
+// void PerformanceWidget::setPainter(PerformancePainter *painter)
+// {
+    // m_painter = painter;
+    // m_painter->setGeometry(width(),height());
+    // updateData();
+// }
+
+
diff --git a/src/imports/multimedia/PERFORMANCE/widgets/performancewidget.h b/src/imports/multimedia/PERFORMANCE/widgets/performancewidget.h
new file mode 100644
index 0000000..d8ef67b
--- /dev/null
+++ b/src/imports/multimedia/PERFORMANCE/widgets/performancewidget.h
@@ -0,0 +1,86 @@
+#ifndef PERFORMANCEWIDGET_H
+#define PERFORMANCEWIDGET_H
+
+
+#include <QWidget>
+#include "../dataQuery/queryresource.h"
+#include <QTimer>
+//#include "../painters/graphpainter.h"
+//#include "../painters/barspainter.h"
+//#include "../painters/graphmulticolorpainter.h"
+#include "../dataQuery/cpudataquery.h"
+
+/**
+
+ * @brief This class is a widget that lets you draw a changing value in time
+ *
+ * This class provides a basic widget used to draw a changing value in time,
+ * The class in order to work needa two things :
+ * \li data fetcher : A class inerithed from DataQuery , able to fetch the needed data
+ * \li data painter : A class inerithed from PerformancePainter, able to paint the given data
+ *
+ * In this way doesn't matter how we fatch the data or how we want to display the data, we just swap
+ * one of the needed classes and the widget will display accordingly
+ *
+*/
+
+class PerformanceWidget : public QWidget
+{
+    Q_OBJECT
+public :
+    /// Constants defining the update's speed
+    enum speedType
+    {
+      /// Fast update 250 ms
+      FAST_UPDATE = 250,
+      /// Medium update 500 ms
+      MEDIUM_UPDATE = 500,
+      /// Slow update 1000 ms
+      SLOW_UPDATE = 1000
+    } ;
+
+public:
+    /// Constructor
+    explicit PerformanceWidget(QWidget *parent = 0);
+    /// Destructor
+    ~PerformanceWidget();
+    /// Paint envent
+//    void paintEvent(QPaintEvent *e);
+    /** This method lets the user set the wanted update speed for the
+    * widget
+    * @param speed : the wanted speed , 3 constants available \li SLOW_UPDATE
+    *                \li MEDIUM_UPDATE \li FAST_UPDATE
+    */
+    void setSpeed( const speedType speed);
+    /**
+     * @brief Reimplemented size event, automatically connect the setGeometry() of the painter
+     * providing correct data
+     * @param e : the event
+     */
+//    void resizeEvent(QResizeEvent *e);
+
+    void setDataQuery(DataQuery *dataQ);
+//    void setPainter(PerformancePainter *painter);
+
+//Q_SIGNALS: 
+//    void intervalChanged();
+
+private slots:
+    ///This function is used to fetch the data from the data class
+    void updateData();
+
+private :
+    ///The internal timer for the repaint
+    QTimer * m_timer;
+//    PerformancePainter * m_painter;
+    DataQuery * m_dataQuery;
+
+
+
+
+};
+
+
+
+
+#endif // PERFORMANCEWIDGET_H
diff --git a/src/imports/multimedia/multimedia.cpp b/src/imports/multimedia/multimedia.cpp
index 4b31068..7734359 100644
--- a/src/imports/multimedia/multimedia.cpp
+++ b/src/imports/multimedia/multimedia.cpp
@@ -53,6 +53,15 @@
 #include "qdeclarativecameraimageprocessing_p.h"
 #include "qdeclarativecameraviewfinder_p.h"
 #include "qdeclarativetorch_p.h"
+#include "qdeclarativeH264Streaming_p.h"
+#include "qdeclarativeaudiostreaming_p.h"
+#include "qdeclarativeMP4Playback_p.h"
+#include "qdeclarativeMP4Recorder_p.h"
+#include "qdeclarativeaxistat_p.h"
+#include "PERFORMANCE/qdeclarativecpu_p.h"
+#include "PERFORMANCE/qdeclarativemem_p.h"
+#include "BAR/qdeclarativebar_p.h"
+#include "GRAPH/qdeclarativegraph_p.h"
 
 QML_DECLARE_TYPE(QSoundEffect)
 
@@ -75,14 +84,23 @@ public:
         Q_ASSERT(QLatin1String(uri) == QLatin1String("QtMultimedia"));
 
         // 5.0 types
+        qmlRegisterType<QDeclarativeAxistat>(uri, 5, 0, "Axistat");
+        qmlRegisterType<QDeclarativeGraph>(uri, 5, 0, "GRAPH");
+        qmlRegisterType<QDeclarativeMem>(uri, 5, 0, "MEM");
+        qmlRegisterType<QDeclarativeBar>(uri, 5, 0, "BAR");
+        qmlRegisterType<QDeclarativeCPU>(uri, 5, 0, "CPU");
         qmlRegisterType<QSoundEffect>(uri, 5, 0, "SoundEffect");
         qmlRegisterType<QDeclarativeAudio>(uri, 5, 0, "Audio");
+        qmlRegisterType<QDeclarativeAudioStreaming>(uri, 5, 0, "AudioStreaming");
         qmlRegisterType<QDeclarativeAudio>(uri, 5, 0, "MediaPlayer");
         qmlRegisterType<QDeclarativeVideoOutput>(uri, 5, 0, "VideoOutput");
         qmlRegisterType<QDeclarativeRadio>(uri, 5, 0, "Radio");
         qmlRegisterType<QDeclarativeRadioData>(uri, 5, 0, "RadioData");
         qmlRegisterType<QDeclarativeCamera>(uri, 5, 0, "Camera");
         qmlRegisterType<QDeclarativeTorch>(uri, 5, 0, "Torch");
+        qmlRegisterType<QDeclarativeH264Streaming>(uri, 5, 0, "H264Streaming");
+        qmlRegisterType<QDeclarativeMP4Playback>(uri, 5, 0, "MP4Playback");
+        qmlRegisterType<QDeclarativeMP4Recorder>(uri, 5, 0, "MP4Recorder");
         qmlRegisterUncreatableType<QDeclarativeCameraCapture>(uri, 5, 0, "CameraCapture",
                                 trUtf8("CameraCapture is provided by Camera"));
         qmlRegisterUncreatableType<QDeclarativeCameraRecorder>(uri, 5, 0, "CameraRecorder",
diff --git a/src/imports/multimedia/multimedia.pro b/src/imports/multimedia/multimedia.pro
index 71358ca..67965cc 100644
--- a/src/imports/multimedia/multimedia.pro
+++ b/src/imports/multimedia/multimedia.pro
@@ -1,6 +1,7 @@
 QT += qml quick network multimedia-private qtmultimediaquicktools-private
 
 HEADERS += \
+        qdeclarativeaudiostreaming_p.h \
         qdeclarativeaudio_p.h \
         qdeclarativemediametadata_p.h \
         qdeclarativeradio_p.h \
@@ -15,10 +16,23 @@ HEADERS += \
         qdeclarativecamerapreviewprovider_p.h \
         qdeclarativetorch_p.h \
         qdeclarativecameraviewfinder_p.h \
-        qdeclarativemultimediaglobal_p.h
+        qdeclarativemultimediaglobal_p.h \
+        qdeclarativeH264Streaming_p.h \
+        qdeclarativeMP4Playback_p.h \
+        qdeclarativeMP4Recorder_p.h \
+        qdeclarativeaxistat_p.h \
+        PERFORMANCE/dataQuery/cpudataquery.h \
+        PERFORMANCE/dataQuery/dataquery.h \
+        PERFORMANCE/dataQuery/queryresource.h \
+        PERFORMANCE/qdeclarativecpu_p.h \
+        PERFORMANCE/qdeclarativemem_p.h \
+        PERFORMANCE/dataQuery/ramdataquery.h \
+        BAR/qdeclarativebar_p.h \
+        GRAPH/qdeclarativegraph_p.h
 
 SOURCES += \
         multimedia.cpp \
+        qdeclarativeaudiostreaming.cpp \
         qdeclarativeaudio.cpp \
         qdeclarativeradio.cpp \
         qdeclarativeradiodata.cpp \
@@ -32,8 +46,21 @@ SOURCES += \
         qdeclarativecamerapreviewprovider.cpp \
         qdeclarativetorch.cpp \
         qdeclarativecameraviewfinder.cpp \
-        qdeclarativemultimediaglobal.cpp
+        qdeclarativemultimediaglobal.cpp \
+        qdeclarativeH264Streaming.cpp \
+        qdeclarativeMP4Playback.cpp \
+        qdeclarativeMP4Recorder.cpp \
+        qdeclarativeaxistat.cpp \
+        PERFORMANCE/dataQuery/cpudataquery.cpp \
+        PERFORMANCE/dataQuery/dataquery.cpp \
+        PERFORMANCE/dataQuery/queryresource.cpp \
+        PERFORMANCE/qdeclarativecpu.cpp \
+        PERFORMANCE/qdeclarativemem.cpp \
+        PERFORMANCE/dataQuery/ramdataquery.cpp \
+        BAR/qdeclarativebar.cpp \
+        GRAPH/qdeclarativegraph.cpp
 
+LIBS += -laxistat
 QML_FILES += \
     Video.qml
 
diff --git a/src/imports/multimedia/qdeclarativeH264Streaming.cpp b/src/imports/multimedia/qdeclarativeH264Streaming.cpp
new file mode 100755
index 0000000..5de36d7
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeH264Streaming.cpp
@@ -0,0 +1,697 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QtQml/qqmlinfo.h>
+
+#include "qdeclarativeH264Streaming_p.h"
+
+#include <qH264Streamingcontrol.h>
+#include <qmediaavailabilitycontrol.h>
+
+#include <qmediaservice.h>
+#include <private/qmediaserviceprovider_p.h>
+#include <qmetadatareadercontrol.h>
+#include <qmediaavailabilitycontrol.h>
+
+#include "qdeclarativemediametadata_p.h"
+
+#include <QTimerEvent>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \qmltype Audio
+    \instantiates QDeclarativeMediaPlayerPOC
+    \brief Add audio playback to a scene.
+
+    \inqmlmodule QtMultimedia
+    \ingroup multimedia_qml
+    \ingroup multimedia_audio_qml
+
+    This type is part of the \b{QtMultimedia 5.0} module.
+
+    \qml
+    import QtQuick 2.0
+    import QtMultimedia 5.0
+
+    Text {
+        text: "Click Me!";
+        font.pointSize: 24;
+        width: 150; height: 50;
+
+        Audio {
+            id: playMusic
+            source: "music.wav"
+        }
+        MouseArea {
+            id: playArea
+            anchors.fill: parent
+            onPressed:  { playMusic.play() }
+        }
+    }
+    \endqml
+
+    \sa Video
+*/
+
+void QDeclarativeH264Streaming::_q_error(QH264Streaming::Error errorCode)
+{
+    m_error = errorCode;
+    m_errorString = m_player->errorString();
+
+    emit error(Error(errorCode), m_errorString);
+    emit errorChanged();
+}
+
+QDeclarativeH264Streaming::QDeclarativeH264Streaming(QObject *parent)
+    : QObject(parent)
+    , m_autoPlay(false)
+    , m_autoLoad(true)
+    , m_loaded(false)
+    , m_complete(false)
+    , m_loopCount(1)
+    , m_runningCount(0)
+    , m_position(0)
+    , m_playbackState(QH264Streaming::StoppedState)
+    , m_status(QH264Streaming::NoMedia)
+    , m_error(QH264Streaming::ServiceMissingError)
+    , m_player(0)
+    , m_hdmi_width(-1)
+    , m_hdmi_height(-1)
+    , m_hdmi_format("NV12")
+    , m_enc_bitrate(-1)
+    , m_num_p_frames(-1)
+    , m_no_reorder(false)
+    , m_udp_port("1234")
+    , m_udp_host("192.168.0.30")
+    , m_transmit(false)
+    , m_vspm(false)
+    , m_vspm_dmabuf_use(false)
+    , m_vspm_width(-1)
+    , m_vspm_width1(-1)
+    , m_vspm_height(-1)
+    , m_vspm_height1(-1)
+    , m_vspm_format(true)
+    , m_wls_max_lateness(0)
+    , m_wls_qos(true)
+    , m_wls_position_x(-1)
+    , m_wls_position_y(-1)
+    , m_wls_out_width(-1)
+    , m_wls_out_height(-1)
+{
+
+}
+
+QDeclarativeH264Streaming::~QDeclarativeH264Streaming()
+{
+    delete m_player;
+}
+
+int QDeclarativeH264Streaming::hdmiWidth() const
+{
+    return m_hdmi_width;
+}
+
+void QDeclarativeH264Streaming::setHdmiWidth(int hdmiwidth)
+{
+    m_hdmi_width = hdmiwidth;
+    m_player->setHdmiWidth(hdmiwidth);
+}
+
+int QDeclarativeH264Streaming::hdmiHeight() const
+{
+    return m_hdmi_height;
+}
+
+void QDeclarativeH264Streaming::setHdmiHeight(int hdmiheight)
+{
+    m_hdmi_height = hdmiheight;
+    m_player->setHdmiHeight(hdmiheight);
+}
+
+QString QDeclarativeH264Streaming::hdmiFormat() const
+{
+    return m_hdmi_format;
+}
+
+void QDeclarativeH264Streaming::setHdmiFormat(QString hdmiformat)
+{
+    m_hdmi_format = hdmiformat;
+    m_player->setHdmiFormat(hdmiformat);
+}
+
+int QDeclarativeH264Streaming::encBitrate() const
+{
+    return m_enc_bitrate;
+}
+
+void QDeclarativeH264Streaming::setEncBitrate(int encbitrate)
+{
+    m_enc_bitrate = encbitrate;
+    m_player->setEncBitrate(encbitrate);
+}
+
+int QDeclarativeH264Streaming::numPframes() const
+{
+    return m_num_p_frames;
+}
+
+void QDeclarativeH264Streaming::setNumPframes(int numpframes)
+{
+    m_num_p_frames = numpframes;
+    m_player->setNumPframes(numpframes);
+}
+
+bool QDeclarativeH264Streaming::noReorder() const 
+{
+    return m_no_reorder;
+}
+
+void QDeclarativeH264Streaming::setNoReorder(bool noreorder)
+{
+    m_no_reorder = noreorder;
+    m_player->setNoReorder(noreorder);
+}
+
+QString QDeclarativeH264Streaming::udpPort() const
+{
+    return m_udp_port;
+}
+
+void QDeclarativeH264Streaming::setUdpPort(QString udpport)
+{
+    m_udp_port = udpport;
+    m_player->setUdpPort(udpport);
+}
+
+QString QDeclarativeH264Streaming::udpHost() const
+{
+    return m_udp_host;
+}
+
+void QDeclarativeH264Streaming::setUdpHost(QString udphost)
+{
+    m_udp_host = udphost;
+    m_player->setUdpHost(udphost);
+}
+
+bool QDeclarativeH264Streaming::transmit() const
+{
+    return m_transmit;
+}
+
+void QDeclarativeH264Streaming::setTransmit(bool transmit)
+{
+    m_transmit = transmit;
+    m_player->setTransmit(transmit);
+}
+
+bool QDeclarativeH264Streaming::vspm() const
+{
+    return m_vspm;
+}
+
+void QDeclarativeH264Streaming::setVspm(bool vspm)
+{
+    m_vspm = vspm;
+    m_player->setVspm(vspm);
+}
+
+bool QDeclarativeH264Streaming::vspmDmabuf() const
+{
+    return m_vspm_dmabuf_use;
+}
+
+void QDeclarativeH264Streaming::setVspmDmabuf(bool vspmdmabuf)
+{
+    m_vspm_dmabuf_use = vspmdmabuf;
+    m_player->setVspmDmabuf(vspmdmabuf);
+}
+
+int QDeclarativeH264Streaming::vspmWidth() const
+{
+    return m_vspm_width;
+}
+
+int QDeclarativeH264Streaming::vspmWidth1() const
+{
+    return m_vspm_width1;
+}
+
+void QDeclarativeH264Streaming::setVspmWidth(int vspmwidth)
+{
+    m_vspm_width = vspmwidth;
+    m_player->setVspmWidth(vspmwidth);
+}
+
+void QDeclarativeH264Streaming::setVspmWidth1(int vspmwidth1)
+{
+    m_vspm_width1 = vspmwidth1;
+    m_player->setVspmWidth1(vspmwidth1);
+}
+
+int QDeclarativeH264Streaming::vspmHeight() const
+{
+    return m_vspm_height;
+}
+
+int QDeclarativeH264Streaming::vspmHeight1() const
+{
+    return m_vspm_height1;
+}
+
+
+void QDeclarativeH264Streaming::setVspmHeight(int vspmheight)
+{
+    m_vspm_height = vspmheight;
+    m_player->setVspmHeight(vspmheight);
+}
+
+void QDeclarativeH264Streaming::setVspmHeight1(int vspmheight1)
+{
+    m_vspm_height1 = vspmheight1;
+    m_player->setVspmHeight1(vspmheight1);
+}
+
+QString QDeclarativeH264Streaming::vspmFormat() const
+{
+    return m_vspm_format;
+}
+
+void QDeclarativeH264Streaming::setVspmFormat(QString vspmformat)
+{
+    m_vspm_format = vspmformat;
+    m_player->setVspmFormat(vspmformat);
+}
+
+int QDeclarativeH264Streaming::wlsMaxLateness() const
+{
+    return m_wls_max_lateness;
+}
+
+void QDeclarativeH264Streaming::setWlsMaxLateness(int wlsmaxlateness)
+{
+    m_wls_max_lateness = wlsmaxlateness;
+    m_player->setWlsMaxLateness(wlsmaxlateness);
+}
+
+bool QDeclarativeH264Streaming::wlsQos() const
+{
+    return m_wls_qos;
+}
+
+void QDeclarativeH264Streaming::setWlsQos(bool wlsqos)
+{
+    m_wls_qos = wlsqos;
+    m_player->setWlsQos(wlsqos);
+}
+
+int QDeclarativeH264Streaming::wlsPositionX() const
+{
+    return m_wls_position_x;
+}
+
+void QDeclarativeH264Streaming::setWlsPositionX(int wlspositionx)
+{
+    m_wls_position_x = wlspositionx;
+    m_player->setWlsPositionX(wlspositionx);
+}
+int QDeclarativeH264Streaming::wlsPositionY() const
+{
+    return m_wls_position_y;
+}
+
+void QDeclarativeH264Streaming::setWlsPositionY(int wlspositiony)
+{
+    m_wls_position_y = wlspositiony;
+    m_player->setWlsPositionY(wlspositiony);
+}
+
+int QDeclarativeH264Streaming::wlsOutWidth() const
+{
+    return m_wls_out_width;
+}
+
+void QDeclarativeH264Streaming::setWlsOutWidth(int wlsoutwidth)
+{
+    m_wls_out_width = wlsoutwidth;
+    m_player->setWlsOutWidth(wlsoutwidth);
+}
+
+int QDeclarativeH264Streaming::wlsOutHeight() const
+{
+    return m_wls_out_height;
+}
+
+void QDeclarativeH264Streaming::setWlsOutHeight(int wlsoutheight)
+{
+    m_wls_out_height = wlsoutheight;
+    m_player->setWlsOutHeight(wlsoutheight);
+}
+
+QUrl QDeclarativeH264Streaming::source() const
+{
+    return m_source;
+}
+
+bool QDeclarativeH264Streaming::autoPlay() const
+{
+    return m_autoPlay;
+}
+
+void QDeclarativeH264Streaming::setAutoPlay(bool autoplay)
+{
+    if (m_autoPlay == autoplay)
+        return;
+
+    m_autoPlay = autoplay;
+    emit autoPlayChanged();
+}
+
+void QDeclarativeH264Streaming::setSource(const QUrl &url)
+{
+    if (url == m_source)
+        return;
+
+    m_source = url;
+    m_content = m_source.isEmpty() ? QMediaContent() : m_source;
+    m_loaded = false;
+    if (m_complete && (m_autoLoad || m_content.isNull() || m_autoPlay)) {
+        if (m_error != QH264Streaming::ServiceMissingError && m_error != QH264Streaming::NoError) {
+            m_error = QH264Streaming::NoError;
+            m_errorString = QString();
+
+            emit errorChanged();
+        }
+
+        m_player->setMedia(m_content, 0);
+        m_loaded = true;
+    }
+    else
+        emit sourceChanged();
+
+    if (m_autoPlay)
+        m_player->play();
+}
+
+bool QDeclarativeH264Streaming::isAutoLoad() const
+{
+    return m_autoLoad;
+}
+
+void QDeclarativeH264Streaming::setAutoLoad(bool autoLoad)
+{
+    if (m_autoLoad == autoLoad)
+        return;
+
+    m_autoLoad = autoLoad;
+    emit autoLoadChanged();
+}
+
+int QDeclarativeH264Streaming::loopCount() const
+{
+    return m_loopCount;
+}
+
+void QDeclarativeH264Streaming::setLoopCount(int loopCount)
+{
+    if (loopCount == 0)
+        loopCount = 1;
+    else if (loopCount < -1)
+        loopCount = -1;
+
+    if (m_loopCount == loopCount) {
+        return;
+    }
+    m_loopCount = loopCount;
+    m_runningCount = loopCount - 1;
+    emit loopCountChanged();
+}
+
+void QDeclarativeH264Streaming::setPlaybackState(QH264Streaming::State playbackState)
+{
+    if (m_playbackState == playbackState)
+        return;
+
+    if (m_complete) {
+        switch (playbackState){
+        case (QH264Streaming::PlayingState):
+            if (!m_loaded) {
+                m_player->setMedia(m_content, 0);
+                m_player->setPosition(m_position);
+                m_loaded = true;
+            }
+            m_player->play();
+            break;
+
+        case (QH264Streaming::PausedState):
+            if (!m_loaded) {
+                m_player->setMedia(m_content, 0);
+                m_player->setPosition(m_position);
+                m_loaded = true;
+            }
+            m_player->pause();
+            break;
+
+        case (QH264Streaming::StoppedState):
+            m_player->stop();
+            
+        }
+    }
+}
+
+int QDeclarativeH264Streaming::duration() const
+{
+    return !m_complete ? 0 : m_player->duration();
+}
+
+int QDeclarativeH264Streaming::position() const
+{
+    return !m_complete ? m_position : m_player->position();
+}
+
+QString QDeclarativeH264Streaming::errorString() const
+{
+    return m_errorString;
+}
+
+/*!
+    \qmlmethod QtMultimedia::Audio::play()
+
+    Starts playback of the media.
+
+    Sets the \l playbackState property to PlayingState.
+*/
+
+void QDeclarativeH264Streaming::play()
+{
+    if (!m_complete)
+        return;
+
+    setPlaybackState(QH264Streaming::PlayingState);
+}
+
+/*!
+    \qmlmethod QtMultimedia::Audio::pause()
+
+    Pauses playback of the media.
+
+    Sets the \l playbackState property to PausedState.
+*/
+
+void QDeclarativeH264Streaming::pause()
+{
+    if (!m_complete)
+        return;
+
+    setPlaybackState(QH264Streaming::PausedState);
+}
+
+/*!
+    \qmlmethod QtMultimedia::Audio::stop()
+
+    Stops playback of the media.
+
+    Sets the \l playbackState property to StoppedState.
+*/
+
+void QDeclarativeH264Streaming::stop()
+{
+    if (!m_complete)
+        return;
+
+    setPlaybackState(QH264Streaming::StoppedState);
+}
+
+QDeclarativeH264Streaming::Status QDeclarativeH264Streaming::status() const
+{
+    return Status(m_status);
+}
+
+
+/*!
+    \qmlproperty enumeration QtMultimedia::Audio::playbackState
+
+    This property holds the state of media playback. It can be one of:
+
+    \list
+    \li PlayingState - the media is currently playing.
+    \li PausedState - playback of the media has been suspended.
+    \li StoppedState - playback of the media is yet to begin.
+    \endlist
+*/
+
+QDeclarativeH264Streaming::PlaybackState QDeclarativeH264Streaming::playbackState() const
+{
+    return PlaybackState(m_playbackState);
+}
+
+/*!
+    \qmlproperty enumeration QtMultimedia::Audio::error
+
+    This property holds the error state of the audio.  It can be one of:
+
+    \table
+    \header \li Value \li Description
+    \row \li NoError
+        \li There is no current error.
+    \row \li ResourceError
+        \li The audio cannot be played due to a problem allocating resources.
+    \row \li FormatError
+        \li The audio format is not supported.
+    \row \li NetworkError
+        \li The audio cannot be played due to network issues.
+    \row \li AccessDenied
+        \li The audio cannot be played due to insufficient permissions.
+    \row \li ServiceMissing
+        \li The audio cannot be played because the media service could not be
+    instantiated.
+    \endtable
+*/
+
+QDeclarativeH264Streaming::Error QDeclarativeH264Streaming::error() const
+{
+    return Error(m_error);
+}
+
+void QDeclarativeH264Streaming::classBegin()
+{
+    m_player = new QH264Streaming(this, QH264Streaming::H264Streaming);
+
+    connect(m_player, SIGNAL(stateChanged(QH264Streaming::State)),
+            this, SLOT(_q_statusChanged()));
+    connect(m_player, SIGNAL(mediaStatusChanged(QH264Streaming::MediaStatus)),
+            this, SLOT(_q_statusChanged()));
+    connect(m_player, SIGNAL(mediaChanged(QMediaContent)),
+            this, SIGNAL(sourceChanged()));
+    connect(m_player, SIGNAL(durationChanged(qint64)),
+            this, SIGNAL(durationChanged()));
+    connect(m_player, SIGNAL(positionChanged(qint64)),
+            this, SIGNAL(positionChanged()));
+    connect(m_player, SIGNAL(error(QH264Streaming::Error)),
+            this, SLOT(_q_error(QH264Streaming::Error)));
+    // connect(m_player, SIGNAL(audioAvailableChanged(bool)),
+            // this, SIGNAL(hasAudioChanged()));
+    // connect(m_player, SIGNAL(videoAvailableChanged(bool)),
+            // this, SIGNAL(hasVideoChanged()));
+
+    emit mediaObjectChanged();
+}
+
+void QDeclarativeH264Streaming::componentComplete()
+{
+    if (!m_content.isNull() && (m_autoLoad || m_autoPlay)) {
+        m_player->setMedia(m_content, 0);
+        m_loaded = true;
+        if (m_position > 0)
+            m_player->setPosition(m_position);
+    }
+
+    m_complete = true;
+    m_player->componentComplete();
+
+    if (m_autoPlay) {
+        if (m_content.isNull()) {
+            m_player->stop();
+        } else {
+            m_player->play();
+        }
+    }
+}
+
+void QDeclarativeH264Streaming::_q_statusChanged()
+{
+    if (m_player->mediaStatus() == QH264Streaming::EndOfMedia && m_runningCount != 0) {
+        m_runningCount -= 1;
+        m_player->play();
+    }
+    const QH264Streaming::MediaStatus oldStatus = m_status;
+    const QH264Streaming::State lastPlaybackState = m_playbackState;
+
+    const QH264Streaming::State state = m_player->state();
+
+    m_playbackState = state;
+
+    m_status = m_player->mediaStatus();
+
+    if (m_status != oldStatus)
+        emit statusChanged();
+
+    if (lastPlaybackState != state) {
+
+        if (lastPlaybackState == QH264Streaming::StoppedState)
+            m_runningCount = m_loopCount - 1;
+
+        switch (state) {
+        case QH264Streaming::StoppedState:
+            emit stopped();
+            break;
+        case QH264Streaming::PausedState:
+            emit paused();
+            break;
+        case QH264Streaming::PlayingState:
+            emit playing();
+            break;
+        case QH264Streaming::VideoPlaying:
+            emit statusChanged();
+            break;
+        }
+
+        emit playbackStateChanged();
+    }
+}
+
+QT_END_NAMESPACE
+
+#include "moc_qdeclarativeH264Streaming_p.cpp"
+
+
diff --git a/src/imports/multimedia/qdeclarativeH264Streaming_p.h b/src/imports/multimedia/qdeclarativeH264Streaming_p.h
new file mode 100755
index 0000000..724095a
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeH264Streaming_p.h
@@ -0,0 +1,315 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QDECLARATIVEH264STREAMING_P_H
+#define QDECLARATIVEH264STREAMING_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of other Qt classes.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QtCore/qbasictimer.h>
+#include <QtQml/qqmlparserstatus.h>
+#include <QtQml/qqml.h>
+
+#include <qH264Streaming.h>
+
+QT_BEGIN_NAMESPACE
+
+class QTimerEvent;
+class QH264StreamingControl;
+class QMediaService;
+class QMediaServiceProvider;
+class QMetaDataReaderControl;
+class QDeclarativeMediaBaseAnimation;
+class QDeclarativeMediaMetaData;
+class QMediaAvailabilityControl;
+
+class QDeclarativeH264Streaming : public QObject, public QQmlParserStatus
+{
+    Q_OBJECT
+    Q_PROPERTY(QUrl source READ source WRITE setSource NOTIFY sourceChanged)
+    Q_PROPERTY(int loops READ loopCount WRITE setLoopCount NOTIFY loopCountChanged)
+    Q_PROPERTY(PlaybackState playbackState READ playbackState NOTIFY playbackStateChanged)
+    Q_PROPERTY(bool autoPlay READ autoPlay WRITE setAutoPlay NOTIFY autoPlayChanged)
+    Q_PROPERTY(bool autoLoad READ isAutoLoad WRITE setAutoLoad NOTIFY autoLoadChanged)
+    Q_PROPERTY(Status status READ status NOTIFY statusChanged)
+    Q_PROPERTY(int duration READ duration NOTIFY durationChanged)
+    Q_PROPERTY(int position READ position NOTIFY positionChanged)
+    Q_PROPERTY(Error error READ error NOTIFY errorChanged)
+    Q_PROPERTY(QString errorString READ errorString NOTIFY errorChanged)
+    Q_PROPERTY(QObject *mediaObject READ mediaObject NOTIFY mediaObjectChanged SCRIPTABLE false DESIGNABLE false)
+    Q_ENUMS(Status)
+    Q_ENUMS(Error)
+    Q_ENUMS(Loop)
+    Q_ENUMS(PlaybackState)
+    Q_ENUMS(Availability)
+    Q_INTERFACES(QQmlParserStatus)
+
+    Q_PROPERTY(int hdmiWidth READ hdmiWidth WRITE setHdmiWidth)
+    Q_PROPERTY(int hdmiHeight READ hdmiHeight WRITE setHdmiHeight)
+    Q_PROPERTY(QString hdmiFormat READ hdmiFormat WRITE setHdmiFormat)
+    Q_PROPERTY(int encBitrate READ encBitrate WRITE setEncBitrate)
+    Q_PROPERTY(int numPframes READ numPframes WRITE setNumPframes)
+    Q_PROPERTY(bool noReorder READ noReorder WRITE setNoReorder)
+    Q_PROPERTY(QString udpPort READ udpPort WRITE setUdpPort)
+    Q_PROPERTY(QString udpHost READ udpHost WRITE setUdpHost)
+    Q_PROPERTY(bool transmit READ transmit WRITE setTransmit)
+    Q_PROPERTY(bool vspm READ vspm WRITE setVspm)
+    Q_PROPERTY(bool vspmDmabuf READ vspmDmabuf WRITE setVspmDmabuf)
+    Q_PROPERTY(int vspmWidth READ vspmWidth WRITE setVspmWidth)
+    Q_PROPERTY(int vspmHeight READ vspmHeight WRITE setVspmHeight)
+    Q_PROPERTY(int vspmWidth1 READ vspmWidth1 WRITE setVspmWidth1)
+    Q_PROPERTY(int vspmHeight1 READ vspmHeight1 WRITE setVspmHeight1)
+    Q_PROPERTY(QString vspmFormat READ vspmFormat WRITE setVspmFormat)
+    Q_PROPERTY(int wlsMaxLateness READ wlsMaxLateness WRITE setWlsMaxLateness)
+    Q_PROPERTY(bool wlsQos READ wlsQos WRITE setWlsQos)
+    Q_PROPERTY(int wlsPositionX READ wlsPositionX WRITE setWlsPositionX)
+    Q_PROPERTY(int wlsPositionY READ wlsPositionY WRITE setWlsPositionY)
+    Q_PROPERTY(int wlsOutWidth READ wlsOutWidth WRITE setWlsOutWidth)
+    Q_PROPERTY(int wlsOutHeight READ wlsOutHeight WRITE setWlsOutHeight)
+public:
+    enum Status
+    {
+        UnknownStatus = QH264Streaming::UnknownMediaStatus,
+        NoMedia       = QH264Streaming::NoMedia,
+        Loading       = QH264Streaming::LoadingMedia,
+        Loaded        = QH264Streaming::LoadedMedia,
+        Stalled       = QH264Streaming::StalledMedia,
+        Buffering     = QH264Streaming::BufferingMedia,
+        Buffered      = QH264Streaming::BufferedMedia,
+        EndOfMedia    = QH264Streaming::EndOfMedia,
+        InvalidMedia  = QH264Streaming::InvalidMedia
+    };
+
+    enum Error
+    {
+        NoError        = QH264Streaming::NoError,
+        ResourceError  = QH264Streaming::ResourceError,
+        FormatError    = QH264Streaming::FormatError,
+        NetworkError   = QH264Streaming::NetworkError,
+        AccessDenied   = QH264Streaming::AccessDeniedError,
+        ServiceMissing = QH264Streaming::ServiceMissingError
+    };
+
+    enum Loop
+    {
+        Infinite = -1
+    };
+
+    enum PlaybackState
+    {
+        PlayingState = QH264Streaming::PlayingState,
+        PausedState = QH264Streaming::PausedState,
+        StoppedState = QH264Streaming::StoppedState,
+        VideoPlaying  = QH264Streaming::VideoPlaying
+    };
+
+    enum Availability {
+        Available = QMultimedia::Available,
+        Busy = QMultimedia::Busy,
+        Unavailable = QMultimedia::ServiceMissing,
+        ResourceMissing = QMultimedia::ResourceError
+    };
+
+    QDeclarativeH264Streaming(QObject *parent = 0);
+    ~QDeclarativeH264Streaming();
+
+    Status status() const;
+    Error error() const;
+    PlaybackState playbackState() const;
+    void setPlaybackState(QH264Streaming::State playbackState);
+
+    void classBegin();
+
+    QObject *mediaObject() { return m_player; }
+
+    QUrl source() const;
+    void setSource(const QUrl &url);
+
+    int loopCount() const;
+    void setLoopCount(int loopCount);
+
+    int duration() const;
+
+    int position() const;
+
+    QString errorString() const;
+
+    QDeclarativeMediaMetaData *metaData() const;
+
+    bool isAutoLoad() const;
+    void setAutoLoad(bool autoLoad);
+
+    bool autoPlay() const;
+    void setAutoPlay(bool autoplay);
+    
+    int hdmiWidth() const;
+    void setHdmiWidth(int hdmiwidth);
+    
+    int hdmiHeight() const;
+    void setHdmiHeight(int hdmiheight);
+    
+    QString hdmiFormat() const;
+    void setHdmiFormat(QString hdmiformat);
+    
+    bool noReorder() const;
+    void setNoReorder(bool noreorder);
+    
+    QString udpHost() const;
+    void setUdpHost(QString udphost);
+    
+    bool vspm() const;
+    void setVspm(bool vspm);
+
+public Q_SLOTS:
+    void play();
+    void pause();
+    void stop();
+    int encBitrate() const;
+    void setEncBitrate(int encbitrate);
+    int numPframes() const;
+    void setNumPframes(int numpframes);
+    int wlsMaxLateness() const;
+    void setWlsMaxLateness(int wlsmaxlateness);
+    bool wlsQos() const;
+    void setWlsQos(bool wlsqos);
+    bool transmit() const;
+    void setTransmit(bool transmit);
+    int wlsPositionX() const;
+    void setWlsPositionX(int wlspositionx);
+    QString udpPort() const;
+    void setUdpPort(QString udpport);
+    int wlsPositionY() const;
+    void setWlsPositionY(int wlspositiony);
+    bool vspmDmabuf() const; 
+    void setVspmDmabuf(bool vspmdmabuf);
+    int vspmWidth() const;
+    int vspmWidth1() const;
+    void setVspmWidth(int vspmwidth);
+    void setVspmWidth1(int vspmwidth1);
+    int vspmHeight() const;
+    int vspmHeight1() const;
+    void setVspmHeight(int vspmheight);
+    void setVspmHeight1(int vspmheight1);
+    QString vspmFormat() const;
+    void setVspmFormat(QString vspmformat);
+    int wlsOutWidth() const;
+    void setWlsOutWidth(int wlsoutwidth);
+    int wlsOutHeight() const;
+    void setWlsOutHeight(int wlsoutheight);
+    void componentComplete();
+
+Q_SIGNALS:
+    void sourceChanged();
+    void autoLoadChanged();
+    void loopCountChanged();
+
+    void playbackStateChanged();
+    void autoPlayChanged();
+
+    void paused();
+    void stopped();
+    void playing();
+
+    void statusChanged();
+
+    void durationChanged();
+    void positionChanged();
+
+    void errorChanged();
+    void error(QDeclarativeH264Streaming::Error error, const QString &errorString);
+
+    void mediaObjectChanged();
+
+private Q_SLOTS:
+    void _q_error(QH264Streaming::Error);
+    void _q_statusChanged();
+
+private:
+    Q_DISABLE_COPY(QDeclarativeH264Streaming)
+
+    bool m_autoPlay;
+    bool m_autoLoad;
+    bool m_loaded;
+    bool m_complete;
+    int m_loopCount;
+    int m_runningCount;
+    int m_position;
+
+    QH264Streaming::State m_playbackState;
+    QH264Streaming::MediaStatus m_status;
+    QH264Streaming::Error m_error;
+    QString m_errorString;
+    QUrl m_source;
+    QMediaContent m_content;
+
+    QH264Streaming *m_player;
+
+    int m_hdmi_width;
+    int m_hdmi_height;
+    QString m_hdmi_format;
+    int m_enc_bitrate;
+    int m_num_p_frames;
+    bool m_no_reorder;
+    QString m_udp_port;
+    QString m_udp_host;
+    bool m_transmit;
+    bool m_vspm;
+    bool m_vspm_dmabuf_use;
+    int m_vspm_width1;
+    int m_vspm_width;
+    int m_vspm_height1;
+    int m_vspm_height;
+    QString m_vspm_format;
+    int m_wls_max_lateness;
+    bool m_wls_qos;
+    int m_wls_position_x;
+    int m_wls_position_y;
+    int m_wls_out_width;
+    int m_wls_out_height;
+
+};
+
+QT_END_NAMESPACE
+
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativeH264Streaming))
+
+#endif
diff --git a/src/imports/multimedia/qdeclarativeMP4Playback.cpp b/src/imports/multimedia/qdeclarativeMP4Playback.cpp
new file mode 100755
index 0000000..9acd8b2
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeMP4Playback.cpp
@@ -0,0 +1,147 @@
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <QtQml/qqmlinfo.h>
+#include <qmediaservice.h>
+#include <private/qmediaserviceprovider_p.h>
+#include <qmetadatareadercontrol.h>
+#include <qmediaavailabilitycontrol.h>
+#include "qdeclarativemediametadata_p.h"
+#include "qdeclarativeMP4Playback_p.h"
+
+// #define DEBUG_QMP4PLAYBACK
+QT_BEGIN_NAMESPACE
+
+QDeclarativeMP4Playback::QDeclarativeMP4Playback(QObject *parent)
+    : QObject(parent)
+    , m_source("\0")
+    , m_loop(false)
+    , m_state(QMP4Playback::StoppedState)
+    , m_status(QMP4Playback::NoMedia)
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+QDeclarativeMP4Playback::~QDeclarativeMP4Playback()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+QMP4Playback::State QDeclarativeMP4Playback::state() const
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_state;
+}
+
+QMP4Playback::Status QDeclarativeMP4Playback::status() const
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_status;
+}
+
+void QDeclarativeMP4Playback::classBegin()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_mp4playback = new QMP4Playback(this);
+    connect(m_mp4playback, SIGNAL(signal_StateStatusChanged(QMP4Playback::State, QMP4Playback::Status)),
+            this, SLOT(processStateStatusChanged(QMP4Playback::State, QMP4Playback::Status)));
+}
+
+void QDeclarativeMP4Playback::componentComplete()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_mp4playback->componentComplete();
+}
+
+QString QDeclarativeMP4Playback::source() const
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_source;
+}
+
+bool QDeclarativeMP4Playback::loop() const
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_loop;
+}
+
+void QDeclarativeMP4Playback::setSource(QString src)
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_source = src;
+    m_mp4playback->setSource(m_source);
+}
+
+void QDeclarativeMP4Playback::setLoop(bool lo)
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_loop = lo;
+}
+
+void QDeclarativeMP4Playback::play()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_mp4playback->play();
+}
+
+void QDeclarativeMP4Playback::stop()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_mp4playback->stop();
+}
+
+void QDeclarativeMP4Playback::pause()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_mp4playback->pause();
+}
+
+void QDeclarativeMP4Playback::processStateStatusChanged(QMP4Playback::State newstate, QMP4Playback::Status newstatus)
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+    QMP4Playback::printState(newstate);
+    QMP4Playback::printStatus(newstatus);
+#endif
+    m_state = newstate;
+    m_status = newstatus;
+    emit stateChanged();
+    emit statusChanged();
+    if((m_status == QMP4Playback::EndOfMedia) && m_loop){
+        m_mp4playback->play();
+    }else if((m_status == QMP4Playback::EndOfMedia) && !m_loop){
+        m_mp4playback->stop();
+    }
+}
+
+QT_END_NAMESPACE
+#include "moc_qdeclarativeMP4Playback_p.cpp"
\ No newline at end of file
diff --git a/src/imports/multimedia/qdeclarativeMP4Playback_p.h b/src/imports/multimedia/qdeclarativeMP4Playback_p.h
new file mode 100755
index 0000000..77b9388
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeMP4Playback_p.h
@@ -0,0 +1,62 @@
+#ifndef QDECLARATIVEMP4PLAYBACK_P_H
+#define QDECLARATIVEMP4PLAYBACK_P_H
+
+#include <QtCore/qbasictimer.h>
+#include <QtQml/qqmlparserstatus.h>
+#include <QtQml/qqml.h>
+#include <qMP4Playback.h>
+
+QT_BEGIN_NAMESPACE
+class QMediaService;
+class QMediaServiceProvider;
+
+class QDeclarativeMP4Playback : public QObject, public QQmlParserStatus
+{
+    Q_OBJECT
+    Q_PROPERTY(QString source READ source WRITE setSource)
+    Q_PROPERTY(bool loop READ loop WRITE setLoop)
+    
+    Q_PROPERTY(QMP4Playback::Status status READ status NOTIFY statusChanged)
+    Q_PROPERTY(QMP4Playback::State state READ state NOTIFY stateChanged)
+    Q_INTERFACES(QQmlParserStatus)
+    
+public:
+    QDeclarativeMP4Playback(QObject *parent = 0);
+    ~QDeclarativeMP4Playback();
+    
+    QMP4Playback::Status status() const;
+    QMP4Playback::State state() const;
+    
+    void classBegin();
+    void componentComplete();
+    
+    QString source() const;
+    bool loop() const;
+    
+    void setSource(QString src);
+    void setLoop(bool lo);
+    
+public Q_SLOTS:
+    void play();
+    void stop();
+    void pause();
+    void processStateStatusChanged(QMP4Playback::State, QMP4Playback::Status);
+    
+Q_SIGNALS:
+    void statusChanged();
+    void stateChanged();
+    
+private:
+    Q_DISABLE_COPY(QDeclarativeMP4Playback)
+    QMP4Playback* m_mp4playback;
+    QMP4Playback::State m_state;
+    QMP4Playback::Status m_status;
+    
+    QString m_source;
+    bool m_loop;
+};
+
+QT_END_NAMESPACE
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativeMP4Playback))
+
+#endif
\ No newline at end of file
diff --git a/src/imports/multimedia/qdeclarativeMP4Recorder.cpp b/src/imports/multimedia/qdeclarativeMP4Recorder.cpp
new file mode 100755
index 0000000..0cf380d
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeMP4Recorder.cpp
@@ -0,0 +1,156 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QtQml/qqmlinfo.h>
+
+#include "qdeclarativeMP4Recorder_p.h"
+
+#include <qmediaservice.h>
+#include <private/qmediaserviceprovider_p.h>
+#include <qmetadatareadercontrol.h>
+#include <qmediaavailabilitycontrol.h>
+
+#include "qdeclarativemediametadata_p.h"
+
+#include <QTimerEvent>
+
+QT_BEGIN_NAMESPACE
+
+QDeclarativeMP4Recorder::QDeclarativeMP4Recorder(QObject *parent)
+    : QObject(parent)
+    , m_fsinklocation("\0")
+    , m_usrcport(0)
+{
+    // qDebug() << Q_FUNC_INFO;
+}
+
+QDeclarativeMP4Recorder::~QDeclarativeMP4Recorder()
+{
+    // qDebug() << Q_FUNC_INFO;
+}
+
+QDeclarativeMP4Recorder::Error QDeclarativeMP4Recorder::error() const
+{
+    // qDebug() << Q_FUNC_INFO;
+    return Error(m_error);
+}
+
+void QDeclarativeMP4Recorder::classBegin()
+{
+    // qDebug() << Q_FUNC_INFO;
+    
+    m_recorder = new QMP4Recorder(this);
+    connect(m_recorder, SIGNAL(mediaStatusChanged(QMP4Recorder::MediaStatus)),
+            this, SLOT(_q_statusChanged(QMP4Recorder::MediaStatus)));
+    emit mediaObjectChanged();
+}
+
+void QDeclarativeMP4Recorder::componentComplete()
+{
+    // qDebug() << Q_FUNC_INFO;
+    m_recorder->componentComplete();
+}
+
+void QDeclarativeMP4Recorder::start()
+{
+    // qDebug() << Q_FUNC_INFO;
+    m_recorder->start();
+}
+
+void QDeclarativeMP4Recorder::stop()
+{
+    // qDebug() << Q_FUNC_INFO;
+    m_recorder->stop();
+}
+
+void QDeclarativeMP4Recorder::pause()
+{
+    // qDebug() << Q_FUNC_INFO;
+    m_recorder->pause();
+}
+
+void QDeclarativeMP4Recorder::setUsrcPort(int usrcport)
+{
+    m_usrcport = usrcport;
+    m_recorder->setUsrcPort(m_usrcport);
+}
+
+void QDeclarativeMP4Recorder::setFSinkLocation(QString fsinkloc)
+{
+    m_fsinklocation = fsinkloc;
+    m_recorder->setFSinkLocation(m_fsinklocation);
+}
+
+int QDeclarativeMP4Recorder::usrcPort() const
+{
+    return m_usrcport;
+}
+
+QString QDeclarativeMP4Recorder::fSinkLocation() const
+{
+    return m_fsinklocation;
+}
+
+void QDeclarativeMP4Recorder::_q_statusChanged(QMP4Recorder::MediaStatus mst)
+{
+    // qDebug() << Q_FUNC_INFO;
+    // switch(mst){
+        // case QEncoderMMPOC::UnknownMediaStatus: qDebug() << "UnknownMediaStatus"; break;
+        // case QEncoderMMPOC::NoMedia: qDebug() << "NoMedia"; break;
+        // case QEncoderMMPOC::LoadingMedia: qDebug() << "LoadingMedia"; break;
+        // case QEncoderMMPOC::LoadedMedia: qDebug() << "LoadedMedia"; break;
+        // case QEncoderMMPOC::StalledMedia: qDebug() << "StalledMedia"; break;
+        // case QEncoderMMPOC::BufferingMedia: qDebug() << "BufferingMedia"; break;
+        // case QEncoderMMPOC::BufferedMedia: qDebug() << "BufferedMedia"; break;
+        // case QEncoderMMPOC::EndOfMedia: qDebug() << "EndOfMedia"; break;
+        // case QEncoderMMPOC::InvalidMedia: qDebug() << "InvalidMedia"; break;
+        // case QEncoderMMPOC::Active: qDebug() << "Active"; break;
+    // }
+    m_status = mst;
+    emit statusChanged();
+}
+
+QDeclarativeMP4Recorder::Status QDeclarativeMP4Recorder::status() const
+{
+    // qDebug() << Q_FUNC_INFO;
+    // switch(m_encoder->mediaStatus()){
+        // case QEncoderMMPOC::EndOfMedia: return QDeclarativeMP4Recorder::EndOfMedia;
+    // }
+    // return QDeclarativeMP4Recorder::UnknownStatus;
+    return Status(m_status);
+}
+
+QT_END_NAMESPACE
+
+#include "moc_qdeclarativeMP4Recorder_p.cpp"
+
+
diff --git a/src/imports/multimedia/qdeclarativeMP4Recorder_p.h b/src/imports/multimedia/qdeclarativeMP4Recorder_p.h
new file mode 100755
index 0000000..d74e1b1
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeMP4Recorder_p.h
@@ -0,0 +1,172 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QDECLARATIVEMP4RECORDER_P_H
+#define QDECLARATIVEMP4RECORDER_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of other Qt classes.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <QtCore/qbasictimer.h>
+#include <QtQml/qqmlparserstatus.h>
+#include <QtQml/qqml.h>
+
+#include <qMP4Recorder.h>
+// #include <qmediaplayerMMPOC.h>
+
+QT_BEGIN_NAMESPACE
+
+class QTimerEvent;
+class QMediaService;
+class QMediaServiceProvider;
+class QMetaDataReaderControl;
+class QDeclarativeMediaBaseAnimation;
+class QDeclarativeMediaMetaData;
+class QMediaAvailabilityControl;
+
+class QDeclarativeMP4Recorder : public QObject, public QQmlParserStatus
+{
+    Q_OBJECT
+    Q_PROPERTY(QString fSinkLocation READ fSinkLocation WRITE setFSinkLocation)
+    Q_PROPERTY(int usrcPort READ usrcPort WRITE setUsrcPort)
+    
+    Q_PROPERTY(Status status READ status NOTIFY statusChanged)
+    Q_PROPERTY(State state READ state NOTIFY stateChanged)
+    Q_PROPERTY(Error error READ error NOTIFY errorChanged)
+    Q_PROPERTY(QString errorString READ errorString NOTIFY errorChanged)
+    Q_PROPERTY(QObject *mediaObject READ mediaObject NOTIFY mediaObjectChanged SCRIPTABLE false DESIGNABLE false)
+    Q_ENUMS(Status)
+    Q_ENUMS(State)
+    Q_ENUMS(Error)
+    Q_INTERFACES(QQmlParserStatus)
+
+public:
+    enum Status {
+        UnknownStatus = QMP4Recorder::UnknownMediaStatus,
+        NoMedia       = QMP4Recorder::NoMedia,
+        LoadingMedia  = QMP4Recorder::LoadingMedia,
+        LoadedMedia   = QMP4Recorder::LoadedMedia,
+        EndOfMedia    = QMP4Recorder::EndOfMedia,
+        InvalidMedia  = QMP4Recorder::InvalidMedia,
+        Active        = QMP4Recorder::Active
+    };
+
+    enum State {
+        StoppedState = QMP4Recorder::StoppedState,
+        PlayingState = QMP4Recorder::StartedState,
+        PausedState  = QMP4Recorder::PausedState
+    };
+
+    enum Error
+    {
+        NoError             = QMP4Recorder::NoError,
+        InvalidRequestError = QMP4Recorder::InvalidRequestError,
+        InputArgumentError  = QMP4Recorder::InputArgumentError
+    };
+
+    QDeclarativeMP4Recorder(QObject *parent = 0);
+    ~QDeclarativeMP4Recorder();
+
+    Status status() const;
+    State state() const;
+    Error error() const;
+
+    QObject *mediaObject() { return NULL; }
+
+    void classBegin();
+    void componentComplete();
+
+    QString errorString() const;
+
+    void setUsrcPort(int usrcport);
+    void setFSinkLocation(QString fsinkloc);
+    
+    int usrcPort() const;
+    QString fSinkLocation() const;
+    
+public Q_SLOTS:
+    void pause();
+    void stop();
+    void start();
+    void _q_statusChanged(QMP4Recorder::MediaStatus);
+
+Q_SIGNALS:
+    void sourceChanged();
+    void autoLoadChanged();
+    void statusChanged();
+    void stateChanged();
+    void errorChanged();
+
+    void mediaObjectChanged();
+
+private Q_SLOTS:
+    void _q_error(QDeclarativeMP4Recorder::Error);
+    void _q_stateChanged();
+    
+
+private:
+    Q_DISABLE_COPY(QDeclarativeMP4Recorder)
+
+    QDeclarativeMP4Recorder::Error m_error;
+    QUrl m_source;
+    bool m_autoLoad;
+    bool m_loaded;
+    QMP4Recorder::MediaStatus m_status;
+
+    QMP4Recorder *m_recorder;
+    QString m_fsinklocation;
+    int m_usrcport;
+    
+
+};
+
+QT_END_NAMESPACE
+
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativeMP4Recorder))
+
+#endif
diff --git a/src/imports/multimedia/qdeclarativeaudiostreaming.cpp b/src/imports/multimedia/qdeclarativeaudiostreaming.cpp
new file mode 100755
index 0000000..30e13dd
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeaudiostreaming.cpp
@@ -0,0 +1,247 @@
+#include <QtQml/qqmlinfo.h>
+#include <qmediaservice.h>
+#include <private/qmediaserviceprovider_p.h>
+#include <qmetadatareadercontrol.h>
+#include <qmediaavailabilitycontrol.h>
+#include "qdeclarativemediametadata_p.h"
+#include "qdeclarativeaudiostreaming_p.h"
+
+// #define DEBUG_AUDIOSTREAMING
+
+QT_BEGIN_NAMESPACE
+
+QDeclarativeAudioStreaming::QDeclarativeAudioStreaming(QObject *parent)
+    : QObject(parent)
+    , m_type("\0")
+    , m_asrcdevice("hw:0,0")
+    , m_asinksync(true)
+    , m_usrcport(5004)
+    , m_usinkhost("localhost")
+    , m_usinkport(5004)
+    , m_usinksync(true)
+    , m_state(QAudioStreaming::StoppedState)
+    , m_status(QAudioStreaming::UnActive)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+QDeclarativeAudioStreaming::~QDeclarativeAudioStreaming()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+void QDeclarativeAudioStreaming::talk()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->talk();
+}
+
+void QDeclarativeAudioStreaming::mute()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->mute();
+}
+
+void QDeclarativeAudioStreaming::stop()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->stop();
+}
+
+QString QDeclarativeAudioStreaming::type() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_type;
+}
+
+QString QDeclarativeAudioStreaming::audioPlugin() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_audioplugin;
+}
+
+QString QDeclarativeAudioStreaming::asrcDevice() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_asrcdevice;
+}
+
+bool QDeclarativeAudioStreaming::asinkSync() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_asinksync;
+}
+
+int QDeclarativeAudioStreaming::usrcPort() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_usrcport;
+}
+
+QString QDeclarativeAudioStreaming::usinkHost() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_usinkhost;
+}
+
+int QDeclarativeAudioStreaming::usinkPort() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_usinkport;
+}
+
+bool QDeclarativeAudioStreaming::usinkSync() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_usinksync;
+}
+
+void QDeclarativeAudioStreaming::setType(QString type)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->setType(type);
+}
+
+void QDeclarativeAudioStreaming::setAudioPlugin(QString audioplugin)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->setAudioPlugin(audioplugin);
+}
+
+void QDeclarativeAudioStreaming::setAsrcDevice(QString device)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->setAsrcDevice(device);
+}
+
+void QDeclarativeAudioStreaming::setAsinkSync(bool sync)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->setAsinkSync(sync);
+}
+
+void QDeclarativeAudioStreaming::setUsrcPort(int port)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->setUsrcPort(port);
+}
+
+void QDeclarativeAudioStreaming::setUsinkHost(QString host)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->setUsinkHost(host);
+}
+
+void QDeclarativeAudioStreaming::setUsinkPort(int port)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->setUsinkPort(port);
+}
+
+void QDeclarativeAudioStreaming::setUsinkSync(bool sync)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->setUsinkSync(sync);
+}
+
+void QDeclarativeAudioStreaming::classBegin()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+    m_audiostream = new QAudioStreaming(this);
+    connect(m_audiostream, SIGNAL(signal_StateStatusChanged(QAudioStreaming::State, QAudioStreaming::Status)),
+            this, SLOT(processStateStatusChanged(QAudioStreaming::State, QAudioStreaming::Status)));
+}
+
+void QDeclarativeAudioStreaming::componentComplete()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_audiostream->componentComplete();
+}
+
+void QDeclarativeAudioStreaming::_q_statusChanged(QAudioStreaming::Status mst)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_status = mst;
+    emit statusChanged();
+}
+
+QAudioStreaming::Status QDeclarativeAudioStreaming::status() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_status;
+}
+
+QAudioStreaming::State QDeclarativeAudioStreaming::state() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_state;
+}
+
+void QDeclarativeAudioStreaming::processStateStatusChanged(QAudioStreaming::State newstate, QAudioStreaming::Status newstatus)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_state = newstate;
+    m_status = newstatus;
+    emit stateChanged();
+    emit statusChanged();
+}
+
+QT_END_NAMESPACE
+#include "moc_qdeclarativeaudiostreaming_p.cpp"
diff --git a/src/imports/multimedia/qdeclarativeaudiostreaming_p.h b/src/imports/multimedia/qdeclarativeaudiostreaming_p.h
new file mode 100755
index 0000000..1da3fc6
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeaudiostreaming_p.h
@@ -0,0 +1,120 @@
+#ifndef QDECLARATIVEAUDIOSTREAMING_P_H
+#define QDECLARATIVEAUDIOSTREAMING_P_H
+
+#include <QtCore/qbasictimer.h>
+#include <QtQml/qqmlparserstatus.h>
+#include <QtQml/qqml.h>
+#include <qaudiostreaming.h>
+
+QT_BEGIN_NAMESPACE
+class QMediaService;
+class QMediaServiceProvider;
+
+class QDeclarativeAudioStreaming : public QObject, public QQmlParserStatus
+{
+    Q_OBJECT
+    Q_PROPERTY(QString type READ type WRITE setType)
+    Q_PROPERTY(QString audioPlugin READ audioPlugin WRITE setAudioPlugin)
+    Q_PROPERTY(QString asrcDevice READ asrcDevice WRITE setAsrcDevice)
+    Q_PROPERTY(bool asinkSync READ asinkSync WRITE setAsinkSync)
+    Q_PROPERTY(int usrcPort READ usrcPort WRITE setUsrcPort)
+    Q_PROPERTY(QString usinkHost READ usinkHost WRITE setUsinkHost)
+    Q_PROPERTY(int usinkPort READ usinkPort WRITE setUsinkPort)
+    Q_PROPERTY(bool usinkSync READ usinkSync WRITE setUsinkSync)
+    
+    Q_PROPERTY(QAudioStreaming::Status status READ status NOTIFY statusChanged)
+    Q_PROPERTY(QAudioStreaming::State state READ state NOTIFY stateChanged)
+    Q_PROPERTY(Error error READ error NOTIFY errorChanged)
+    Q_PROPERTY(QString errorString READ errorString NOTIFY errorChanged)
+    Q_ENUMS(Status)
+    Q_ENUMS(State)
+    Q_ENUMS(Error)
+    Q_INTERFACES(QQmlParserStatus)
+
+public:
+    enum Status
+    {
+        UnknownStatus = QAudioStreaming::UnknownStatus,
+        NoMedia       = QAudioStreaming::NoMedia,
+        LoadingMedia  = QAudioStreaming::LoadingMedia,
+        LoadedMedia   = QAudioStreaming::LoadedMedia,
+        UnActive      = QAudioStreaming::UnActive,
+        Active        = QAudioStreaming::Active
+    };
+
+    enum State {
+        StoppedState,
+        TalkedState,
+        MutedState,
+        TalkedMutedState
+    };
+
+    enum Error
+    {
+        NoError,
+        ResourceError,
+        InputArgumentError
+    };
+    
+    QDeclarativeAudioStreaming(QObject *parent = 0);
+    ~QDeclarativeAudioStreaming();
+
+    QAudioStreaming::Status status() const;
+    QAudioStreaming::State state() const;
+    Error error() const;
+
+    void classBegin();
+    void componentComplete();
+
+    QString errorString() const;
+    
+    QString type() const;
+    QString audioPlugin() const;
+    QString asrcDevice() const;
+    bool asinkSync() const;
+    int usrcPort() const;
+    QString usinkHost() const;
+    int usinkPort() const;
+    bool usinkSync() const;
+    
+    void setType(QString type);
+    void setAudioPlugin(QString audioplugin);
+    void setAsrcDevice(QString device);
+    void setAsinkSync(bool sync);
+    void setUsrcPort(int port);
+    void setUsinkHost(QString host);
+    void setUsinkPort(int port);
+    void setUsinkSync(bool sync);
+    
+public Q_SLOTS:
+    void talk();
+    void mute();
+    void stop();
+    void _q_statusChanged(QAudioStreaming::Status);
+    void processStateStatusChanged(QAudioStreaming::State, QAudioStreaming::Status);
+    
+Q_SIGNALS:
+    void statusChanged();
+    void stateChanged();
+    void errorChanged();
+    
+private:
+    Q_DISABLE_COPY(QDeclarativeAudioStreaming)
+    QAudioStreaming* m_audiostream;
+    QAudioStreaming::State m_state;
+    QAudioStreaming::Status m_status;
+    
+    QString m_type;
+    QString m_audioplugin;
+    QString m_asrcdevice;
+    bool m_asinksync;
+    int m_usrcport;
+    QString m_usinkhost;
+    int m_usinkport;
+    bool m_usinksync;
+};
+
+QT_END_NAMESPACE
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativeAudioStreaming))
+
+#endif
\ No newline at end of file
diff --git a/src/imports/multimedia/qdeclarativeaxistat.cpp b/src/imports/multimedia/qdeclarativeaxistat.cpp
new file mode 100644
index 0000000..0326ec3
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeaxistat.cpp
@@ -0,0 +1,565 @@
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <QtQml/qqmlinfo.h>
+#include <qmediaservice.h>
+#include <private/qmediaserviceprovider_p.h>
+#include <qmetadatareadercontrol.h>
+#include <qmediaavailabilitycontrol.h>
+#include "qdeclarativemediametadata_p.h"
+#include "qdeclarativeaxistat_p.h"
+
+// #define DEBUG_AXISTAT
+QT_BEGIN_NAMESPACE
+
+static void qRegisterAxistatMetaTypes()
+{
+    qRegisterMetaType<QDeclarativeAxistat::AxistatState>("QDeclarativeAxistat::AxistatState");
+}
+Q_CONSTRUCTOR_FUNCTION(qRegisterAxistatMetaTypes)
+
+QDeclarativeAxistat::QDeclarativeAxistat(QObject *parent)
+    : QMediaObject(parent, 0)
+    , m_updateaxist(false)
+    , m_measurestate(false)
+    , m_mem_fd(-1)
+    , m_interval(1000)
+    , m_pattern(PATTERN0)
+    , m_burst_types(8)
+    , m_filter_size(0)
+    , m_filter_length(0)
+    , m_id_mask(1)
+    , m_countofres(-1)
+    , m_numofres(-1)
+    , m_filter("m1")
+    , m_state(QDeclarativeAxistat::InActivatedState)
+    , m_ddrR(0)
+    , m_ddrW(0)
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+QDeclarativeAxistat::~QDeclarativeAxistat()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+
+}
+
+bool QDeclarativeAxistat::updateaxist()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    /* Interrupt is cleared when the measurement completion is done, and the result is displayed */
+    uVal = READREG32(AXI.AXSTS3CCIR);
+    if(uVal & IR_TE)
+    {
+        /* The result is displayed according to the measurement pattern */
+        process_result();
+        // axi_display_result(m_pattern, m_device, m_id_mask, m_mul_read, m_mul_write);
+    
+        /* Clearness of interrupt factor register */
+        uVal = READREG32(AXI.AXSTS3CCIR);
+        uVal &= ~(IR_TE);
+        WRITEREG32(AXI.AXSTS3CCIR, uVal);
+        
+        // /* fixme: It confirms whether skipping has been generated when the continuousness execution mode is effective */
+        uVal = READREG32(AXI.AXSTS3CCCNT);
+
+        if(internal_countofres > 0){
+            internal_countofres--;
+        }
+        if(internal_countofres == 0){
+            inactive();
+        }
+        
+        if(m_pattern == PATTERN1){
+            if(m_numofres != -1){
+                internal_numofres--;
+                if(internal_numofres == 0){
+                    axi_stop_measurement(m_device);
+                    analysis();
+                    measure();
+                }
+            }
+        }
+    }
+    
+    return m_updateaxist;
+}
+
+void QDeclarativeAxistat::active()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+
+    /* open /dev/mem */
+    m_mem_fd = open(DEVNAME_MEM, O_RDWR);
+    
+    /* get device infomation */
+    m_pPRRBase = mmap( NULL, PRR_REGSIZE, PROT_READ|PROT_WRITE, MAP_SHARED, m_mem_fd, PRR_REGBASE );
+    uReg = (unsigned long)m_pPRRBase + (PRR - PRR_REGBASE);
+    uVal = READREG32(uReg);
+    m_device = uVal & 0x0000ff00;
+    m_device_version = uVal & 0x000000f0;
+    munmap(m_pPRRBase,PRR_REGSIZE);
+    axi_display_board_information(m_device, m_device_version);
+    
+    /* AXISTAT module wakeup */
+    m_pCpgBase = mmap( NULL, TMP_REGSIZE,
+                    PROT_READ|PROT_WRITE, MAP_SHARED, m_mem_fd, TMP_REGBASE );
+    uReg = (unsigned long)m_pCpgBase + (SMSTPCR3 - TMP_REGBASE);
+    uVal = READREG32(uReg);
+    if ((uVal & 0x00000002) != 0) {
+        uVal &= ~(0x00000002);
+        WRITEREG32(uReg, uVal);
+        printf("\e[31mWakeup AXISTAT module!\r\e[0m\n");
+    }
+    munmap(m_pCpgBase,TMP_REGSIZE);
+
+    /* initialize AXISTAT registers */
+    m_pAXISTATRegBase = mmap( NULL, AXISTAT_SIZE01,
+                            PROT_READ|PROT_WRITE, MAP_SHARED, m_mem_fd,
+                            AXISTAT_BASE01 );
+
+    axi_init((unsigned long)m_pAXISTATRegBase, m_device);
+    reg_addr_init();
+    
+    analysis();
+    measure();
+
+    m_state = QDeclarativeAxistat::ActivatedState;
+    emit axistatStateChanged();
+    
+    internal_countofres = m_countofres;
+    addPropertyWatch("updateaxist");
+    m_updateaxist = true;
+}
+
+void QDeclarativeAxistat::inactive()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_updateaxist = false;
+    removePropertyWatch("updateaxist");
+    
+    m_state = QDeclarativeAxistat::InActivatedState;
+    emit axistatStateChanged();
+    
+    axi_stop_measurement(m_device);
+    munmap(m_pAXISTATRegBase,AXISTAT_SIZE01);
+    close(m_mem_fd);
+}
+
+void QDeclarativeAxistat::analysis()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    int i;
+    int g_on_going;
+    char f_skip;
+    struct burst filtered_list[8];
+    unsigned char list_length = 0;
+    unsigned long tmp_reg_0 = 0;
+    unsigned long tmp_reg_1 = 0;
+    unsigned long tmp_reg_2 = 0;
+    unsigned long tmp_reg_3 = 0;
+    unsigned long sum_read, sum_write;
+    if  (m_pattern == PATTERN1)	//GPU or CPU measurement. Start analyzing burst types
+    {
+        internal_numofres = m_numofres;
+        // Set connection
+        // set_connection(pattern);
+        axi_set_connection(m_pattern, m_device);
+
+        list_length = 0;
+        for (i = 0; i < m_burst_types; i++)
+        {
+            // Set ID filter
+            // set_filter(pattern);
+            axi_set_filter(m_pattern, m_device, m_id_mask, m_filter_size, m_filter_length);
+
+            // set_timer_ms(50);
+            axi_set_timer_ms(m_device, 50);
+
+            // set_interrupt();
+            axi_set_interrupt();
+
+            // set_size_length_filter(aList[i].size, aList[i].length);
+            axi_set_size_length_filter(aList[i].size, aList[i].length);
+
+            // start_measurement();
+            axi_start_measurement(m_device);
+
+            f_skip = 1;			// skipping flag to ignore unstable results
+            g_on_going = 1;
+            while( g_on_going != 0 )
+            {
+                /* Interrupt is cleared when the measurement completion is done, and the result is displayed */
+                uVal = READREG32(AXI.AXSTS3CCIR);
+                if(uVal & IR_TE)
+                {
+                    // /* The result is displayed according to the measurement pattern */
+                    if (f_skip > 0)
+                    {
+                        // dump_SR();
+                        axi_dump_SR();
+                        f_skip--;
+                    }
+                    else
+                    {
+                        tmp_reg_0 = diff_readreg32(AXSTS3CCSR02);
+                        tmp_reg_1 = diff_readreg32(AXSTS3CCSR12);
+                        tmp_reg_2 = diff_readreg32(AXSTS3CCSR22);
+                        tmp_reg_3 = diff_readreg32(AXSTS3CCSR32);
+                        
+                        if (tmp_reg_0 > 0 || tmp_reg_1 > 0
+                         || tmp_reg_2 > 0 || tmp_reg_3 > 0
+                            )
+                        {
+                            filtered_list[list_length].size = aList[i].size;
+                            filtered_list[list_length].length = aList[i].length;
+                            filtered_list[list_length].read = (tmp_reg_0 + tmp_reg_1);
+                            filtered_list[list_length].write = (tmp_reg_2 + tmp_reg_3);
+                            list_length++;
+                        }
+                        g_on_going = 0;
+                    }
+                    /* Clearness of interrupt factor register */
+                    uVal = READREG32(AXI.AXSTS3CCIR);
+                    uVal &= ~(IR_TE);
+                    WRITEREG32(AXI.AXSTS3CCIR, uVal);
+                }
+            }
+            // stop_measurement();
+            axi_stop_measurement(m_device);
+        }
+        // STATISTIC
+        sum_read 	= 0;
+        sum_write 	= 0;
+        m_mul_read 	= 0;
+        m_mul_write 	= 0;
+        for (i=0; i<list_length; i++)
+        {
+            sum_read += filtered_list[i].read;
+            sum_write += filtered_list[i].write;
+        }
+        for (i=0; i<list_length; i++)
+        {
+            printf ("\e[34mS%d-L%d R=%d%\tW=%d%\e[0m\n"
+                        , filtered_list[i].size
+                        , filtered_list[i].length
+                        , ((sum_read==0)	? 0 : (filtered_list[i].read*100/sum_read))
+                        , ((sum_write==0)	? 0 : (filtered_list[i].write*100/sum_write))
+                    );
+            m_mul_read += (filtered_list[i].read*filtered_list[i].length);
+            m_mul_write += (filtered_list[i].write*filtered_list[i].length);
+        }
+        if (sum_read > 0)
+        {
+            m_mul_read = m_mul_read*100 /sum_read;
+        }
+        if (sum_write > 0)
+        {
+            m_mul_write = m_mul_write *100 /sum_write;
+        }
+        
+    }
+}
+
+void QDeclarativeAxistat::measure()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    /* Measurement HW counter (1up every one cycle) is clear */
+    WRITEREG32(AXI.AXSTS3CCCNT, 0);
+
+    axi_set_connection(m_pattern, m_device);
+    axi_set_filter(m_pattern, m_device, m_id_mask, m_filter_size, m_filter_length);
+    axi_set_size_length_filter(m_filter_size, m_filter_length);
+    axi_set_timer_ms(m_device, m_interval);
+    axi_set_interrupt();
+    axi_dump_SR(); // make sure there are NOT any value in output registors.
+    axi_start_measurement(m_device);
+}
+
+void QDeclarativeAxistat::classBegin()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+void QDeclarativeAxistat::componentComplete()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+QDeclarativeAxistat::AxistatState QDeclarativeAxistat::axistatstate()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_state;
+}
+
+int QDeclarativeAxistat::interval()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_interval;
+}
+
+void QDeclarativeAxistat::setInterval(int interval)
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO << "Input: " << interval;
+#endif
+    m_interval = interval;
+    setNotifyInterval(interval);
+}
+
+int QDeclarativeAxistat::countofres()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_countofres;
+}
+
+void QDeclarativeAxistat::setCountofres(int countofres)
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO << "Input: " << countofres;
+#endif
+    m_countofres = countofres;
+}
+
+int QDeclarativeAxistat::numofres()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_numofres;
+}
+
+void QDeclarativeAxistat::setNumofres(int numofres)
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO << "Input: " << numofres;
+#endif
+    m_numofres = numofres;
+}
+
+int QDeclarativeAxistat::pattern()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_pattern;
+}
+
+void QDeclarativeAxistat::setPattern(int pattern)
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO << "Input: " << pattern;
+#endif
+    m_pattern = (MeasPattern)pattern;
+}
+
+int QDeclarativeAxistat::filter()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_id_mask;
+}
+
+void QDeclarativeAxistat::setFilter(int filter)
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO << "Input: " << filter;
+#endif
+    m_id_mask = filter;
+}
+
+long QDeclarativeAxistat::DDRR()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_ddrR;
+}
+
+long QDeclarativeAxistat::DDRW()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_ddrW;
+}
+
+long QDeclarativeAxistat::GPUR()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_gpuR;
+}
+
+long QDeclarativeAxistat::GPUW()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_gpuW;
+}
+
+long QDeclarativeAxistat::CPUR()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_cpuR;
+}
+
+long QDeclarativeAxistat::CPUW()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_cpuW;
+}
+
+void QDeclarativeAxistat::process_result()
+{
+#ifdef DEBUG_AXISTAT
+    qDebug() << Q_FUNC_INFO;
+#endif
+    switch(m_pattern) {
+        case PATTERN0:
+        {
+            /* [Conversion description]
+            The connection nets in this pattern is used to count the number of data transaction SEPARATELY.
+            This connection net is [S3 cache_0/1] <-> [MEM_0/1]
+            The signal rvalid/ wvalid data cell is counted in stead of arvalid/ awvalid. (Please refer to AMBA AXI specification)
+            
+            Ex: burst_length = 4 => counted_value = 4 x number_of_burst.
+            The size of transaction data is always 32 bytes = 256 bits (S3 AXI bus width). (Please refer to AMBA AXI specification)
+            
+            Signal-MB/s conversion method used for this pattern is QUITE DIFFERENT from the others pattern
+            because of its SEPARATELY counting method.
+            Rate (MB/s) = (counted_value x 32) / (1024 x 1024)
+            */
+            unsigned long	read_tmp_reg_0;
+            unsigned long	read_tmp_reg_1;
+            unsigned long	read_tmp_reg_2;
+            unsigned long	read_tmp_reg_3;
+            
+            read_tmp_reg_0 = diff_readreg32(AXSTS3CCSR61);
+            read_tmp_reg_1 = diff_readreg32(AXSTS3CCSR71);
+            read_tmp_reg_2 = diff_readreg32(AXSTS3CCSR81);
+            read_tmp_reg_3 = diff_readreg32(AXSTS3CCSR91);
+            
+            /* (/32768) is a value converted to calculate (x32 /(1024 x 1024)) without overflowing */
+            // printf("DDR R=%4ldMB/s, W=%4ldMB/s\r\n",(read_tmp_reg_0 + read_tmp_reg_2)/32768, (read_tmp_reg_1 + read_tmp_reg_3)/32768);
+            m_ddrR = (read_tmp_reg_0 + read_tmp_reg_2)/32768;
+            m_ddrW = (read_tmp_reg_1 + read_tmp_reg_3)/32768;
+            
+            emit memoryChanged();
+            break;
+        }
+
+        case PATTERN1:
+        {
+            /* 
+            The connection nets in this pattern is used to count the number of BURST transaction.
+            This connection net is [S3 cache_0/1] <-> [MEM_0/1]
+            The signal arvalid/ awvalid is counted. (Please refer to AMBA AXI specification)
+            
+            Counted_value = number of burst, regardless to burst length.
+            The size of transaction data is always 32 bytes = 256 bits (S3 AXI bus width). (Please refer to AMBA AXI specification)
+            
+            Signal-MB/s conversion method used for pattern[1 -> 9] is similar:
+            Rate (MB/s) = (counted_value x 32 x burst_length) / (1024 x 1024).
+            However, there are many kind of burst-based transactions with different burst lengths.
+            The solution for burst_length calculation is the probability of existence of each kind of burst.
+            
+            For example, in 01 second of transaction, there are:
+            Length = 2: ~12%
+            Length = 4: ~30%
+            Length = 8: ~58%
+            Rate (MB/s) = (counted_value x 32) x (0.12 x 2 + 0.3 x 4 + 0.58 x 8) / (1024 x 1024)
+            */
+            
+            /* GPU */
+            unsigned long	read_tmp_reg_0;
+            unsigned long	read_tmp_reg_1;
+            unsigned long	read_tmp_reg_2;
+            unsigned long	read_tmp_reg_3;
+            read_tmp_reg_0 = diff_readreg32(AXSTS3CCSR02);
+            read_tmp_reg_1 = diff_readreg32(AXSTS3CCSR12);
+            read_tmp_reg_2 = diff_readreg32(AXSTS3CCSR22);
+            read_tmp_reg_3 = diff_readreg32(AXSTS3CCSR32);
+            
+            /* DDR */
+            unsigned long	read_tmp_reg_4;
+            unsigned long	read_tmp_reg_5;
+            unsigned long	read_tmp_reg_6;
+            unsigned long	read_tmp_reg_7;
+            read_tmp_reg_4 = diff_readreg32(AXSTS3CCSR61);
+            read_tmp_reg_5 = diff_readreg32(AXSTS3CCSR71);
+            read_tmp_reg_6 = diff_readreg32(AXSTS3CCSR81);
+            read_tmp_reg_7 = diff_readreg32(AXSTS3CCSR91);
+            
+            // printf("DDR: R=%4ldMB/s, W=%4ldMB/s\t"
+                        // , (read_tmp_reg_4 + read_tmp_reg_6)/32768
+                        // , (read_tmp_reg_5 + read_tmp_reg_7)/32768
+                        // );
+            m_ddrR = (read_tmp_reg_4 + read_tmp_reg_6)/32768;
+            m_ddrW = (read_tmp_reg_5 + read_tmp_reg_7)/32768;
+            switch (m_id_mask)
+            {
+                case 1:
+                    // printf("\e[31mGPU: \e[0m");
+                    m_gpuR = (read_tmp_reg_0 + read_tmp_reg_1)/32768*m_mul_read/100;
+                    m_gpuW = (read_tmp_reg_2 + read_tmp_reg_3)/32768*m_mul_write/100;
+                    emit memoryChanged();
+                    emit gpuChanged();
+                    break;
+                    
+                case 2:
+                    // printf("\e[31mCPU: \e[0m");
+                    m_cpuR = (read_tmp_reg_0 + read_tmp_reg_1)/32768*m_mul_read/100;
+                    m_cpuW = (read_tmp_reg_2 + read_tmp_reg_3)/32768*m_mul_write/100;
+                    emit memoryChanged();
+                    emit cpuChanged();
+                    break;
+            }
+            // printf("R=%4ldMB/s, W=%4ldMB/s\r\n"
+                        // , (read_tmp_reg_0 + read_tmp_reg_1)/32768*mul_read/100
+                        // , (read_tmp_reg_2 + read_tmp_reg_3)/32768*mul_write/100
+                        // );
+            break;
+        }
+        
+    }
+}
+
+QT_END_NAMESPACE
+#include "moc_qdeclarativeaxistat_p.cpp"
\ No newline at end of file
diff --git a/src/imports/multimedia/qdeclarativeaxistat_p.h b/src/imports/multimedia/qdeclarativeaxistat_p.h
new file mode 100644
index 0000000..7fb50ed
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeaxistat_p.h
@@ -0,0 +1,156 @@
+#ifndef QDECLARATIVEAXISTAT_P_H
+#define QDECLARATIVEAXISTAT_P_H
+
+#include <QtCore/qbasictimer.h>
+#include <QtQml/qqmlparserstatus.h>
+#include <QtQml/qqml.h>
+#include <QtMultimedia/qmediaobject.h>
+
+extern "C" {
+#include "axistat/axi.h"
+#include "axistat/axistatus.h"
+#include "axistat/axistat.h"
+}
+
+QT_BEGIN_NAMESPACE
+
+// class QDeclarativeAxistat : public QObject, public QQmlParserStatus
+class QDeclarativeAxistat : public QMediaObject, public QQmlParserStatus
+{
+    Q_OBJECT
+    
+    //Interval (-i)
+    Q_PROPERTY(int interval READ interval WRITE setInterval)
+
+    //Count of result (-c)
+    Q_PROPERTY(int countofres READ countofres WRITE setCountofres)
+
+    //Number of displayed result (-a)
+    Q_PROPERTY(int numofres READ numofres WRITE setNumofres)
+
+    //Pattern (-p)
+    Q_PROPERTY(int pattern READ pattern WRITE setPattern)
+
+    //GPU filter m1/CPU filter m2
+    Q_PROPERTY(int filter READ filter WRITE setFilter)
+
+    //DDR R= 378MB/s, W=   0MB/s
+    Q_PROPERTY(long DDRR READ DDRR NOTIFY memoryChanged)
+    Q_PROPERTY(long DDRW READ DDRW NOTIFY memoryChanged)
+    
+    // GPU: R=   0MB/s, W=   0MB/s
+    Q_PROPERTY(long GPUR READ GPUR NOTIFY gpuChanged)
+    Q_PROPERTY(long GPUW READ GPUW NOTIFY gpuChanged)
+    
+    // CPU: R=   0MB/s, W=   0MB/s
+    Q_PROPERTY(long CPUR READ CPUR NOTIFY cpuChanged)
+    Q_PROPERTY(long CPUW READ CPUW NOTIFY cpuChanged)
+    
+    Q_PROPERTY(bool updateaxist READ updateaxist NOTIFY updateAxistChanged)
+    
+    Q_PROPERTY(AxistatState axistatstate READ axistatstate NOTIFY axistatStateChanged)
+    Q_ENUMS(AxistatState)
+    Q_INTERFACES(QQmlParserStatus)
+    
+public:
+    
+    enum AxistatState
+    {
+        ActivatedState,
+        InActivatedState,
+        FinishedState
+    };
+
+    QDeclarativeAxistat(QObject *parent = 0);
+    ~QDeclarativeAxistat();
+    
+    AxistatState axistatstate();
+    
+    void classBegin();
+    void componentComplete();
+    
+    int interval();
+    void setInterval(int interval);
+    int countofres();
+    void setCountofres(int);
+    int numofres();
+    void setNumofres(int);
+    int pattern();
+    void setPattern(int);
+    int filter();
+    void setFilter(int);
+    
+    long DDRR();
+    long DDRW();
+    
+    long GPUR();
+    long GPUW();
+    
+    long CPUR();
+    long CPUW();
+    
+    bool updateaxist();
+    
+    
+public Q_SLOTS:
+    void active();
+    void inactive();
+    
+
+Q_SIGNALS:
+    void updateAxistChanged();
+    void axistatStateChanged();
+    void memoryChanged();
+    void gpuChanged();
+    void cpuChanged();
+    
+private:
+    void analysis();
+    void measure();
+    void process_result();
+    Q_DISABLE_COPY(QDeclarativeAxistat)
+
+    struct burst aList[8] = {
+        {16, 1, 0, 0},
+        {16, 2, 0, 0},
+        {16, 3, 0, 0},
+        {16, 4, 0, 0},
+        {16, 8, 0, 0},
+        {32, 1, 0, 0},
+        {32, 2, 0, 0},
+        {32, 4, 0, 0}
+    };
+
+    bool m_measurestate;
+    bool m_updateaxist;
+    int m_interval; //Interval (-i)
+    int m_countofres; //Count of result (-c)
+    int m_numofres; //Number of displayed result (-a)
+    MeasPattern m_pattern; //Pattern (-p)
+    QString m_filter; //GPUfilter m1 / CPUfilter m2
+    AxistatState m_state;
+    long m_ddrR;
+    long m_ddrW;
+    long m_gpuR;
+    long m_gpuW;
+    long m_cpuR;
+    long m_cpuW;
+
+    int m_mem_fd; //device handle
+    unsigned long m_device, m_device_version; //device information
+    void *m_pAXISTATRegBase, *m_pCpgBase, *m_pPRRBase;
+    unsigned long uReg, uVal, uReg_axistat_ctl;
+    int m_burst_types;
+    unsigned long m_mul_read, m_mul_write;
+    int m_id_mask;
+    int m_filter_size, m_filter_length;
+    int internal_countofres;
+    int internal_numofres;
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QDeclarativeAxistat::AxistatState)
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativeAxistat))
+
+#endif
\ No newline at end of file
diff --git a/src/multimedia/audio/audio.pri b/src/multimedia/audio/audio.pri
index 96cfb1c..8098131 100644
--- a/src/multimedia/audio/audio.pri
+++ b/src/multimedia/audio/audio.pri
@@ -12,7 +12,8 @@ PUBLIC_HEADERS += \
            audio/qsoundeffect.h \
            audio/qsound.h \
            audio/qaudioprobe.h \
-           audio/qaudiodecoder.h
+           audio/qaudiodecoder.h \
+           audio/qaudiostreaming.h
 
 PRIVATE_HEADERS += \
            audio/qaudiobuffer_p.h \
@@ -37,6 +38,7 @@ SOURCES += \
            audio/qaudiobuffer.cpp \
            audio/qaudioprobe.cpp \
            audio/qaudiodecoder.cpp \
+           audio/qaudiostreaming.cpp \
            audio/qaudiohelpers.cpp
 
 unix:!mac {
diff --git a/src/multimedia/audio/qaudiostreaming.cpp b/src/multimedia/audio/qaudiostreaming.cpp
new file mode 100755
index 0000000..ad752c8
--- /dev/null
+++ b/src/multimedia/audio/qaudiostreaming.cpp
@@ -0,0 +1,257 @@
+#include "qaudiostreaming.h"
+#include "qmediaobject_p.h"
+#include <qmediaservice.h>
+#include <qmediaserviceprovider_p.h>
+#include <qaudiostreamingcontrol.h>
+
+#include <QtCore/qdebug.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qstringlist.h>
+#include <QtCore/qmetaobject.h>
+
+// #define DEBUG_AUDIOSTREAMING
+
+QT_BEGIN_NAMESPACE
+
+static void qRegisterMediaPlayerMetaTypes()
+{
+    qRegisterMetaType<QAudioStreaming::State>("QAudioStreaming::State");
+    qRegisterMetaType<QAudioStreaming::Status>("QAudioStreaming::Status");
+    qRegisterMetaType<QAudioStreaming::Error>("QAudioStreaming::Error");
+}
+Q_CONSTRUCTOR_FUNCTION(qRegisterMediaPlayerMetaTypes)
+
+class QAudioStreamingPrivate : public QMediaObjectPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QAudioStreaming)
+
+public:
+    QAudioStreamingPrivate()
+        : provider(0)
+        , control(0)
+    {}
+    
+    QMediaServiceProvider *provider;
+    QAudioStreamingControl* control;
+    
+    void _q_stateChanged(QAudioStreaming::State);
+    void _q_statusChanged(QAudioStreaming::Status);
+    void _q_error(int, const QString &);
+};
+
+void QAudioStreamingPrivate::_q_stateChanged(QAudioStreaming::State)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+void QAudioStreamingPrivate::_q_statusChanged(QAudioStreaming::Status)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+void QAudioStreamingPrivate::_q_error(int, const QString &errorString)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+}
+
+
+static QMediaService *playerService()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider();
+    return provider->requestService(Q_MEDIASERVICE_AUDIOSTREAMING);
+}
+
+QAudioStreaming::QAudioStreaming(QObject *parent):QMediaObject(*new QAudioStreamingPrivate, parent, playerService())
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->provider = QMediaServiceProvider::defaultServiceProvider();
+    if (d->service == 0) {
+        
+    }else{
+        d->control = qobject_cast<QAudioStreamingControl*>(d->service->requestControl(QAudioStreamingControl_iid));
+        if (d->control != 0) {
+            connect(d->control, SIGNAL(statestatusChanged(QAudioStreaming::State, QAudioStreaming::Status)),
+                    SLOT(slot_StateStatusChanged(QAudioStreaming::State, QAudioStreaming::Status)));
+        }
+    }
+}
+
+QAudioStreaming::~QAudioStreaming()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+
+    if (d->service) {
+        if (d->control)
+            d->service->releaseControl(d->control);
+
+        d->provider->releaseService(d->service);
+    }
+}
+
+QAudioStreaming::State QAudioStreaming::state() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return QAudioStreaming::StoppedState;
+}
+
+QAudioStreaming::Status QAudioStreaming::status() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return QAudioStreaming::UnknownStatus;
+}
+
+QAudioStreaming::Error QAudioStreaming::error() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return QAudioStreaming::NoError;
+}
+
+QString QAudioStreaming::errorString() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return NULL;
+}
+
+void QAudioStreaming::talk()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->talk();
+}
+
+void QAudioStreaming::mute()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->mute();
+}
+
+void QAudioStreaming::stop()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->stop();
+}
+
+void QAudioStreaming::setType(QString type)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->setType(type);
+}
+
+void QAudioStreaming::setAsrcDevice(QString device)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->setAsrcDevice(device);
+}
+
+void QAudioStreaming::setAsinkSync(bool sync)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->setAsinkSync(sync);
+}
+
+void QAudioStreaming::setUsrcPort(int port)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->setUsrcPort(port);
+}
+
+void QAudioStreaming::setUsinkHost(QString host)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->setUsinkHost(host);
+}
+
+void QAudioStreaming::setUsinkPort(int port)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->setUsinkPort(port);
+}
+
+void QAudioStreaming::setUsinkSync(bool sync)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->setUsinkSync(sync);
+}
+
+void QAudioStreaming::setAudioPlugin(QString audioplugin)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->setAudioPlugin(audioplugin);
+}
+
+void QAudioStreaming::componentComplete()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QAudioStreaming);
+    d->control->componentComplete();
+}
+
+void QAudioStreaming::slot_StateStatusChanged(QAudioStreaming::State newstate, QAudioStreaming::Status newstatus)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    emit signal_StateStatusChanged(newstate, newstatus);
+}
+
+#include "moc_qaudiostreaming.cpp"
+QT_END_NAMESPACE
\ No newline at end of file
diff --git a/src/multimedia/audio/qaudiostreaming.h b/src/multimedia/audio/qaudiostreaming.h
new file mode 100755
index 0000000..72fe855
--- /dev/null
+++ b/src/multimedia/audio/qaudiostreaming.h
@@ -0,0 +1,92 @@
+#ifndef QAUDIOSTREAMING_H
+#define QAUDIOSTREAMING_H
+
+#include <QtMultimedia/qmediaobject.h>
+#include <QtMultimedia/qmediaenumdebug.h>
+
+QT_BEGIN_NAMESPACE
+class QAudioStreamingPrivate;
+class Q_MULTIMEDIA_EXPORT QAudioStreaming : public QMediaObject
+{
+    Q_OBJECT
+    Q_PROPERTY(State state READ state NOTIFY stateChanged)
+    Q_PROPERTY(Status status READ status NOTIFY statusChanged)
+    Q_PROPERTY(QString error READ errorString)
+    
+    Q_ENUMS(Status)
+    Q_ENUMS(State)
+    Q_ENUMS(Error)
+
+public:
+    enum Status
+    {
+        UnknownStatus,
+        NoMedia,
+        LoadingMedia,
+        LoadedMedia,
+        UnActive,
+        Active
+    };
+
+    enum State {
+        StoppedState,
+        TalkedState,
+        MutedState,
+        TalkedMutedState
+    };
+
+    enum Error
+    {
+        NoError,
+        ResourceError,
+        InputArgumentError
+    };
+    
+    QAudioStreaming(QObject *parent = 0);
+    ~QAudioStreaming();
+    
+    State state() const;
+    Status status() const;
+    Error error() const;
+    QString errorString() const;
+
+public Q_SLOTS:
+    void talk();
+    void mute();
+    void stop();
+    
+    void setType(QString type);
+    void setAudioPlugin(QString audioplugin);
+    void setAsrcDevice(QString device);
+    void setAsinkSync(bool sync);
+    void setUsrcPort(int port);
+    void setUsinkHost(QString host);
+    void setUsinkPort(int port);
+    void setUsinkSync(bool sync);
+    void componentComplete();
+    void slot_StateStatusChanged(QAudioStreaming::State, QAudioStreaming::Status);
+
+Q_SIGNALS:
+    void stateChanged(QAudioStreaming::State);
+    void statusChanged(QAudioStreaming::Status);
+    void signal_StateStatusChanged(QAudioStreaming::State, QAudioStreaming::Status);
+
+private:
+    Q_DISABLE_COPY(QAudioStreaming)
+    Q_DECLARE_PRIVATE(QAudioStreaming)
+    Q_PRIVATE_SLOT(d_func(), void _q_stateChanged(QAudioStreaming::State))
+    Q_PRIVATE_SLOT(d_func(), void _q_statusChanged(QAudioStreaming::Status))
+    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QAudioStreaming::State)
+Q_DECLARE_METATYPE(QAudioStreaming::Status)
+Q_DECLARE_METATYPE(QAudioStreaming::Error)
+
+Q_MEDIA_ENUM_DEBUG(QAudioStreaming, State)
+Q_MEDIA_ENUM_DEBUG(QAudioStreaming, Status)
+Q_MEDIA_ENUM_DEBUG(QAudioStreaming, Error)
+
+#endif  // QAUDIOSTREAMING_H
\ No newline at end of file
diff --git a/src/multimedia/controls/controls.pri b/src/multimedia/controls/controls.pri
index b19532f..bb01e77 100644
--- a/src/multimedia/controls/controls.pri
+++ b/src/multimedia/controls/controls.pri
@@ -3,6 +3,7 @@ INCLUDEPATH += controls
 
 PUBLIC_HEADERS += \
     controls/qaudiodecodercontrol.h \
+    controls/qaudiostreamingcontrol.h \
     controls/qaudioencodersettingscontrol.h \
     controls/qaudioinputselectorcontrol.h \
     controls/qaudiooutputselectorcontrol.h \
@@ -36,7 +37,10 @@ PUBLIC_HEADERS += \
     controls/qvideowindowcontrol.h \
     controls/qmediaaudioprobecontrol.h \
     controls/qmediavideoprobecontrol.h \
-    controls/qmediaavailabilitycontrol.h
+    controls/qmediaavailabilitycontrol.h \
+    controls/qH264Streamingcontrol.h \
+    controls/qMP4Playbackcontrol.h \
+    controls/qMP4Recordercontrol.h
 
 PRIVATE_HEADERS += \
     controls/qmediaplaylistcontrol_p.h \
@@ -75,9 +79,13 @@ SOURCES += \
     controls/qmediavideoprobecontrol.cpp \
     controls/qmediaavailabilitycontrol.cpp \
     controls/qaudiodecodercontrol.cpp \
+    controls/qaudiostreamingcontrol.cpp \
     controls/qvideoencodersettingscontrol.cpp \
     controls/qaudioencodersettingscontrol.cpp \
     controls/qaudioinputselectorcontrol.cpp \
     controls/qaudiooutputselectorcontrol.cpp \
-    controls/qvideodeviceselectorcontrol.cpp
+    controls/qvideodeviceselectorcontrol.cpp \
+    controls/qH264Streamingcontrol.cpp \
+    controls/qMP4Playbackcontrol.cpp \
+    controls/qMP4Recordercontrol.cpp
 
diff --git a/src/multimedia/controls/qH264Streamingcontrol.cpp b/src/multimedia/controls/qH264Streamingcontrol.cpp
new file mode 100755
index 0000000..fb7bcca
--- /dev/null
+++ b/src/multimedia/controls/qH264Streamingcontrol.cpp
@@ -0,0 +1,371 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qH264Streamingcontrol.h"
+#include "qmediacontrol_p.h"
+#include "qH264Streaming.h"
+
+QT_BEGIN_NAMESPACE
+
+
+/*!
+    \class QMediaPlayerControl
+    \inmodule QtMultimedia
+
+
+    \ingroup multimedia_control
+
+
+    \brief The QMediaPlayerControl class provides access to the media playing
+    functionality of a QMediaService.
+
+    If a QMediaService can play media is will implement QMediaPlayerControl.
+    This control provides a means to set the \l {setMedia()}{media} to play,
+    \l {play()}{start}, \l {pause()} {pause} and \l {stop()}{stop} playback,
+    \l {setPosition()}{seek}, and control the \l {setVolume()}{volume}.
+    It also provides feedback on the \l {duration()}{duration} of the media,
+    the current \l {position()}{position}, and \l {bufferStatus()}{buffering}
+    progress.
+
+    The functionality provided by this control is exposed to application
+    code through the QMediaPlayer class.
+
+    The interface name of QMediaPlayerControl is \c org.qt-project.qt.mediaplayercontrol/5.0 as
+    defined in QMediaPlayerControl_iid.
+
+    \sa QMediaService::requestControl(), QMediaPlayer
+*/
+
+/*!
+    \macro QMediaPlayerControl_iid
+
+    \c org.qt-project.qt.mediaplayercontrol/5.0
+
+    Defines the interface name of the QMediaPlayerControl class.
+
+    \relates QMediaPlayerControl
+*/
+
+/*!
+    Destroys a media player control.
+*/
+QH264StreamingControl::~QH264StreamingControl()
+{
+}
+
+/*!
+    Constructs a new media player control with the given \a parent.
+*/
+QH264StreamingControl::QH264StreamingControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+/*!
+    \fn QMediaPlayerControl::state() const
+
+    Returns the state of a player control.
+*/
+
+/*!
+    \fn QMediaPlayerControl::stateChanged(QMediaPlayer::State state)
+
+    Signals that the \a state of a player control has changed.
+
+    \sa state()
+*/
+
+/*!
+    \fn QMediaPlayerControl::mediaStatus() const
+
+    Returns the status of the current media.
+*/
+
+/*!
+    \fn QMediaPlayerControl::mediaStatusChanged(QMediaPlayer::MediaStatus status)
+
+    Signals that the \a status of the current media has changed.
+
+    \sa mediaStatus()
+*/
+
+
+/*!
+    \fn QMediaPlayerControl::duration() const
+
+    Returns the duration of the current media in milliseconds.
+*/
+
+/*!
+    \fn QMediaPlayerControl::durationChanged(qint64 duration)
+
+    Signals that the \a duration of the current media has changed.
+
+    \sa duration()
+*/
+
+/*!
+    \fn QMediaPlayerControl::position() const
+
+    Returns the current playback position in milliseconds.
+*/
+
+/*!
+    \fn QMediaPlayerControl::setPosition(qint64 position)
+
+    Sets the playback \a position of the current media.  This will initiate a seek and it may take
+    some time for playback to reach the position set.
+*/
+
+/*!
+    \fn QMediaPlayerControl::positionChanged(qint64 position)
+
+    Signals the playback \a position has changed.
+
+    This is only emitted in when there has been a discontinous change in the playback postion, such
+    as a seek or the position being reset.
+
+    \sa position()
+*/
+
+/*!
+    \fn QMediaPlayerControl::volume() const
+
+    Returns the audio volume of a player control.
+*/
+
+/*!
+    \fn QMediaPlayerControl::setVolume(int volume)
+
+    Sets the audio \a volume of a player control.
+*/
+
+/*!
+    \fn QMediaPlayerControl::volumeChanged(int volume)
+
+    Signals the audio \a volume of a player control has changed.
+
+    \sa volume()
+*/
+
+/*!
+    \fn QMediaPlayerControl::isMuted() const
+
+    Returns the mute state of a player control.
+*/
+
+/*!
+    \fn QMediaPlayerControl::setMuted(bool mute)
+
+    Sets the \a mute state of a player control.
+*/
+
+/*!
+    \fn QMediaPlayerControl::mutedChanged(bool mute)
+
+    Signals a change in the \a mute status of a player control.
+
+    \sa isMuted()
+*/
+
+/*!
+    \fn QMediaPlayerControl::bufferStatus() const
+
+    Returns the buffering progress of the current media.  Progress is measured in the percentage
+    of the buffer filled.
+*/
+
+/*!
+    \fn QMediaPlayerControl::bufferStatusChanged(int progress)
+
+    Signals that buffering \a progress has changed.
+
+    \sa bufferStatus()
+*/
+
+/*!
+    \fn QMediaPlayerControl::isAudioAvailable() const
+
+    Identifies if there is audio output available for the current media.
+
+    Returns true if audio output is available and false otherwise.
+*/
+
+/*!
+    \fn QMediaPlayerControl::audioAvailableChanged(bool audio)
+
+    Signals that there has been a change in the availability of \a audio output.
+
+    \sa isAudioAvailable()
+*/
+
+/*!
+    \fn QMediaPlayerControl::isVideoAvailable() const
+
+    Identifies if there is video output available for the current media.
+
+    Returns true if video output is available and false otherwise.
+*/
+
+/*!
+    \fn QMediaPlayerControl::videoAvailableChanged(bool video)
+
+    Signals that there has been a change in the availability of \a video output.
+
+    \sa isVideoAvailable()
+*/
+
+/*!
+    \fn QMediaPlayerControl::isSeekable() const
+
+    Identifies if the current media is seekable.
+
+    Returns true if it possible to seek within the current media, and false otherwise.
+*/
+
+/*!
+    \fn QMediaPlayerControl::seekableChanged(bool seekable)
+
+    Signals that the \a seekable state of a player control has changed.
+
+    \sa isSeekable()
+*/
+
+/*!
+    \fn QMediaPlayerControl::availablePlaybackRanges() const
+
+    Returns a range of times in milliseconds that can be played back.
+
+    Usually for local files this is a continuous interval equal to [0..duration()]
+    or an empty time range if seeking is not supported, but for network sources
+    it refers to the buffered parts of the media.
+*/
+
+/*!
+    \fn QMediaPlayerControl::availablePlaybackRangesChanged(const QMediaTimeRange &ranges)
+
+    Signals that the available media playback \a ranges have changed.
+
+    \sa QMediaPlayerControl::availablePlaybackRanges()
+*/
+
+/*!
+    \fn qreal QMediaPlayerControl::playbackRate() const
+
+    Returns the rate of playback.
+*/
+
+/*!
+    \fn QMediaPlayerControl::setPlaybackRate(qreal rate)
+
+    Sets the \a rate of playback.
+*/
+
+/*!
+    \fn QMediaPlayerControl::media() const
+
+    Returns the current media source.
+*/
+
+/*!
+    \fn QMediaPlayerControl::mediaStream() const
+
+    Returns the current media stream. This is only a valid if a stream was passed to setMedia().
+
+    \sa setMedia()
+*/
+
+/*!
+    \fn QMediaPlayerControl::setMedia(const QMediaContent &media, QIODevice *stream)
+
+    Sets the current \a media source.  If a \a stream is supplied; data will be read from that
+    instead of attempting to resolve the media source.  The media source may still be used to
+    supply media information such as mime type.
+
+    Setting the media to a null QMediaContent will cause the control to discard all
+    information relating to the current media source and to cease all I/O operations related
+    to that media.
+*/
+
+/*!
+    \fn QMediaPlayerControl::mediaChanged(const QMediaContent& content)
+
+    Signals that the current media \a content has changed.
+*/
+
+/*!
+    \fn QMediaPlayerControl::play()
+
+    Starts playback of the current media.
+
+    If successful the player control will immediately enter the \l {QMediaPlayer::PlayingState}
+    {playing} state.
+
+    \sa state()
+*/
+
+/*!
+    \fn QMediaPlayerControl::pause()
+
+    Pauses playback of the current media.
+
+    If sucessful the player control will immediately enter the \l {QMediaPlayer::PausedState}
+    {paused} state.
+
+    \sa state(), play(), stop()
+*/
+
+/*!
+    \fn QMediaPlayerControl::stop()
+
+    Stops playback of the current media.
+
+    If successful the player control will immediately enter the \l {QMediaPlayer::StoppedState}
+    {stopped} state.
+*/
+
+/*!
+    \fn QMediaPlayerControl::error(int error, const QString &errorString)
+
+    Signals that an \a error has occurred.  The \a errorString provides a more detailed explanation.
+*/
+
+/*!
+    \fn QMediaPlayerControl::playbackRateChanged(qreal rate)
+
+    Signal emitted when playback rate changes to \a rate.
+*/
+
+#include "moc_qH264Streamingcontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qH264Streamingcontrol.h b/src/multimedia/controls/qH264Streamingcontrol.h
new file mode 100755
index 0000000..da829fb
--- /dev/null
+++ b/src/multimedia/controls/qH264Streamingcontrol.h
@@ -0,0 +1,141 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QH264STREAMINGCONTROL_H
+#define QH264STREAMINGCONTROL_H
+
+#include <QtMultimedia/qmediacontrol.h>
+#include <QtMultimedia/qH264Streaming.h>
+#include <QtMultimedia/qmediatimerange.h>
+
+#include <QtCore/qpair.h>
+
+QT_BEGIN_NAMESPACE
+
+
+class QMediaPlaylist;
+
+class Q_MULTIMEDIA_EXPORT QH264StreamingControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QH264StreamingControl();
+
+    virtual QH264Streaming::State state() const = 0;
+
+    virtual QH264Streaming::MediaStatus mediaStatus() const = 0;
+
+    virtual qint64 duration() const = 0;
+
+    virtual qint64 position() const = 0;
+    virtual void setPosition(qint64 position) = 0;
+
+    virtual int volume() const = 0;
+    virtual void setVolume(int volume) = 0;
+
+    virtual bool isMuted() const = 0;
+    virtual void setMuted(bool muted) = 0;
+
+    virtual int bufferStatus() const = 0;
+
+    virtual bool isAudioAvailable() const = 0;
+    virtual bool isVideoAvailable() const = 0;
+
+    virtual bool isSeekable() const = 0;
+
+    virtual QMediaTimeRange availablePlaybackRanges() const = 0;
+
+    virtual qreal playbackRate() const = 0;
+    virtual void setPlaybackRate(qreal rate) = 0;
+
+    virtual QMediaContent media() const = 0;
+    virtual const QIODevice *mediaStream() const = 0;
+    virtual void setMedia(const QMediaContent &media, QIODevice *stream) = 0;
+
+    virtual void play() = 0;
+    virtual void pause() = 0;
+    virtual void stop() = 0;
+    
+    virtual void setHdmiWidth(int hdmiwidth) = 0;
+    virtual void setHdmiHeight(int hdmiheight) = 0;
+    virtual void setHdmiFormat(QString hdmiformat) = 0;
+    virtual void setNumPframes(int numpframes) = 0;
+    virtual void setEncBitrate (int encbitrate) = 0;
+    virtual void setNoReorder (bool noreorder) = 0;
+    virtual void setTransmit (bool transmit) = 0;
+    virtual void setUdpPort (QString udpport) = 0;
+    virtual void setUdpHost (QString udphost) = 0;
+    virtual void setVspm(bool vspm) = 0;
+    virtual void setVspmDmabuf(bool vspmdmabuf) = 0;
+    virtual void setVspmWidth(int vspmwidth) = 0;
+    virtual void setVspmWidth1(int vspmwidth1) = 0;
+    virtual void setVspmHeight(int vspmheight) = 0;
+    virtual void setVspmHeight1(int vspmheight1) = 0;
+    virtual void setVspmFormat(QString vspmformat) = 0;
+    virtual void setWlsMaxLateness(int wlsmaxlateness) = 0;
+    virtual void setWlsQos(bool wlsqos) = 0;
+    virtual void setWlsPositionX(int wlspositionx) = 0;
+    virtual void setWlsPositionY(int wlspositiony) = 0;
+    virtual void setWlsOutWidth(int wlsoutwidth) = 0;
+    virtual void setWlsOutHeight(int wlsoutheight) = 0;
+    virtual void componentComplete() = 0;
+
+Q_SIGNALS:
+    void mediaChanged(const QMediaContent& content);
+    void durationChanged(qint64 duration);
+    void positionChanged(qint64 position);
+    void stateChanged(QH264Streaming::State newState);
+    void mediaStatusChanged(QH264Streaming::MediaStatus status);
+    void volumeChanged(int volume);
+    void mutedChanged(bool muted);
+    void audioAvailableChanged(bool audioAvailable);
+    void videoAvailableChanged(bool videoAvailable);
+    void bufferStatusChanged(int percentFilled);
+    void seekableChanged(bool);
+    void availablePlaybackRangesChanged(const QMediaTimeRange&);
+    void playbackRateChanged(qreal rate);
+    void error(int error, const QString &errorString);
+
+protected:
+    QH264StreamingControl(QObject* parent = 0);
+};
+
+#define QH264StreamingControl_iid "org.qt-project.qt.H264Streamingcontrol/5.0"
+Q_MEDIA_DECLARE_CONTROL(QH264StreamingControl, QH264StreamingControl_iid)
+
+QT_END_NAMESPACE
+
+
+#endif  // QMEDIAPLAYERCONTROL_H
+
diff --git a/src/multimedia/controls/qMP4Playbackcontrol.cpp b/src/multimedia/controls/qMP4Playbackcontrol.cpp
new file mode 100755
index 0000000..4570cea
--- /dev/null
+++ b/src/multimedia/controls/qMP4Playbackcontrol.cpp
@@ -0,0 +1 @@
+#include "qmediacontrol_p.h"#include "qMP4Playbackcontrol.h"QT_BEGIN_NAMESPACEQMP4PlaybackControl::~QMP4PlaybackControl(){}QMP4PlaybackControl::QMP4PlaybackControl(QObject *parent):    QMediaControl(*new QMediaControlPrivate, parent){}#include "moc_qMP4Playbackcontrol.cpp"QT_END_NAMESPACE
\ No newline at end of file
diff --git a/src/multimedia/controls/qMP4Playbackcontrol.h b/src/multimedia/controls/qMP4Playbackcontrol.h
new file mode 100755
index 0000000..02c3b60
--- /dev/null
+++ b/src/multimedia/controls/qMP4Playbackcontrol.h
@@ -0,0 +1 @@
+#ifndef QMP4PLAYBACKCONTROL_H#define QMP4PLAYBACKCONTROL_H#include <QtMultimedia/qmediacontrol.h>#include <QtMultimedia/qMP4Playback.h>#include <QtCore/qpair.h>QT_BEGIN_NAMESPACEclass Q_MULTIMEDIA_EXPORT QMP4PlaybackControl : public QMediaControl{    Q_OBJECTpublic:    ~QMP4PlaybackControl();        virtual void play() = 0;    virtual void stop() = 0;    virtual void pause() = 0;    virtual void setSource(QString source) = 0;    virtual void componentComplete() = 0;    Q_SIGNALS:    void statestatusChanged(QMP4Playback::State, QMP4Playback::Status);    protected:    QMP4PlaybackControl(QObject* parent = 0);};#define QMP4PlaybackControl_iid "org.qt-project.qt.mp4playbackcontrol/5.0"Q_MEDIA_DECLARE_CONTROL(QMP4PlaybackControl, QMP4PlaybackControl_iid)QT_END_NAMESPACE#endif // QMP4PLAYBACKCONTROL_H
\ No newline at end of file
diff --git a/src/multimedia/controls/qMP4Recordercontrol.cpp b/src/multimedia/controls/qMP4Recordercontrol.cpp
new file mode 100755
index 0000000..16e8f43
--- /dev/null
+++ b/src/multimedia/controls/qMP4Recordercontrol.cpp
@@ -0,0 +1,54 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qMP4Recordercontrol.h"
+#include "qmediacontrol_p.h"
+#include "qMP4Recorder.h"
+
+QT_BEGIN_NAMESPACE
+
+QMP4RecorderControl::~QMP4RecorderControl()
+{
+}
+
+/*!
+    Constructs a new media player control with the given \a parent.
+*/
+QMP4RecorderControl::QMP4RecorderControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+#include "moc_qMP4Recordercontrol.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/controls/qMP4Recordercontrol.h b/src/multimedia/controls/qMP4Recordercontrol.h
new file mode 100755
index 0000000..04df6eb
--- /dev/null
+++ b/src/multimedia/controls/qMP4Recordercontrol.h
@@ -0,0 +1,93 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMP4RECORDERCONTROL_H
+#define QMP4RECORDERCONTROL_H
+
+#include <QtMultimedia/qmediacontrol.h>
+#include <QtMultimedia/qMP4Recorder.h>
+#include <QtMultimedia/qmediatimerange.h>
+
+#include <QtCore/qpair.h>
+
+QT_BEGIN_NAMESPACE
+
+
+class QMediaPlaylist;
+
+class Q_MULTIMEDIA_EXPORT QMP4RecorderControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QMP4RecorderControl();
+
+    virtual QMP4Recorder::State state() const = 0;
+
+    virtual QMP4Recorder::MediaStatus mediaStatus() const = 0;
+
+    virtual void setUsrcPort(int) = 0;
+    virtual void setFSinkLocation(QString) = 0;
+    virtual void componentComplete() = 0;
+    virtual void start() = 0;
+    virtual void stop() = 0;
+    virtual void pause() = 0;
+
+Q_SIGNALS:
+    // void mediaChanged(const QMediaContent& content);
+    void durationChanged(qint64 duration);
+    void positionChanged(qint64 position);
+    void stateChanged(QMP4Recorder::State newState);
+    void mediaStatusChanged(QMP4Recorder::MediaStatus status);
+    void volumeChanged(int volume);
+    void mutedChanged(bool muted);
+    void audioAvailableChanged(bool audioAvailable);
+    void videoAvailableChanged(bool videoAvailable);
+    void bufferStatusChanged(int percentFilled);
+    void seekableChanged(bool);
+    void availablePlaybackRangesChanged(const QMediaTimeRange&);
+    void playbackRateChanged(qreal rate);
+    void error(int error, const QString &errorString);
+
+protected:
+    QMP4RecorderControl(QObject* parent = 0);
+};
+
+#define QMP4RecorderControl_iid "org.qt-project.qt.mp4recordercontrol/5.0"
+Q_MEDIA_DECLARE_CONTROL(QMP4RecorderControl, QMP4RecorderControl_iid)
+
+QT_END_NAMESPACE
+
+
+#endif  // QMEDIAPLAYERCONTROL_H
+
diff --git a/src/multimedia/controls/qaudiostreamingcontrol.cpp b/src/multimedia/controls/qaudiostreamingcontrol.cpp
new file mode 100755
index 0000000..2d63ded
--- /dev/null
+++ b/src/multimedia/controls/qaudiostreamingcontrol.cpp
@@ -0,0 +1,17 @@
+#include "qmediacontrol_p.h"
+#include "qaudiostreamingcontrol.h"
+
+QT_BEGIN_NAMESPACE
+
+QAudioStreamingControl::~QAudioStreamingControl()
+{
+}
+
+QAudioStreamingControl::QAudioStreamingControl(QObject *parent):
+    QMediaControl(*new QMediaControlPrivate, parent)
+{
+}
+
+
+#include "moc_qaudiostreamingcontrol.cpp"
+QT_END_NAMESPACE
\ No newline at end of file
diff --git a/src/multimedia/controls/qaudiostreamingcontrol.h b/src/multimedia/controls/qaudiostreamingcontrol.h
new file mode 100755
index 0000000..a5c4bc7
--- /dev/null
+++ b/src/multimedia/controls/qaudiostreamingcontrol.h
@@ -0,0 +1,48 @@
+#ifndef QAUDIOSTREAMINGCONTROL_H
+#define QAUDIOSTREAMINGCONTROL_H
+
+#include <QtMultimedia/qmediacontrol.h>
+#include <QtMultimedia/qaudiostreaming.h>
+#include <QtCore/qpair.h>
+
+QT_BEGIN_NAMESPACE
+
+class Q_MULTIMEDIA_EXPORT QAudioStreamingControl : public QMediaControl
+{
+    Q_OBJECT
+
+public:
+    ~QAudioStreamingControl();
+    
+    virtual QAudioStreaming::State state() const = 0;
+    virtual QAudioStreaming::Status status() const = 0;
+    
+    virtual void talk() = 0;
+    virtual void mute() = 0;
+    virtual void stop() = 0;
+    
+    virtual void setType(QString type) = 0;
+    virtual void setAudioPlugin(QString audioplugin) = 0;
+    virtual void setAsrcDevice(QString device) = 0;
+    virtual void setAsinkSync(bool sync) = 0;
+    virtual void setUsrcPort(int port) = 0;
+    virtual void setUsinkHost(QString host) = 0;
+    virtual void setUsinkPort(int port) = 0;
+    virtual void setUsinkSync(bool sync) = 0;
+    virtual void componentComplete() = 0;
+    
+Q_SIGNALS:
+    void stateChanged(QAudioStreaming::State newState);
+    void statusChanged(QAudioStreaming::Status status);
+    void error(int error, const QString &errorString);
+    void statestatusChanged(QAudioStreaming::State, QAudioStreaming::Status);
+
+protected:
+    QAudioStreamingControl(QObject* parent = 0);
+};
+
+#define QAudioStreamingControl_iid "org.qt-project.qt.audiostreamingcontrol/5.0"
+Q_MEDIA_DECLARE_CONTROL(QAudioStreamingControl, QAudioStreamingControl_iid)
+
+QT_END_NAMESPACE
+#endif // QAUDIOSTREAMINGCONTROL_H
\ No newline at end of file
diff --git a/src/multimedia/playback/playback.pri b/src/multimedia/playback/playback.pri
index 3bbb8ce..790cf9e 100644
--- a/src/multimedia/playback/playback.pri
+++ b/src/multimedia/playback/playback.pri
@@ -4,7 +4,9 @@ PUBLIC_HEADERS += \
     playback/qmediacontent.h \
     playback/qmediaplayer.h \
     playback/qmediaplaylist.h \
-    playback/qmediaresource.h
+    playback/qmediaresource.h \
+    playback/qH264Streaming.h \
+    playback/qMP4Playback.h
 
 PRIVATE_HEADERS += \
     playback/qmediaplaylist_p.h \
@@ -23,4 +25,6 @@ SOURCES += \
     playback/qmediaplaylistnavigator.cpp \
     playback/qmediaplaylistprovider.cpp \
     playback/qmediaresource.cpp \
-    playback/playlistfileparser.cpp
+    playback/playlistfileparser.cpp \
+    playback/qH264Streaming.cpp \
+    playback/qMP4Playback.cpp
diff --git a/src/multimedia/playback/qH264Streaming.cpp b/src/multimedia/playback/qH264Streaming.cpp
new file mode 100755
index 0000000..8a2b448
--- /dev/null
+++ b/src/multimedia/playback/qH264Streaming.cpp
@@ -0,0 +1,1496 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qH264Streaming.h"
+#include "qvideosurfaceoutput_p.h"
+
+
+#include "qmediaobject_p.h"
+#include <qmediaservice.h>
+#include <qH264Streamingcontrol.h>
+#include <qmediaserviceprovider_p.h>
+#include <qmediaplaylist.h>
+#include <qmediaplaylistcontrol_p.h>
+#include <qmediaplaylistsourcecontrol_p.h>
+#include <qmedianetworkaccesscontrol.h>
+
+#include <QtCore/qcoreevent.h>
+#include <QtCore/qmetaobject.h>
+#include <QtCore/qtimer.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/qpointer.h>
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \class QMediaPlayer
+    \brief The QMediaPlayer class allows the playing of a media source.
+    \inmodule QtMultimedia
+    \ingroup multimedia
+    \ingroup multimedia_playback
+
+    The QMediaPlayer class is a high level media playback class. It can be used
+    to playback such content as songs, movies and internet radio. The content
+    to playback is specified as a QMediaContent object, which can be thought of as a
+    main or canonical URL with additional information attached. When provided
+    with a QMediaContent playback may be able to commence.
+
+    \snippet multimedia-snippets/media.cpp Player
+
+    QVideoWidget can be used with QMediaPlayer for video rendering and QMediaPlaylist
+    for accessing playlist functionality.
+
+    \snippet multimedia-snippets/media.cpp Movie playlist
+
+    Since QMediaPlayer is a QMediaObject, you can use several of the QMediaObject
+    functions for things like:
+
+    \list
+    \li Accessing the currently playing media's metadata (\l {QMediaObject::metaData()} and \l {QMediaMetaData}{predefined meta-data keys})
+    \li Checking to see if the media playback service is currently available (\l {QMediaObject::availability()})
+    \endlist
+
+    \sa QMediaObject, QMediaService, QVideoWidget, QMediaPlaylist
+*/
+
+static void qRegisterMediaPlayerMetaTypes()
+{
+    qRegisterMetaType<QH264Streaming::State>("QH264Streaming::State");
+    qRegisterMetaType<QH264Streaming::MediaStatus>("QH264Streaming::MediaStatus");
+    qRegisterMetaType<QH264Streaming::Error>("QH264Streaming::Error");
+}
+
+Q_CONSTRUCTOR_FUNCTION(qRegisterMediaPlayerMetaTypes)
+
+
+
+#define MAX_NESTED_PLAYLISTS 16
+
+class QH264StreamingPrivate : public QMediaObjectPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QH264Streaming)
+
+public:
+    QH264StreamingPrivate()
+        : provider(0)
+        , control(0)
+        , state(QH264Streaming::StoppedState)
+        , error(QH264Streaming::NoError)
+        , playlist(0)
+        , networkAccessControl(0)
+        , nestedPlaylists(0)
+    {}
+
+    QMediaServiceProvider *provider;
+    QH264StreamingControl* control;
+    QH264Streaming::State state;
+    QH264Streaming::Error error;
+    QString errorString;
+
+    QPointer<QObject> videoOutput;
+    QMediaPlaylist *playlist;
+    QMediaNetworkAccessControl *networkAccessControl;
+    QVideoSurfaceOutput surfaceOutput;
+
+    QMediaContent rootMedia;
+    QMediaContent pendingPlaylist;
+    QMediaPlaylist *parentPlaylist(QMediaPlaylist *pls);
+    bool isInChain(QUrl url);
+    int nestedPlaylists;
+
+    void setPlaylist(QMediaPlaylist *playlist);
+    void setPlaylistMedia();
+    void loadPlaylist();
+    void disconnectPlaylist();
+    void connectPlaylist();
+
+    void _q_stateChanged(QH264Streaming::State state);
+    void _q_mediaStatusChanged(QH264Streaming::MediaStatus status);
+    void _q_error(int error, const QString &errorString);
+    void _q_updateMedia(const QMediaContent&);
+    void _q_playlistDestroyed();
+    void _q_handlePlaylistLoaded();
+    void _q_handlePlaylistLoadFailed();
+};
+
+QMediaPlaylist *QH264StreamingPrivate::parentPlaylist(QMediaPlaylist *pls)
+{
+    // This function finds a parent playlist for an item in the active chain of playlists.
+    // Every item in the chain comes from currentMedia() of its parent.
+    // We don't need to travers the whole tree of playlists,
+    // but only the subtree of active ones.
+    for (QMediaPlaylist *current = rootMedia.playlist(); current && current != pls; current = current->currentMedia().playlist())
+        if (current->currentMedia().playlist() == pls)
+            return current;
+    return 0;
+}
+
+bool QH264StreamingPrivate::isInChain(QUrl url)
+{
+    // Check whether a URL is already in the chain of playlists.
+    // Also see a comment in parentPlaylist().
+    for (QMediaPlaylist *current = rootMedia.playlist(); current && current != playlist; current = current->currentMedia().playlist())
+        if (current->currentMedia().canonicalUrl() == url) {
+            return true;
+        }
+    return false;
+}
+
+void QH264StreamingPrivate::_q_stateChanged(QH264Streaming::State ps)
+{
+    Q_Q(QH264Streaming);
+
+    // Backend switches into stopped state every time new media is about to be loaded.
+    // If media player has a playlist loaded make sure player doesn' stop.
+    if (playlist && playlist->currentIndex() != -1 && ps != state && ps == QH264Streaming::StoppedState) {
+        if (control->mediaStatus() == QH264Streaming::EndOfMedia ||
+                control->mediaStatus() == QH264Streaming::InvalidMedia) {
+            // if media player is not stopped, and
+            // we have finished playback for the current media,
+            // advance to the next item in the playlist
+            Q_ASSERT(state != QH264Streaming::StoppedState);
+            playlist->next();
+            return;
+        } else if (control->mediaStatus() == QH264Streaming::LoadingMedia) {
+            return;
+        }
+    }
+
+    if (ps != state) {
+        state = ps;
+
+        if (ps == QH264Streaming::PlayingState)
+            q->addPropertyWatch("position");
+        else
+            q->removePropertyWatch("position");
+
+        emit q->stateChanged(ps);
+    }
+}
+
+void QH264StreamingPrivate::_q_mediaStatusChanged(QH264Streaming::MediaStatus status)
+{
+    Q_Q(QH264Streaming);
+
+    switch (status) {
+    case QH264Streaming::StalledMedia:
+    case QH264Streaming::BufferingMedia:
+        q->addPropertyWatch("bufferStatus");
+        emit q->mediaStatusChanged(status);
+        break;
+    default:
+        q->removePropertyWatch("bufferStatus");
+        emit q->mediaStatusChanged(status);
+        break;
+    }
+
+}
+
+void QH264StreamingPrivate::_q_error(int error, const QString &errorString)
+{
+    Q_Q(QH264Streaming);
+
+    if (error == int(QH264Streaming::MediaIsPlaylist)) {
+        loadPlaylist();
+    } else {
+        this->error = QH264Streaming::Error(error);
+        this->errorString = errorString;
+        emit q->error(this->error);
+
+        if (playlist)
+            playlist->next();
+    }
+}
+
+void QH264StreamingPrivate::_q_updateMedia(const QMediaContent &media)
+{
+    Q_Q(QH264Streaming);
+
+    if (!control)
+        return;
+
+    // check if the current playlist is a top-level playlist
+    Q_ASSERT(playlist);
+    if (media.isNull() && playlist != rootMedia.playlist()) {
+        // switch back to parent playlist
+        QMediaPlaylist *pls = parentPlaylist(playlist);
+        Q_ASSERT(pls);
+        disconnectPlaylist();
+        playlist = pls;
+        connectPlaylist();
+
+        Q_ASSERT(!pendingPlaylist.playlist());
+        nestedPlaylists--;
+        Q_ASSERT(nestedPlaylists >= 0);
+
+        playlist->next();
+        return;
+    }
+
+    if (media.playlist()) {
+        if (nestedPlaylists < MAX_NESTED_PLAYLISTS) {
+            nestedPlaylists++;
+            Q_ASSERT(!pendingPlaylist.playlist());
+
+            // disconnect current playlist
+            disconnectPlaylist();
+            // new playlist signals are connected
+            // in the call to setPlaylist() in _q_handlePlaylistLoaded()
+            playlist = media.playlist();
+            emit q->currentMediaChanged(media);
+            _q_handlePlaylistLoaded();
+            return;
+        } else if (playlist) {
+            playlist->next();
+        }
+        return;
+    }
+
+    const QH264Streaming::State currentState = state;
+
+    control->setMedia(media, 0);
+
+    if (!media.isNull()) {
+        switch (currentState) {
+        case QH264Streaming::PlayingState:
+            control->play();
+            break;
+        case QH264Streaming::PausedState:
+            control->pause();
+            break;
+        default:
+            break;
+        }
+    }
+
+    _q_stateChanged(control->state());
+}
+
+void QH264StreamingPrivate::_q_playlistDestroyed()
+{
+    playlist = 0;
+
+    if (!control)
+        return;
+
+    control->setMedia(QMediaContent(), 0);
+}
+
+void QH264StreamingPrivate::setPlaylist(QMediaPlaylist *pls)
+{
+    disconnectPlaylist();
+    playlist = pls;
+
+    setPlaylistMedia();
+}
+
+void QH264StreamingPrivate::setPlaylistMedia()
+{
+    // This function loads current playlist media into backend.
+    // If current media is a playlist, the function recursively
+    // loads media from the playlist.
+    // It also makes sure the correct playlist signals are connected.
+    Q_Q(QH264Streaming);
+
+    if (playlist) {
+        connectPlaylist();
+        if (playlist->currentMedia().playlist()) {
+            if (nestedPlaylists < MAX_NESTED_PLAYLISTS) {
+                emit q->currentMediaChanged(playlist->currentMedia());
+                // rewind nested playlist to start
+                playlist->currentMedia().playlist()->setCurrentIndex(0);
+                nestedPlaylists++;
+                setPlaylist(playlist->currentMedia().playlist());
+            } else {
+                playlist->next();
+            }
+            return;
+        } else if (control != 0) {
+            // If we've just switched to a new playlist,
+            // then last emited currentMediaChanged was a playlist.
+            // Make sure we emit currentMediaChanged if new playlist has
+            // the same media as the previous one:
+            // sample.m3u
+            //      test.wav     -- processed by backend
+            //      nested.m3u   -- processed by frontend
+            //          test.wav -- processed by backend,
+            //                      media is not changed,
+            //                      frontend needs to emit currentMediaChanged
+            bool isSameMedia = (control->media() == playlist->currentMedia());
+            control->setMedia(playlist->currentMedia(), 0);
+            if (isSameMedia) {
+                emit q->currentMediaChanged(control->media());
+            }
+        }
+    } else {
+        q->setMedia(QMediaContent(), 0);
+    }
+}
+
+void QH264StreamingPrivate::loadPlaylist()
+{
+    Q_Q(QH264Streaming);
+    Q_ASSERT(pendingPlaylist.isNull());
+
+    // Do not load a playlist if there are more than MAX_NESTED_PLAYLISTS in the chain already,
+    // or if the playlist URL is already in the chain, i.e. do not allow recursive playlists and loops.
+    if (nestedPlaylists < MAX_NESTED_PLAYLISTS && !q->currentMedia().canonicalUrl().isEmpty() && !isInChain(q->currentMedia().canonicalUrl())) {
+        pendingPlaylist = QMediaContent(new QMediaPlaylist, q->currentMedia().canonicalUrl(), true);
+        QObject::connect(pendingPlaylist.playlist(), SIGNAL(loaded()), q, SLOT(_q_handlePlaylistLoaded()));
+        QObject::connect(pendingPlaylist.playlist(), SIGNAL(loadFailed()), q, SLOT(_q_handlePlaylistLoadFailed()));
+        pendingPlaylist.playlist()->load(pendingPlaylist.canonicalRequest());
+    } else if (playlist) {
+        playlist->next();
+    }
+}
+
+void QH264StreamingPrivate::disconnectPlaylist()
+{
+    Q_Q(QH264Streaming);
+    if (playlist) {
+        QObject::disconnect(playlist, SIGNAL(currentMediaChanged(QMediaContent)),
+                            q, SLOT(_q_updateMedia(QMediaContent)));
+        QObject::disconnect(playlist, SIGNAL(destroyed()), q, SLOT(_q_playlistDestroyed()));
+    }
+}
+
+void QH264StreamingPrivate::connectPlaylist()
+{
+    Q_Q(QH264Streaming);
+    if (playlist) {
+        QObject::connect(playlist, SIGNAL(currentMediaChanged(QMediaContent)),
+                         q, SLOT(_q_updateMedia(QMediaContent)));
+        QObject::connect(playlist, SIGNAL(destroyed()), q, SLOT(_q_playlistDestroyed()));
+    }
+}
+
+void QH264StreamingPrivate::_q_handlePlaylistLoaded()
+{
+    Q_Q(QH264Streaming);
+
+    if (pendingPlaylist.playlist()) {
+        Q_ASSERT(!q->currentMedia().playlist());
+        // if there is an active playlist
+        if (playlist) {
+            Q_ASSERT(playlist->currentIndex() >= 0);
+            disconnectPlaylist();
+            playlist->insertMedia(playlist->currentIndex() + 1, pendingPlaylist);
+            playlist->removeMedia(playlist->currentIndex());
+            nestedPlaylists++;
+        } else {
+            Q_ASSERT(!rootMedia.playlist());
+            rootMedia = pendingPlaylist;
+            emit q->mediaChanged(rootMedia);
+        }
+
+        playlist = pendingPlaylist.playlist();
+        emit q->currentMediaChanged(pendingPlaylist);
+    }
+    pendingPlaylist = QMediaContent();
+
+    playlist->next();
+    setPlaylistMedia();
+
+    switch (state) {
+    case QH264Streaming::PausedState:
+        control->pause();
+        break;
+    case QH264Streaming::PlayingState:
+        control->play();
+        break;
+    case QH264Streaming::StoppedState:
+        break;
+    }
+}
+
+void QH264StreamingPrivate::_q_handlePlaylistLoadFailed()
+{
+    pendingPlaylist = QMediaContent();
+
+    if (!control)
+        return;
+
+    if (playlist)
+        playlist->next();
+    else
+        control->setMedia(QMediaContent(), 0);
+}
+
+static QMediaService *playerService(QH264Streaming::Flags flags)
+{
+    QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider();
+    if (flags) {
+        QMediaServiceProviderHint::Features features = 0;
+        if (flags & QH264Streaming::LowLatency)
+            features |= QMediaServiceProviderHint::LowLatencyPlayback;
+
+        if (flags & QH264Streaming::StreamPlayback)
+            features |= QMediaServiceProviderHint::StreamPlayback;
+
+        if (flags & QH264Streaming::VideoSurface)
+            features |= QMediaServiceProviderHint::VideoSurface;
+        
+        if(flags & QH264Streaming::H264Streaming)
+            return provider->requestService(Q_MEDIASERVICE_H264STREAMING);
+
+        return provider->requestService(Q_MEDIASERVICE_MEDIAPLAYER,
+                                        QMediaServiceProviderHint(features));
+    } else
+        return provider->requestService(Q_MEDIASERVICE_MEDIAPLAYER);
+}
+
+void QH264Streaming::setHdmiWidth(int hdmiwidth)
+{
+    Q_D(QH264Streaming);
+    d->control->setHdmiWidth(hdmiwidth);
+}
+
+void QH264Streaming::setHdmiHeight(int hdmiheight)
+{
+    Q_D(QH264Streaming);
+    d->control->setHdmiHeight(hdmiheight);
+}
+
+void QH264Streaming::setHdmiFormat(QString hdmiformat)
+{
+    Q_D(QH264Streaming);
+    d->control->setHdmiFormat(hdmiformat);
+}
+
+void QH264Streaming::setEncBitrate(int encbitrate)
+{
+    Q_D(QH264Streaming);
+    d->control->setEncBitrate(encbitrate);
+}
+
+void QH264Streaming::setNumPframes(int numpframes)
+{
+    Q_D(QH264Streaming);
+    d->control->setNumPframes(numpframes);
+}
+
+void QH264Streaming::setNoReorder(bool noreorder)
+{
+    Q_D(QH264Streaming);
+    d->control->setNoReorder(noreorder);
+}
+
+void QH264Streaming::setUdpPort(QString udpport)
+{
+    Q_D(QH264Streaming);
+    d->control->setUdpPort(udpport);
+}
+
+void QH264Streaming::setUdpHost(QString udphost)
+{
+    Q_D(QH264Streaming);
+    d->control->setUdpHost(udphost);
+}
+
+void QH264Streaming::setTransmit(bool transmit)
+{
+    Q_D(QH264Streaming);
+    d->control->setTransmit(transmit);
+}
+
+void QH264Streaming::setVspm(bool vspm)
+{
+    Q_D(QH264Streaming);
+    d->control->setVspm(vspm);
+}
+
+void QH264Streaming::setVspmDmabuf(bool vspmdmabuf)
+{
+    Q_D(QH264Streaming);
+    d->control->setVspmDmabuf(vspmdmabuf);
+}
+
+void QH264Streaming::setVspmWidth(int vspmwidth)
+{
+    Q_D(QH264Streaming);
+    d->control->setVspmWidth(vspmwidth);
+}
+
+void QH264Streaming::setVspmWidth1(int vspmwidth1)
+{
+    Q_D(QH264Streaming);
+    d->control->setVspmWidth1(vspmwidth1);
+}
+
+void QH264Streaming::setVspmHeight(int vspmheight)
+{
+    Q_D(QH264Streaming);
+    d->control->setVspmHeight(vspmheight);
+}
+
+void QH264Streaming::setVspmHeight1(int vspmheight1)
+{
+    Q_D(QH264Streaming);
+    d->control->setVspmHeight1(vspmheight1);
+}
+
+void QH264Streaming::setVspmFormat(QString vspmformat)
+{
+    Q_D(QH264Streaming);
+    d->control->setVspmFormat(vspmformat);
+}
+
+void QH264Streaming::setWlsMaxLateness(int wlsmaxlateness)
+{
+    Q_D(QH264Streaming);
+    d->control->setWlsMaxLateness(wlsmaxlateness);
+}
+
+void QH264Streaming::setWlsQos(bool wlsqos)
+{
+    Q_D(QH264Streaming);
+    d->control->setWlsQos(wlsqos);
+}
+
+void QH264Streaming::setWlsPositionX(int wlspositionx)
+{
+    Q_D(QH264Streaming);
+    d->control->setWlsPositionX(wlspositionx);
+}
+
+void QH264Streaming::setWlsPositionY(int wlspositiony)
+{
+    Q_D(QH264Streaming);
+    d->control->setWlsPositionY(wlspositiony);
+}
+
+void QH264Streaming::setWlsOutWidth(int wlsoutwidth)
+{
+    Q_D(QH264Streaming);
+    d->control->setWlsOutWidth(wlsoutwidth);
+}
+
+void QH264Streaming::setWlsOutHeight(int wlsoutheight)
+{
+    Q_D(QH264Streaming);
+    d->control->setWlsOutHeight(wlsoutheight);
+}
+
+void QH264Streaming::componentComplete()
+{
+    Q_D(QH264Streaming);
+    d->control->componentComplete();
+}
+
+/*!
+    Construct a QMediaPlayer instance
+    parented to \a parent and with \a flags.
+*/
+
+QH264Streaming::QH264Streaming(QObject *parent, QH264Streaming::Flags flags):
+    QMediaObject(*new QH264StreamingPrivate,
+                 parent,
+                 playerService(flags))
+{
+    Q_D(QH264Streaming);
+
+    d->provider = QMediaServiceProvider::defaultServiceProvider();
+    if (d->service == 0) {
+        d->error = ServiceMissingError;
+    } else {
+        d->control = qobject_cast<QH264StreamingControl*>(d->service->requestControl(QH264StreamingControl_iid));
+        d->networkAccessControl = qobject_cast<QMediaNetworkAccessControl*>(d->service->requestControl(QMediaNetworkAccessControl_iid));
+        if (d->control != 0) {
+            connect(d->control, SIGNAL(mediaChanged(QMediaContent)), SIGNAL(currentMediaChanged(QMediaContent)));
+            connect(d->control, SIGNAL(stateChanged(QH264Streaming::State)), SLOT(_q_stateChanged(QH264Streaming::State)));
+            connect(d->control, SIGNAL(mediaStatusChanged(QH264Streaming::MediaStatus)),
+                    SLOT(_q_mediaStatusChanged(QH264Streaming::MediaStatus)));
+            connect(d->control, SIGNAL(error(int,QString)), SLOT(_q_error(int,QString)));
+
+            connect(d->control, SIGNAL(durationChanged(qint64)), SIGNAL(durationChanged(qint64)));
+            connect(d->control, SIGNAL(positionChanged(qint64)), SIGNAL(positionChanged(qint64)));
+            connect(d->control, SIGNAL(audioAvailableChanged(bool)), SIGNAL(audioAvailableChanged(bool)));
+            connect(d->control, SIGNAL(videoAvailableChanged(bool)), SIGNAL(videoAvailableChanged(bool)));
+            connect(d->control, SIGNAL(volumeChanged(int)), SIGNAL(volumeChanged(int)));
+            connect(d->control, SIGNAL(mutedChanged(bool)), SIGNAL(mutedChanged(bool)));
+            connect(d->control, SIGNAL(seekableChanged(bool)), SIGNAL(seekableChanged(bool)));
+            connect(d->control, SIGNAL(playbackRateChanged(qreal)), SIGNAL(playbackRateChanged(qreal)));
+            connect(d->control, SIGNAL(bufferStatusChanged(int)), SIGNAL(bufferStatusChanged(int)));
+
+            if (d->control->state() == PlayingState)
+                addPropertyWatch("position");
+
+            if (d->control->mediaStatus() == StalledMedia || d->control->mediaStatus() == BufferingMedia)
+                addPropertyWatch("bufferStatus");
+        }
+        if (d->networkAccessControl != 0) {
+            connect(d->networkAccessControl, SIGNAL(configurationChanged(QNetworkConfiguration)),
+            this, SIGNAL(networkConfigurationChanged(QNetworkConfiguration)));
+        }
+    }
+}
+
+
+/*!
+    Destroys the player object.
+*/
+
+QH264Streaming::~QH264Streaming()
+{
+    Q_D(QH264Streaming);
+
+    if (d->service) {
+        if (d->control)
+            d->service->releaseControl(d->control);
+
+        d->provider->releaseService(d->service);
+    }
+}
+
+QMediaContent QH264Streaming::media() const
+{
+    Q_D(const QH264Streaming);
+
+    return d->rootMedia;
+}
+
+/*!
+    Returns the stream source of media data.
+
+    This is only valid if a stream was passed to setMedia().
+
+    \sa setMedia()
+*/
+
+const QIODevice *QH264Streaming::mediaStream() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->mediaStream();
+
+    return 0;
+}
+
+QMediaPlaylist *QH264Streaming::playlist() const
+{
+    Q_D(const QH264Streaming);
+
+    return d->rootMedia.playlist();
+}
+
+QMediaContent QH264Streaming::currentMedia() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->media();
+
+    return QMediaContent();
+}
+
+void QH264Streaming::setPlaylist(QMediaPlaylist *playlist)
+{
+    QMediaContent m(playlist, QUrl(), false);
+    setMedia(m);
+}
+
+/*!
+    Sets the network access points for remote media playback.
+    \a configurations contains, in ascending preferential order, a list of
+    configuration  that can be used for network access.
+
+    This will invalidate the choice of previous configurations.
+*/
+void QH264Streaming::setNetworkConfigurations(const QList<QNetworkConfiguration> &configurations)
+{
+    Q_D(QH264Streaming);
+
+    if (d->networkAccessControl)
+        d->networkAccessControl->setConfigurations(configurations);
+}
+
+QH264Streaming::State QH264Streaming::state() const
+{
+    return d_func()->state;
+}
+
+QH264Streaming::MediaStatus QH264Streaming::mediaStatus() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->mediaStatus();
+
+    return QH264Streaming::UnknownMediaStatus;
+}
+
+qint64 QH264Streaming::duration() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->duration();
+
+    return -1;
+}
+
+qint64 QH264Streaming::position() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->position();
+
+    return 0;
+}
+
+int QH264Streaming::volume() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->volume();
+
+    return 0;
+}
+
+bool QH264Streaming::isMuted() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->isMuted();
+
+    return false;
+}
+
+int QH264Streaming::bufferStatus() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->bufferStatus();
+
+    return 0;
+}
+
+bool QH264Streaming::isAudioAvailable() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->isAudioAvailable();
+
+    return false;
+}
+
+bool QH264Streaming::isVideoAvailable() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->isVideoAvailable();
+
+    return false;
+}
+
+bool QH264Streaming::isSeekable() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->isSeekable();
+
+    return false;
+}
+
+qreal QH264Streaming::playbackRate() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->control != 0)
+        return d->control->playbackRate();
+
+    return 0.0;
+}
+
+/*!
+    Returns the current error state.
+*/
+
+QH264Streaming::Error QH264Streaming::error() const
+{
+    return d_func()->error;
+}
+
+QString QH264Streaming::errorString() const
+{
+    return d_func()->errorString;
+}
+
+/*!
+    Returns the current network access point  in use.
+    If a default contructed QNetworkConfiguration is returned
+    this feature is not available or that none of the
+    current supplied configurations are in use.
+*/
+QNetworkConfiguration QH264Streaming::currentNetworkConfiguration() const
+{
+    Q_D(const QH264Streaming);
+
+    if (d->networkAccessControl)
+        return d_func()->networkAccessControl->currentConfiguration();
+
+    return QNetworkConfiguration();
+}
+
+//public Q_SLOTS:
+/*!
+    Start or resume playing the current source.
+*/
+
+void QH264Streaming::play()
+{
+    Q_D(QH264Streaming);
+
+    if (d->control == 0) {
+        QMetaObject::invokeMethod(this, "_q_error", Qt::QueuedConnection,
+                                    Q_ARG(int, QH264Streaming::ServiceMissingError),
+                                    Q_ARG(QString, tr("The QH264Streaming object does not have a valid service")));
+        return;
+    }
+
+    //if playlist control is available, the service should advance itself
+    if (d->rootMedia.playlist() && d->rootMedia.playlist()->currentIndex() == -1 && !d->rootMedia.playlist()->isEmpty()) {
+
+        // switch to playing state
+        if (d->state != QH264Streaming::PlayingState)
+            d->_q_stateChanged(QH264Streaming::PlayingState);
+
+        if (d->playlist != d->rootMedia.playlist())
+            d->setPlaylist(d->rootMedia.playlist());
+        Q_ASSERT(d->playlist == d->rootMedia.playlist());
+        emit currentMediaChanged(d->rootMedia);
+        d->playlist->setCurrentIndex(0);
+    }
+
+    // Reset error conditions
+    d->error = NoError;
+    d->errorString = QString();
+
+    d->control->play();
+}
+
+/*!
+    Pause playing the current source.
+*/
+
+void QH264Streaming::pause()
+{
+    Q_D(QH264Streaming);
+
+    if (d->control != 0)
+        d->control->pause();
+}
+
+/*!
+    Stop playing, and reset the play position to the beginning.
+*/
+
+void QH264Streaming::stop()
+{
+    Q_D(QH264Streaming);
+
+    if (d->control != 0)
+        d->control->stop();
+
+    // If media player didn't stop in response to control.
+    // This happens if we have an active playlist and control
+    // media status is
+    // QMediaPlayer::LoadingMedia, QMediaPlayer::InvalidMedia, or QMediaPlayer::EndOfMedia
+    // see QMediaPlayerPrivate::_q_stateChanged()
+    if (d->playlist && d->state != QH264Streaming::StoppedState) {
+        d->state = QH264Streaming::StoppedState;
+        removePropertyWatch("position");
+        emit stateChanged(QH264Streaming::StoppedState);
+    }
+}
+
+void QH264Streaming::setPosition(qint64 position)
+{
+    Q_D(QH264Streaming);
+
+    if (d->control == 0)
+        return;
+
+    d->control->setPosition(qMax(position, 0ll));
+}
+
+void QH264Streaming::setVolume(int v)
+{
+    Q_D(QH264Streaming);
+
+    if (d->control == 0)
+        return;
+
+    int clamped = qBound(0, v, 100);
+    if (clamped == volume())
+        return;
+
+    d->control->setVolume(clamped);
+}
+
+void QH264Streaming::setMuted(bool muted)
+{
+    Q_D(QH264Streaming);
+
+    if (d->control == 0 || muted == isMuted())
+        return;
+
+    d->control->setMuted(muted);
+}
+
+void QH264Streaming::setPlaybackRate(qreal rate)
+{
+    Q_D(QH264Streaming);
+
+    if (d->control != 0)
+        d->control->setPlaybackRate(rate);
+}
+
+/*!
+    Sets the current \a media source.
+
+    If a \a stream is supplied; media data will be read from it instead of resolving the media
+    source.  In this case the media source may still be used to resolve additional information
+    about the media such as mime type.
+
+    Setting the media to a null QMediaContent will cause the player to discard all
+    information relating to the current media source and to cease all I/O operations related
+    to that media.
+
+    \note This function returns immediately after recording the specified source of the media.
+    It does not wait for the media to finish loading and does not check for errors. Listen for
+    the mediaStatusChanged() and error() signals to be notified when the media is loaded and
+    when an error occurs during loading.
+*/
+
+
+void QH264Streaming::setMedia(const QMediaContent &media, QIODevice *stream)
+{
+    Q_D(QH264Streaming);
+    stop();
+
+    QMediaContent oldMedia = d->rootMedia;
+    d->disconnectPlaylist();
+    d->playlist = 0;
+    d->rootMedia = media;
+    d->nestedPlaylists = 0;
+
+    if (oldMedia != media)
+        emit mediaChanged(d->rootMedia);
+
+    if (media.playlist()) {
+        // reset playlist to the 1st item
+        media.playlist()->setCurrentIndex(0);
+        d->setPlaylist(media.playlist());
+    } else if (d->control != 0) {
+        d->control->setMedia(media, stream);
+    }
+}
+
+/*!
+    \internal
+*/
+
+bool QH264Streaming::bind(QObject *obj)
+{
+    return QMediaObject::bind(obj);
+}
+
+/*!
+    \internal
+*/
+
+void QH264Streaming::unbind(QObject *obj)
+{
+    QMediaObject::unbind(obj);
+}
+
+/*!
+    Returns the level of support a media player has for a \a mimeType and a set of \a codecs.
+
+    The \a flags argument allows additional requirements such as performance indicators to be
+    specified.
+*/
+QMultimedia::SupportEstimate QH264Streaming::hasSupport(const QString &mimeType,
+                                               const QStringList& codecs,
+                                               Flags flags)
+{
+    return QMediaServiceProvider::defaultServiceProvider()->hasSupport(QByteArray(Q_MEDIASERVICE_MEDIAPLAYER),
+                                                                    mimeType,
+                                                                    codecs,
+                                                                    flags);
+}
+
+/*!
+    \deprecated
+    Returns a list of MIME types supported by the media player.
+
+    The \a flags argument causes the resultant list to be restricted to MIME types which can be supported
+    given additional requirements, such as performance indicators.
+
+    This function may not return useful results on some platforms, and support for a specific file of a
+    given mime type is not guaranteed even if the mime type is in general supported.  In addition, in some
+    cases this function will need to load all available media plugins and query them for their support, which
+    may take some time.
+*/
+QStringList QH264Streaming::supportedMimeTypes(Flags flags)
+{
+    return QMediaServiceProvider::defaultServiceProvider()->supportedMimeTypes(QByteArray(Q_MEDIASERVICE_MEDIAPLAYER),
+                                                                               flags);
+}
+
+/*!
+    \fn void QMediaPlayer::setVideoOutput(QVideoWidget* output)
+
+    Attach a QVideoWidget video \a output to the media player.
+
+    If the media player has already video output attached,
+    it will be replaced with a new one.
+*/
+void QH264Streaming::setVideoOutput(QVideoWidget *output)
+{
+    Q_D(QH264Streaming);
+
+    if (d->videoOutput)
+        unbind(d->videoOutput);
+
+    // We don't know (in this library) that QVideoWidget inherits QObject
+    QObject *outputObject = reinterpret_cast<QObject*>(output);
+
+    d->videoOutput = outputObject && bind(outputObject) ? outputObject : 0;
+}
+
+/*!
+    \fn void QMediaPlayer::setVideoOutput(QGraphicsVideoItem* output)
+
+    Attach a QGraphicsVideoItem video \a output to the media player.
+
+    If the media player has already video output attached,
+    it will be replaced with a new one.
+*/
+void QH264Streaming::setVideoOutput(QGraphicsVideoItem *output)
+{
+    Q_D(QH264Streaming);
+
+    if (d->videoOutput)
+        unbind(d->videoOutput);
+
+    // We don't know (in this library) that QGraphicsVideoItem (multiply) inherits QObject
+    // but QObject inheritance depends on QObject coming first, so try this out.
+    QObject *outputObject = reinterpret_cast<QObject*>(output);
+
+    d->videoOutput = outputObject && bind(outputObject) ? outputObject : 0;
+}
+
+/*!
+    Sets a video \a surface as the video output of a media player.
+
+    If a video output has already been set on the media player the new surface
+    will replace it.
+*/
+
+void QH264Streaming::setVideoOutput(QAbstractVideoSurface *surface)
+{
+    Q_D(QH264Streaming);
+
+    d->surfaceOutput.setVideoSurface(surface);
+
+    if (d->videoOutput != &d->surfaceOutput) {
+        if (d->videoOutput)
+            unbind(d->videoOutput);
+
+        d->videoOutput = 0;
+
+        if (surface && bind(&d->surfaceOutput))
+            d->videoOutput =  &d->surfaceOutput;
+    }  else if (!surface) {
+        //unbind the surfaceOutput if null surface is set
+        unbind(&d->surfaceOutput);
+        d->videoOutput = 0;
+    }
+}
+
+/*! \reimp */
+QMultimedia::AvailabilityStatus QH264Streaming::availability() const
+{
+    Q_D(const QH264Streaming);
+
+    if (!d->control)
+        return QMultimedia::ServiceMissing;
+
+    return QMediaObject::availability();
+}
+
+
+// Enums
+/*!
+    \enum QMediaPlayer::State
+
+    Defines the current state of a media player.
+
+    \value StoppedState The media player is not playing content, playback will begin from the start
+    of the current track.
+    \value PlayingState The media player is currently playing content.
+    \value PausedState The media player has paused playback, playback of the current track will
+    resume from the position the player was paused at.
+*/
+
+
+/*!
+    \enum QMediaPlayer::MediaStatus
+
+    Defines the status of a media player's current media.
+
+    \value UnknownMediaStatus The status of the media cannot be determined.
+    \value NoMedia The is no current media.  The player is in the StoppedState.
+    \value LoadingMedia The current media is being loaded. The player may be in any state.
+    \value LoadedMedia The current media has been loaded. The player is in the StoppedState.
+    \value StalledMedia Playback of the current media has stalled due to insufficient buffering or
+    some other temporary interruption.  The player is in the PlayingState or PausedState.
+    \value BufferingMedia The player is buffering data but has enough data buffered for playback to
+    continue for the immediate future.  The player is in the PlayingState or PausedState.
+    \value BufferedMedia The player has fully buffered the current media.  The player is in the
+    PlayingState or PausedState.
+    \value EndOfMedia Playback has reached the end of the current media.  The player is in the
+    StoppedState.
+    \value InvalidMedia The current media cannot be played.  The player is in the StoppedState.
+*/
+
+/*!
+    \enum QMediaPlayer::Error
+
+    Defines a media player error condition.
+
+    \value NoError No error has occurred.
+    \value ResourceError A media resource couldn't be resolved.
+    \value FormatError The format of a media resource isn't (fully) supported.  Playback may still
+    be possible, but without an audio or video component.
+    \value NetworkError A network error occurred.
+    \value AccessDeniedError There are not the appropriate permissions to play a media resource.
+    \value ServiceMissingError A valid playback service was not found, playback cannot proceed.
+    \omitvalue MediaIsPlaylist
+*/
+
+// Signals
+/*!
+    \fn QMediaPlayer::error(QMediaPlayer::Error error)
+
+    Signals that an \a error condition has occurred.
+
+    \sa errorString()
+*/
+
+/*!
+    \fn void QMediaPlayer::stateChanged(State state)
+
+    Signal the \a state of the Player object has changed.
+*/
+
+/*!
+    \fn QMediaPlayer::mediaStatusChanged(QMediaPlayer::MediaStatus status)
+
+    Signals that the \a status of the current media has changed.
+
+    \sa mediaStatus()
+*/
+
+/*!
+    \fn void QMediaPlayer::mediaChanged(const QMediaContent &media);
+
+    Signals that the media source has been changed to \a media.
+
+    \sa media(), currentMediaChanged()
+*/
+
+/*!
+    \fn void QMediaPlayer::currentMediaChanged(const QMediaContent &media);
+
+    Signals that the current playing content has been changed to \a media.
+
+    \sa currentMedia(), mediaChanged()
+*/
+
+/*!
+    \fn void QMediaPlayer::playbackRateChanged(qreal rate);
+
+    Signals the playbackRate has changed to \a rate.
+*/
+
+/*!
+    \fn void QMediaPlayer::seekableChanged(bool seekable);
+
+    Signals the \a seekable status of the player object has changed.
+*/
+
+// Properties
+/*!
+    \property QMediaPlayer::state
+    \brief the media player's playback state.
+
+    By default this property is QMediaPlayer::Stopped
+
+    \sa mediaStatus(), play(), pause(), stop()
+*/
+
+/*!
+    \property QMediaPlayer::error
+    \brief a string describing the last error condition.
+
+    \sa error()
+*/
+
+/*!
+    \property QMediaPlayer::media
+    \brief the active media source being used by the player object.
+
+    The player object will use the QMediaContent for selection of the content to
+    be played.
+
+    By default this property has a null QMediaContent.
+
+    Setting this property to a null QMediaContent will cause the player to discard all
+    information relating to the current media source and to cease all I/O operations related
+    to that media.
+
+    \sa QMediaContent, currentMedia()
+*/
+
+/*!
+    \property QMediaPlayer::currentMedia
+    \brief the current active media content being played by the player object.
+    This value could be different from QMediaPlayer::media property if a playlist is used.
+    In this case currentMedia indicates the current media content being processed
+    by the player, while QMediaPlayer::media property contains the original playlist.
+
+    \sa QMediaContent, media()
+*/
+
+/*!
+    \property QMediaPlayer::playlist
+    \brief the media playlist being used by the player object.
+
+    The player object will use the current playlist item for selection of the content to
+    be played.
+
+    By default this property is set to null.
+
+    If the media playlist is used as a source, QMediaPlayer::currentMedia is updated with
+    a current playlist item. The current source should be selected with
+    QMediaPlaylist::setCurrentIndex(int) instead of QMediaPlayer::setMedia(),
+    otherwise the current playlist will be discarded.
+
+    \sa QMediaContent
+*/
+
+
+/*!
+    \property QMediaPlayer::mediaStatus
+    \brief the status of the current media stream.
+
+    The stream status describes how the playback of the current stream is
+    progressing.
+
+    By default this property is QMediaPlayer::NoMedia
+
+    \sa state
+*/
+
+/*!
+    \property QMediaPlayer::duration
+    \brief the duration of the current media.
+
+    The value is the total playback time in milliseconds of the current media.
+    The value may change across the life time of the QMediaPlayer object and
+    may not be available when initial playback begins, connect to the
+    durationChanged() signal to receive status notifications.
+*/
+
+/*!
+    \property QMediaPlayer::position
+    \brief the playback position of the current media.
+
+    The value is the current playback position, expressed in milliseconds since
+    the beginning of the media. Periodically changes in the position will be
+    indicated with the signal positionChanged(), the interval between updates
+    can be set with QMediaObject's method setNotifyInterval().
+*/
+
+/*!
+    \property QMediaPlayer::volume
+    \brief the current playback volume.
+
+    The playback volume is linear in effect and the value can range from 0 -
+    100, values outside this range will be clamped.
+*/
+
+/*!
+    \property QMediaPlayer::muted
+    \brief the muted state of the current media.
+
+    The value will be true if the playback volume is muted; otherwise false.
+*/
+
+/*!
+    \property QMediaPlayer::bufferStatus
+    \brief the percentage of the temporary buffer filled before playback begins or resumes, from
+    \c 0 (empty) to \c 100 (full).
+
+    When the player object is buffering; this property holds the percentage of
+    the temporary buffer that is filled. The buffer will need to reach 100%
+    filled before playback can start or resume, at which time mediaStatus() will return
+    BufferedMedia or BufferingMedia. If the value is anything lower than \c 100, mediaStatus() will
+    return StalledMedia.
+
+    \sa mediaStatus()
+*/
+
+/*!
+    \property QMediaPlayer::audioAvailable
+    \brief the audio availabilty status for the current media.
+
+    As the life time of QMediaPlayer can be longer than the playback of one
+    QMediaContent, this property may change over time, the
+    audioAvailableChanged signal can be used to monitor it's status.
+*/
+
+/*!
+    \property QMediaPlayer::videoAvailable
+    \brief the video availability status for the current media.
+
+    If available, the QVideoWidget class can be used to view the video. As the
+    life time of QMediaPlayer can be longer than the playback of one
+    QMediaContent, this property may change over time, the
+    videoAvailableChanged signal can be used to monitor it's status.
+
+    \sa QVideoWidget, QMediaContent
+*/
+
+/*!
+    \property QMediaPlayer::seekable
+    \brief the seek-able status of the current media
+
+    If seeking is supported this property will be true; false otherwise. The
+    status of this property may change across the life time of the QMediaPlayer
+    object, use the seekableChanged signal to monitor changes.
+*/
+
+/*!
+    \property QMediaPlayer::playbackRate
+    \brief the playback rate of the current media.
+
+    This value is a multiplier applied to the media's standard play rate. By
+    default this value is 1.0, indicating that the media is playing at the
+    standard pace. Values higher than 1.0 will increase the rate of play.
+    Values less than zero can be set and indicate the media will rewind at the
+    multiplier of the standard pace.
+
+    Not all playback services support change of the playback rate. It is
+    framework defined as to the status and quality of audio and video
+    while fast forwarding or rewinding.
+*/
+
+/*!
+    \fn void QMediaPlayer::durationChanged(qint64 duration)
+
+    Signal the duration of the content has changed to \a duration, expressed in milliseconds.
+*/
+
+/*!
+    \fn void QMediaPlayer::positionChanged(qint64 position)
+
+    Signal the position of the content has changed to \a position, expressed in
+    milliseconds.
+*/
+
+/*!
+    \fn void QMediaPlayer::volumeChanged(int volume)
+
+    Signal the playback volume has changed to \a volume.
+*/
+
+/*!
+    \fn void QMediaPlayer::mutedChanged(bool muted)
+
+    Signal the mute state has changed to \a muted.
+*/
+
+/*!
+    \fn void QMediaPlayer::videoAvailableChanged(bool videoAvailable)
+
+    Signal the availability of visual content has changed to \a videoAvailable.
+*/
+
+/*!
+    \fn void QMediaPlayer::audioAvailableChanged(bool available)
+
+    Signals the availability of audio content has changed to \a available.
+*/
+
+/*!
+    \fn void QMediaPlayer::bufferStatusChanged(int percentFilled)
+
+    Signal the amount of the local buffer filled as a percentage by \a percentFilled.
+*/
+
+/*!
+   \fn void QMediaPlayer::networkConfigurationChanged(const QNetworkConfiguration &configuration)
+
+    Signal that the active in use network access point  has been changed to \a configuration and all subsequent network access will use this \a configuration.
+*/
+
+/*!
+    \enum QMediaPlayer::Flag
+
+    \value LowLatency       The player is expected to be used with simple audio formats,
+            but playback should start without significant delay.
+            Such playback service can be used for beeps, ringtones, etc.
+
+    \value StreamPlayback   The player is expected to play QIODevice based streams.
+            If passed to QMediaPlayer constructor, the service supporting
+            streams playback will be chosen.
+
+    \value VideoSurface     The player is expected to be able to render to a
+            QAbstractVideoSurface \l {setVideoOutput()}{output}.
+*/
+
+#include "moc_qH264Streaming.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/playback/qH264Streaming.h b/src/multimedia/playback/qH264Streaming.h
new file mode 100755
index 0000000..52d19dd
--- /dev/null
+++ b/src/multimedia/playback/qH264Streaming.h
@@ -0,0 +1,245 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QH264STREAMING_H
+#define QH264STREAMING_H
+
+#include <QtMultimedia/qmediaobject.h>
+#include <QtMultimedia/qmediacontent.h>
+#include <QtMultimedia/qmediaenumdebug.h>
+
+#include <QtNetwork/qnetworkconfiguration.h>
+
+QT_BEGIN_NAMESPACE
+
+
+class QAbstractVideoSurface;
+class QMediaPlaylist;
+class QVideoWidget;
+class QGraphicsVideoItem;
+
+class QH264StreamingPrivate;
+class Q_MULTIMEDIA_EXPORT QH264Streaming : public QMediaObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QMediaContent media READ media WRITE setMedia NOTIFY mediaChanged)
+    Q_PROPERTY(QMediaContent currentMedia READ currentMedia NOTIFY currentMediaChanged)
+    Q_PROPERTY(QMediaPlaylist * playlist READ playlist WRITE setPlaylist)
+    Q_PROPERTY(qint64 duration READ duration NOTIFY durationChanged)
+    Q_PROPERTY(qint64 position READ position WRITE setPosition NOTIFY positionChanged)
+    Q_PROPERTY(int volume READ volume WRITE setVolume NOTIFY volumeChanged)
+    Q_PROPERTY(bool muted READ isMuted WRITE setMuted NOTIFY mutedChanged)
+    Q_PROPERTY(int bufferStatus READ bufferStatus NOTIFY bufferStatusChanged)
+    Q_PROPERTY(bool audioAvailable READ isAudioAvailable NOTIFY audioAvailableChanged)
+    Q_PROPERTY(bool videoAvailable READ isVideoAvailable NOTIFY videoAvailableChanged)
+    Q_PROPERTY(bool seekable READ isSeekable NOTIFY seekableChanged)
+    Q_PROPERTY(qreal playbackRate READ playbackRate WRITE setPlaybackRate NOTIFY playbackRateChanged)
+    Q_PROPERTY(State state READ state NOTIFY stateChanged)
+    Q_PROPERTY(MediaStatus mediaStatus READ mediaStatus NOTIFY mediaStatusChanged)
+    Q_PROPERTY(QString error READ errorString)
+    Q_ENUMS(State)
+    Q_ENUMS(MediaStatus)
+    Q_ENUMS(Error)
+
+public:
+    enum State
+    {
+        StoppedState,
+        PlayingState,
+        PausedState,
+        VideoPlaying
+    };
+
+    enum MediaStatus
+    {
+        UnknownMediaStatus,
+        NoMedia,
+        LoadingMedia,
+        LoadedMedia,
+        StalledMedia,
+        BufferingMedia,
+        BufferedMedia,
+        EndOfMedia,
+        InvalidMedia
+    };
+
+    enum Flag
+    {
+        LowLatency = 0x01,
+        StreamPlayback = 0x02,
+        VideoSurface = 0x04,
+        H264Streaming = 0x08
+    };
+    Q_DECLARE_FLAGS(Flags, Flag)
+
+    enum Error
+    {
+        NoError,
+        ResourceError,
+        FormatError,
+        NetworkError,
+        AccessDeniedError,
+        ServiceMissingError,
+        MediaIsPlaylist
+    };
+
+    QH264Streaming(QObject *parent = 0, Flags flags = 0);
+    ~QH264Streaming();
+
+    static QMultimedia::SupportEstimate hasSupport(const QString &mimeType,
+                                            const QStringList& codecs = QStringList(),
+                                            Flags flags = 0);
+    static QStringList supportedMimeTypes(Flags flags = 0);
+
+    void setVideoOutput(QVideoWidget *);
+    void setVideoOutput(QGraphicsVideoItem *);
+    void setVideoOutput(QAbstractVideoSurface *surface);
+
+    QMediaContent media() const;
+    const QIODevice *mediaStream() const;
+    QMediaPlaylist *playlist() const;
+    QMediaContent currentMedia() const;
+
+    State state() const;
+    MediaStatus mediaStatus() const;
+
+    qint64 duration() const;
+    qint64 position() const;
+
+    int volume() const;
+    bool isMuted() const;
+    bool isAudioAvailable() const;
+    bool isVideoAvailable() const;
+
+    int bufferStatus() const;
+
+    bool isSeekable() const;
+    qreal playbackRate() const;
+
+    Error error() const;
+    QString errorString() const;
+
+    QNetworkConfiguration currentNetworkConfiguration() const;
+
+    QMultimedia::AvailabilityStatus availability() const;
+
+public Q_SLOTS:
+    void play();
+    void pause();
+    void stop();
+
+    void setPosition(qint64 position);
+    void setVolume(int volume);
+    void setMuted(bool muted);
+
+    void setPlaybackRate(qreal rate);
+
+    void setMedia(const QMediaContent &media, QIODevice *stream = 0);
+    void setPlaylist(QMediaPlaylist *playlist);
+
+    void setNetworkConfigurations(const QList<QNetworkConfiguration> &configurations);
+    
+    void setHdmiWidth(int hdmiwidth);
+    void setHdmiHeight(int hdmiheight);
+    void setHdmiFormat(QString hdmiformat);
+    void setEncBitrate(int encbitrate);
+    void setNumPframes(int numpframes);
+    void setNoReorder(bool noreorder);
+    void setUdpPort(QString udpport);
+    void setUdpHost(QString udphost);
+    void setTransmit(bool transmit);
+    void setVspm(bool vspm);
+    void setVspmDmabuf(bool vspmdmabuf);
+    void setVspmWidth(int vspmwidth);
+    void setVspmWidth1(int vspmwidth1);
+    void setVspmHeight(int vspmheight);
+    void setVspmHeight1(int vspmheight1);
+    void setVspmFormat(QString vspmformat);
+    void setWlsMaxLateness(int wlsmaxlateness);
+    void setWlsQos(bool wlsqos);
+    void setWlsPositionX(int wlspositionx);
+    void setWlsPositionY(int wlspositiony);
+    void setWlsOutWidth(int wlsoutwidth);
+    void setWlsOutHeight(int wlsoutheight);
+    void componentComplete();
+
+Q_SIGNALS:
+    void mediaChanged(const QMediaContent &media);
+    void currentMediaChanged(const QMediaContent &media);
+
+    void stateChanged(QH264Streaming::State newState);
+    void mediaStatusChanged(QH264Streaming::MediaStatus status);
+
+    void durationChanged(qint64 duration);
+    void positionChanged(qint64 position);
+
+    void volumeChanged(int volume);
+    void mutedChanged(bool muted);
+    void audioAvailableChanged(bool available);
+    void videoAvailableChanged(bool videoAvailable);
+
+    void bufferStatusChanged(int percentFilled);
+
+    void seekableChanged(bool seekable);
+    void playbackRateChanged(qreal rate);
+
+    void error(QH264Streaming::Error error);
+
+    void networkConfigurationChanged(const QNetworkConfiguration &configuration);
+public:
+    virtual bool bind(QObject *);
+    virtual void unbind(QObject *);
+
+private:
+    Q_DISABLE_COPY(QH264Streaming)
+    Q_DECLARE_PRIVATE(QH264Streaming)
+    Q_PRIVATE_SLOT(d_func(), void _q_stateChanged(QH264Streaming::State))
+    Q_PRIVATE_SLOT(d_func(), void _q_mediaStatusChanged(QH264Streaming::MediaStatus))
+    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
+    Q_PRIVATE_SLOT(d_func(), void _q_updateMedia(const QMediaContent&))
+    Q_PRIVATE_SLOT(d_func(), void _q_playlistDestroyed())
+    Q_PRIVATE_SLOT(d_func(), void _q_handlePlaylistLoaded())
+    Q_PRIVATE_SLOT(d_func(), void _q_handlePlaylistLoadFailed())
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QH264Streaming::State)
+Q_DECLARE_METATYPE(QH264Streaming::MediaStatus)
+Q_DECLARE_METATYPE(QH264Streaming::Error)
+
+Q_MEDIA_ENUM_DEBUG(QH264Streaming, State)
+Q_MEDIA_ENUM_DEBUG(QH264Streaming, MediaStatus)
+Q_MEDIA_ENUM_DEBUG(QH264Streaming, Error)
+
+#endif  // QMEDIAPLAYER_H
diff --git a/src/multimedia/playback/qMP4Playback.cpp b/src/multimedia/playback/qMP4Playback.cpp
new file mode 100755
index 0000000..d6445ff
--- /dev/null
+++ b/src/multimedia/playback/qMP4Playback.cpp
@@ -0,0 +1,176 @@
+#include "qMP4Playback.h"
+#include "qmediaobject_p.h"
+#include <qmediaservice.h>
+#include <qmediaserviceprovider_p.h>
+#include <qMP4Playbackcontrol.h>
+
+#include <QtCore/qdebug.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qstringlist.h>
+#include <QtCore/qmetaobject.h>
+
+// #define DEBUG_QMP4PLAYBACK
+
+QT_BEGIN_NAMESPACE
+
+static void qRegisterMediaPlayerMetaTypes()
+{
+    qRegisterMetaType<QMP4Playback::State>("QMP4Playback::State");
+    qRegisterMetaType<QMP4Playback::Status>("QMP4Playback::Status");
+    qRegisterMetaType<QMP4Playback::Error>("QMP4Playback::Error");
+}
+Q_CONSTRUCTOR_FUNCTION(qRegisterMediaPlayerMetaTypes)
+
+class QMP4PlaybackPrivate : public QMediaObjectPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QMP4Playback)
+
+public:
+    QMP4PlaybackPrivate()
+        : provider(0)
+        , control(0)
+    {}
+    
+    QMediaServiceProvider *provider;
+    QMP4PlaybackControl* control;
+};
+
+static QMediaService *playerService()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider();
+    return provider->requestService(Q_MEDIASERVICE_MP4PLAYBACK);
+}
+
+QMP4Playback::QMP4Playback(QObject *parent):QMediaObject(*new QMP4PlaybackPrivate, parent, playerService())
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Playback);
+    d->provider = QMediaServiceProvider::defaultServiceProvider();
+    if (d->service == 0) {
+        
+    }else{
+        d->control = qobject_cast<QMP4PlaybackControl*>(d->service->requestControl(QMP4PlaybackControl_iid));
+        if (d->control != 0) {
+            connect(d->control, SIGNAL(statestatusChanged(QMP4Playback::State, QMP4Playback::Status)),
+                    SLOT(slot_StateStatusChanged(QMP4Playback::State, QMP4Playback::Status)));
+        }
+    }
+}
+
+QMP4Playback::~QMP4Playback()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Playback);
+
+    if (d->service) {
+        if (d->control)
+            d->service->releaseControl(d->control);
+
+        d->provider->releaseService(d->service);
+    }
+}
+
+QString QMP4Playback::errorString() const
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return NULL;
+}
+
+void QMP4Playback::play()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Playback);
+    d->control->play();
+}
+
+void QMP4Playback::stop()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Playback);
+    d->control->stop();
+}
+
+void QMP4Playback::pause()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Playback);
+    d->control->pause();
+}
+
+void QMP4Playback::setSource(QString source)
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Playback);
+    d->control->setSource(source);
+}
+
+void QMP4Playback::componentComplete()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Playback);
+    d->control->componentComplete();
+}
+
+void QMP4Playback::slot_StateStatusChanged(QMP4Playback::State newstate, QMP4Playback::Status newstatus)
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+    printState(newstate);
+    printStatus(newstatus);
+#endif
+    emit signal_StateStatusChanged(newstate, newstatus);
+}
+
+void QMP4Playback::printState(QMP4Playback::State currentstate)
+{
+    switch(currentstate){
+        case QMP4Playback::StoppedState:
+            qDebug() << "Stopped State"; break;
+        case QMP4Playback::PlayingState:
+            qDebug() << "Playing State"; break;
+        case QMP4Playback::PausedState:
+            qDebug() << "Paused State"; break;
+        default:
+            qDebug() << "Unknown State"; break;
+    }
+}
+
+void QMP4Playback::printStatus(QMP4Playback::Status currentstatus)
+{
+    switch (currentstatus){
+        case QMP4Playback::NoMedia:
+            qDebug() << "No Media"; break;
+        case QMP4Playback::LoadedMedia:
+            qDebug() << "Loaded Media"; break;
+        case QMP4Playback::BufferingMedia:
+            qDebug() << "Buffering Media"; break;
+        case QMP4Playback::BufferedMedia:
+            qDebug() << "Buffered Media"; break;
+        case QMP4Playback::EndOfMedia:
+            qDebug() << "End Of Media"; break;
+        default:
+            qDebug() << "Unknown Status"; break;
+    }
+}
+
+#include "moc_qMP4Playback.cpp"
+QT_END_NAMESPACE
\ No newline at end of file
diff --git a/src/multimedia/playback/qMP4Playback.h b/src/multimedia/playback/qMP4Playback.h
new file mode 100755
index 0000000..d62810c
--- /dev/null
+++ b/src/multimedia/playback/qMP4Playback.h
@@ -0,0 +1,86 @@
+#ifndef QMP4PLAYBACK_H
+#define QMP4PLAYBACK_H
+
+#include <QtMultimedia/qmediaobject.h>
+#include <QtMultimedia/qmediacontent.h>
+#include <QtMultimedia/qmediaenumdebug.h>
+
+QT_BEGIN_NAMESPACE
+
+class QMP4PlaybackPrivate;
+class Q_MULTIMEDIA_EXPORT QMP4Playback : public QMediaObject
+{
+    Q_OBJECT
+    // Q_PROPERTY(State state READ state NOTIFY stateChanged)
+    // Q_PROPERTY(Status status READ status NOTIFY statusChanged)
+    Q_PROPERTY(QString error READ errorString)
+    
+    Q_ENUMS(Status)
+    Q_ENUMS(State)
+    Q_ENUMS(Error)
+    
+public:
+    enum Status
+    {
+        NoMedia,
+        LoadedMedia,
+        BufferingMedia,
+        BufferedMedia,
+        EndOfMedia
+    };
+
+    enum State {
+        StoppedState,
+        PlayingState,
+        PausedState,
+        ReadyState
+    };
+
+    enum Error
+    {
+        NoError,
+        ResourceError,
+        InputArgumentError
+    };
+    
+    QMP4Playback(QObject *parent = 0);
+    ~QMP4Playback();
+    
+    // State state() const;
+    // Status status() const;
+    Error error() const;
+    QString errorString() const;
+    
+    static void printState(QMP4Playback::State currentstate);
+    static void printStatus(QMP4Playback::Status currentstatus);
+    
+public Q_SLOTS:
+    void play();
+    void stop();
+    void pause();
+    void setSource(QString source);
+    void componentComplete();
+    void slot_StateStatusChanged(QMP4Playback::State, QMP4Playback::Status);
+
+Q_SIGNALS:
+    // void stateChanged(QMP4Playback::State);
+    // void statusChanged(QMP4Playback::Status);
+    void signal_StateStatusChanged(QMP4Playback::State, QMP4Playback::Status);
+
+private:
+    Q_DISABLE_COPY(QMP4Playback)
+    Q_DECLARE_PRIVATE(QMP4Playback)
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QMP4Playback::State)
+Q_DECLARE_METATYPE(QMP4Playback::Status)
+Q_DECLARE_METATYPE(QMP4Playback::Error)
+
+Q_MEDIA_ENUM_DEBUG(QMP4Playback, State)
+Q_MEDIA_ENUM_DEBUG(QMP4Playback, Status)
+Q_MEDIA_ENUM_DEBUG(QMP4Playback, Error)
+
+
+#endif  // QMP4PLAYBACK_H
\ No newline at end of file
diff --git a/src/multimedia/qmediaserviceproviderplugin.h b/src/multimedia/qmediaserviceproviderplugin.h
index 6e8bdc5..5a42441 100644
--- a/src/multimedia/qmediaserviceproviderplugin.h
+++ b/src/multimedia/qmediaserviceproviderplugin.h
@@ -193,6 +193,16 @@ public:
     virtual void release(QMediaService *service) = 0;
 };
 
+#define Q_MEDIASERVICE_MP4RECORDER "org.qt-project.qt.MP4Recorder"
+#define Q_MEDIASERVICE_MP4PLAYBACK "org.qt-project.qt.mp4playback"
+#define Q_MEDIASERVICE_AUDIOSTREAMING "org.qt-project.qt.audiostreaming"
+
+/*!
+    Service with support for H264 Streaming
+    Required Controls: QMediaPlayerControl
+*/
+#define Q_MEDIASERVICE_H264STREAMING "org.qt-project.qt.H264Streaming"
+
 /*!
     Service with support for media playback
     Required Controls: QMediaPlayerControl
diff --git a/src/multimedia/recording/qMP4Recorder.cpp b/src/multimedia/recording/qMP4Recorder.cpp
new file mode 100755
index 0000000..1f75c61
--- /dev/null
+++ b/src/multimedia/recording/qMP4Recorder.cpp
@@ -0,0 +1,259 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qMP4Recorder.h"
+
+#include "qmediaobject_p.h"
+#include <qmediaservice.h>
+#include <qMP4Recordercontrol.h>
+#include <qmediaserviceprovider_p.h>
+#include <qmetadatawritercontrol.h>
+#include <qaudioencodersettingscontrol.h>
+#include <qvideoencodersettingscontrol.h>
+#include <qmediacontainercontrol.h>
+#include <qmediaavailabilitycontrol.h>
+
+#include <QtCore/qdebug.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qstringlist.h>
+#include <QtCore/qmetaobject.h>
+
+// #define DEBUG_ENCODER
+
+QT_BEGIN_NAMESPACE
+
+static void qRegisterMediaPlayerMetaTypes()
+{
+    qRegisterMetaType<QMP4Recorder::State>("QMP4Recorder::State");
+    qRegisterMetaType<QMP4Recorder::MediaStatus>("QMP4Recorder::MediaStatus");
+    qRegisterMetaType<QMP4Recorder::Error>("QMP4Recorder::Error");
+}
+Q_CONSTRUCTOR_FUNCTION(qRegisterMediaPlayerMetaTypes)
+
+class QMP4RecorderPrivate : public QMediaObjectPrivate
+{
+    Q_DECLARE_NON_CONST_PUBLIC(QMP4Recorder)
+
+public:
+    QMP4RecorderPrivate()
+        : provider(0)
+        , control(0)
+        , state(QMP4Recorder::StoppedState)
+        , error(QMP4Recorder::NoError)
+    {}
+    
+    QMP4Recorder::State state;
+    QMP4Recorder::Error error;
+    QString errorString;
+    QMediaServiceProvider *provider;
+    QMP4RecorderControl* control;
+
+    void _q_stateChanged(QMP4Recorder::State);
+    void _q_mediaStatusChanged(QMP4Recorder::MediaStatus);
+    void _q_error(int, const QString &);
+};
+
+void QMP4RecorderPrivate::_q_stateChanged(QMP4Recorder::State)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+void QMP4RecorderPrivate::_q_mediaStatusChanged(QMP4Recorder::MediaStatus mst)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+    Q_Q(QMP4Recorder);
+    switch(mst){
+        case QMP4Recorder::UnknownMediaStatus: qDebug() << "UnknownMediaStatus"; break;
+        case QMP4Recorder::NoMedia: qDebug() << "NoMedia"; break;
+        case QMP4Recorder::LoadingMedia: qDebug() << "LoadingMedia"; break;
+        case QMP4Recorder::LoadedMedia: qDebug() << "LoadedMedia"; break;
+        case QMP4Recorder::StalledMedia: qDebug() << "StalledMedia"; break;
+        case QMP4Recorder::BufferingMedia: qDebug() << "BufferingMedia"; break;
+        case QMP4Recorder::BufferedMedia: qDebug() << "BufferedMedia"; break;
+        case QMP4Recorder::EndOfMedia: qDebug() << "EndOfMedia"; break;
+        case QMP4Recorder::InvalidMedia: qDebug() << "InvalidMedia"; break;
+        case QMP4Recorder::Active: qDebug() << "Active"; break;
+    }
+    emit q->mediaStatusChanged(mst);
+}
+
+void QMP4RecorderPrivate::_q_error(int error, const QString &errorString)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+}
+
+static QMediaService *playerService()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    QMediaServiceProvider *provider = QMediaServiceProvider::defaultServiceProvider();
+    return provider->requestService(Q_MEDIASERVICE_MP4RECORDER);
+}
+
+/*!
+    Construct a QMP4Recorder instance
+    parented to \a parent.
+*/
+QMP4Recorder::QMP4Recorder(QObject *parent):
+    QMediaObject(*new QMP4RecorderPrivate, parent, playerService())
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+    Q_D(QMP4Recorder);
+    d->provider = QMediaServiceProvider::defaultServiceProvider();
+    if (d->service == 0) {
+        
+    }else{
+        d->control = qobject_cast<QMP4RecorderControl*>(d->service->requestControl(QMP4RecorderControl_iid));
+        if (d->control != 0) {
+            connect(d->control, SIGNAL(mediaStatusChanged(QMP4Recorder::MediaStatus)),
+                    SLOT(_q_mediaStatusChanged(QMP4Recorder::MediaStatus)));
+        }
+    }
+}
+
+/*!
+    Destroys the QMP4Recorder object.
+*/
+QMP4Recorder::~QMP4Recorder()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Recorder);
+    if (d->service) {
+        if (d->control)
+            d->service->releaseControl(d->control);
+
+        d->provider->releaseService(d->service);
+    }
+}
+
+QMP4Recorder::State QMP4Recorder::state() const
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return d_func()->state;
+}
+
+QMP4Recorder::MediaStatus QMP4Recorder::mediaStatus() const
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return QMP4Recorder::UnknownMediaStatus;
+}
+
+QMP4Recorder::Error QMP4Recorder::error() const
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return d_func()->error;
+}
+
+QString QMP4Recorder::errorString() const
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return d_func()->errorString;
+}
+
+void QMP4Recorder::start()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Recorder);
+    d->control->start();
+}
+
+void QMP4Recorder::stop()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Recorder);
+    d->control->stop();
+}
+
+void QMP4Recorder::pause()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Recorder);
+    d->control->pause();
+}
+
+void QMP4Recorder::setUsrcPort(int usrcport)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Recorder);
+    d->control->setUsrcPort(usrcport);
+}
+
+void QMP4Recorder::setFSinkLocation(QString fsinklocation)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    Q_D(QMP4Recorder);
+    d->control->setFSinkLocation(fsinklocation);
+}
+
+void QMP4Recorder::componentComplete()
+{
+    // qDebug() << Q_FUNC_INFO;
+    Q_D(QMP4Recorder);
+    d->control->componentComplete();
+}
+
+#include "moc_qMP4Recorder.cpp"
+QT_END_NAMESPACE
+
diff --git a/src/multimedia/recording/qMP4Recorder.h b/src/multimedia/recording/qMP4Recorder.h
new file mode 100755
index 0000000..0cc167e
--- /dev/null
+++ b/src/multimedia/recording/qMP4Recorder.h
@@ -0,0 +1,134 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMP4RECORDER_H
+#define QMP4RECORDER_H
+
+#include <QtMultimedia/qmultimedia.h>
+#include <QtMultimedia/qmediaobject.h>
+#include <QtMultimedia/qmediaencodersettings.h>
+#include <QtMultimedia/qmediabindableinterface.h>
+#include <QtMultimedia/qmediaenumdebug.h>
+
+#include <QtCore/qpair.h>
+
+QT_BEGIN_NAMESPACE
+
+class QMP4RecorderPrivate;
+
+class Q_MULTIMEDIA_EXPORT QMP4Recorder : public QMediaObject
+{
+    Q_OBJECT
+    Q_PROPERTY(State state READ state NOTIFY stateChanged)
+    Q_PROPERTY(MediaStatus mediaStatus READ mediaStatus NOTIFY mediaStatusChanged)
+    Q_PROPERTY(QString error READ errorString)
+    
+    Q_ENUMS(MediaStatus)
+    Q_ENUMS(State)
+    Q_ENUMS(Error)
+
+public:
+    enum MediaStatus
+    {
+        UnknownMediaStatus,
+        NoMedia,
+        LoadingMedia,
+        LoadedMedia,
+        StalledMedia,
+        BufferingMedia,
+        BufferedMedia,
+        EndOfMedia,
+        InvalidMedia,
+        Active
+    };
+
+    enum State {
+        StoppedState,
+        StartedState,
+        PausedState
+    };
+
+    enum Error
+    {
+        NoError,
+        ResourceError,
+        FormatError,
+        NetworkError,
+        AccessDeniedError,
+        ServiceMissingError,
+        MediaIsPlaylist,
+        InputArgumentError,
+        InvalidRequestError
+    };
+
+    QMP4Recorder(QObject *parent = 0);
+    ~QMP4Recorder();
+    
+    State state() const;
+    MediaStatus mediaStatus() const;
+    Error error() const;
+    QString errorString() const;
+    
+
+public Q_SLOTS:
+    
+    void start();
+    void stop();
+    void pause();
+    void setUsrcPort(int);
+    void setFSinkLocation(QString);
+    void componentComplete();
+    
+Q_SIGNALS:
+    void stateChanged(QMP4Recorder::State);
+    void mediaStatusChanged(QMP4Recorder::MediaStatus);
+    
+private:
+    Q_DISABLE_COPY(QMP4Recorder)
+    Q_DECLARE_PRIVATE(QMP4Recorder)
+    Q_PRIVATE_SLOT(d_func(), void _q_stateChanged(QMP4Recorder::State))
+    Q_PRIVATE_SLOT(d_func(), void _q_mediaStatusChanged(QMP4Recorder::MediaStatus))
+    Q_PRIVATE_SLOT(d_func(), void _q_error(int, const QString &))
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QMP4Recorder::State)
+Q_DECLARE_METATYPE(QMP4Recorder::MediaStatus)
+Q_DECLARE_METATYPE(QMP4Recorder::Error)
+
+Q_MEDIA_ENUM_DEBUG(QMP4Recorder, State)
+Q_MEDIA_ENUM_DEBUG(QMP4Recorder, MediaStatus)
+Q_MEDIA_ENUM_DEBUG(QMP4Recorder, Error)
+
+#endif  // QRECORDER_H
diff --git a/src/multimedia/recording/recording.pri b/src/multimedia/recording/recording.pri
index 20ed99e..05f06e3 100644
--- a/src/multimedia/recording/recording.pri
+++ b/src/multimedia/recording/recording.pri
@@ -4,6 +4,7 @@ PUBLIC_HEADERS += \
     recording/qaudiorecorder.h \
     recording/qmediaencodersettings.h \
     recording/qmediarecorder.h \
+    recording/qMP4Recorder.h 
 
 PRIVATE_HEADERS += \
     recording/qmediarecorder_p.h \
@@ -11,4 +12,5 @@ PRIVATE_HEADERS += \
 SOURCES += \
     recording/qaudiorecorder.cpp \
     recording/qmediaencodersettings.cpp \
-    recording/qmediarecorder.cpp
+    recording/qmediarecorder.cpp \
+    recording/qMP4Recorder.cpp
diff --git a/src/plugins/alsa/asoundlib.h b/src/plugins/alsa/asoundlib.h
new file mode 100644
index 0000000..47f587c
--- /dev/null
+++ b/src/plugins/alsa/asoundlib.h
@@ -0,0 +1,2 @@
+#warning This header is deprecated, use <alsa/asoundlib.h> instead.
+#include <alsa/asoundlib.h>
diff --git a/src/plugins/gstreamer/H264Streaming/H264Streaming.json b/src/plugins/gstreamer/H264Streaming/H264Streaming.json
new file mode 100755
index 0000000..289d2a3
--- /dev/null
+++ b/src/plugins/gstreamer/H264Streaming/H264Streaming.json
@@ -0,0 +1,4 @@
+{
+    "Keys": ["gstreamerH264Streaming"],
+    "Services": ["org.qt-project.qt.H264Streaming"]
+}
diff --git a/src/plugins/gstreamer/H264Streaming/H264Streaming.pro b/src/plugins/gstreamer/H264Streaming/H264Streaming.pro
new file mode 100755
index 0000000..0e35cd1
--- /dev/null
+++ b/src/plugins/gstreamer/H264Streaming/H264Streaming.pro
@@ -0,0 +1,24 @@
+TARGET = gstH264Streaming
+
+PLUGIN_TYPE = mediaservice
+PLUGIN_CLASS_NAME = QGstreamerPlayerServicePlugin
+load(qt_plugin)
+
+include(../common.pri)
+
+INCLUDEPATH += $$PWD
+
+HEADERS += \
+    $$PWD/qgstreamerH264Streamingcontrol.h \
+    $$PWD/qgstreamerH264Streamingservice.h \
+    $$PWD/qgstreamerH264Streamingsession.h \
+    $$PWD/qgstreamerH264Streamingserviceplugin.h
+
+SOURCES += \
+    $$PWD/qgstreamerH264Streamingcontrol.cpp \
+    $$PWD/qgstreamerH264Streamingservice.cpp \
+    $$PWD/qgstreamerH264Streamingsession.cpp \
+    $$PWD/qgstreamerH264Streamingserviceplugin.cpp
+
+OTHER_FILES += \
+    H264Streaming.json
diff --git a/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingcontrol.cpp b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingcontrol.cpp
new file mode 100755
index 0000000..193f33d
--- /dev/null
+++ b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingcontrol.cpp
@@ -0,0 +1,492 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qgstreamerH264Streamingcontrol.h"
+#include "qgstreamerH264Streamingsession.h"
+
+#include <private/qmediaplaylistnavigator_p.h>
+#include <private/qmediaresourcepolicy_p.h>
+#include <private/qmediaresourceset_p.h>
+
+#include <QtCore/qdir.h>
+#include <QtCore/qsocketnotifier.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qdebug.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+
+//#define DEBUG_PLAYBIN
+
+QT_BEGIN_NAMESPACE
+
+QGstreamerH264StreamingControl::QGstreamerH264StreamingControl(QGstreamerH264StreamingSession *session, QObject *parent)
+    : QH264StreamingControl(parent)
+    , m_ownStream(false)
+    , m_session(session)
+    , m_userRequestedState(QH264Streaming::StoppedState)
+    , m_currentState(QH264Streaming::StoppedState)
+    , m_VideoState(QH264Streaming::StoppedState)
+    , m_mediaStatus(QH264Streaming::NoMedia)
+    , m_bufferProgress(-1)
+    , m_pendingSeekPosition(-1)
+    , m_setMediaPending(false)
+    , m_stream(0)
+{
+
+    m_resources = QMediaResourcePolicy::createResourceSet<QMediaPlayerResourceSetInterface>();
+    Q_ASSERT(m_resources);
+
+    connect(m_session, SIGNAL(positionChanged(qint64)),
+            this, SIGNAL(positionChanged(qint64)));
+    connect(m_session, SIGNAL(durationChanged(qint64)),
+            this, SIGNAL(durationChanged(qint64)));
+    connect(m_session, SIGNAL(stateChanged(QH264Streaming::State)),
+            this, SLOT(updateSessionState(QH264Streaming::State)));
+    connect(m_session, SIGNAL(videostateChanged(QH264Streaming::State)),
+            this, SLOT(updateVideoState(QH264Streaming::State)));
+    connect(m_session, SIGNAL(playbackFinished()),
+            this, SLOT(processEOS()));
+    connect(m_session, SIGNAL(seekableChanged(bool)),
+            this, SIGNAL(seekableChanged(bool)));
+    connect(m_session, SIGNAL(error(int,QString)),
+            this, SIGNAL(error(int,QString)));
+    connect(m_session, SIGNAL(invalidMedia()),
+            this, SLOT(handleInvalidMedia()));
+}
+
+QGstreamerH264StreamingControl::~QGstreamerH264StreamingControl()
+{
+
+    QMediaResourcePolicy::destroyResourceSet(m_resources);
+}
+
+void QGstreamerH264StreamingControl::setHdmiWidth(int hdmiwidth)
+{
+    m_session->setHdmiWidth(hdmiwidth);
+}
+
+void QGstreamerH264StreamingControl::setHdmiHeight(int hdmiheight)
+{
+    m_session->setHdmiHeight(hdmiheight);
+}
+
+void QGstreamerH264StreamingControl::setHdmiFormat(QString hdmiformat)
+{
+    m_session->setHdmiFormat(hdmiformat);
+}
+
+void QGstreamerH264StreamingControl::setEncBitrate(int encbitrate)
+{
+    m_session->setEncBitrate(encbitrate);
+}
+
+void QGstreamerH264StreamingControl::setNumPframes(int numpframes)
+{
+    m_session->setNumPframes(numpframes);
+}
+
+void QGstreamerH264StreamingControl::setNoReorder(bool noreorder)
+{
+    m_session->setNoReorder(noreorder);
+}
+
+void QGstreamerH264StreamingControl::setUdpPort(QString udpport)
+{
+    m_session->setUdpPort(udpport);
+}
+
+void QGstreamerH264StreamingControl::setUdpHost(QString udphost)
+{
+    m_session->setUdpHost(udphost);
+}
+
+void QGstreamerH264StreamingControl::setTransmit(bool transmit)
+{
+    m_session->setTransmit(transmit);
+}
+
+void QGstreamerH264StreamingControl::setVspm(bool vspm)
+{
+    m_session->setVspm(vspm);
+}
+
+void QGstreamerH264StreamingControl::setVspmDmabuf(bool vspmdmabuf)
+{
+    m_session->setVspmDmabuf(vspmdmabuf);
+}
+
+void QGstreamerH264StreamingControl::setVspmWidth(int vspmwidth)
+{
+    m_session->setVspmWidth(vspmwidth);
+}
+
+void QGstreamerH264StreamingControl::setVspmWidth1(int vspmwidth1)
+{
+    m_session->setVspmWidth(vspmwidth1);
+}
+
+void QGstreamerH264StreamingControl::setVspmHeight(int vspmheight)
+{
+    m_session->setVspmHeight(vspmheight);
+}
+
+void QGstreamerH264StreamingControl::setVspmHeight1(int vspmheight1)
+{
+    m_session->setVspmHeight1(vspmheight1);
+}
+
+void QGstreamerH264StreamingControl::setVspmFormat(QString vspmformat)
+{
+    m_session->setVspmFormat(vspmformat);
+}
+
+void QGstreamerH264StreamingControl::setWlsMaxLateness(int wlsmaxlateness)
+{
+    m_session->setWlsMaxLateness(wlsmaxlateness);
+}
+
+void QGstreamerH264StreamingControl::setWlsQos(bool wlsqos)
+{
+    m_session->setWlsQos(wlsqos);
+}
+
+void QGstreamerH264StreamingControl::setWlsPositionX(int wlspositionx)
+{
+    m_session->setWlsPositionX(wlspositionx);
+}
+
+void QGstreamerH264StreamingControl::setWlsPositionY(int wlspositiony)
+{
+    m_session->setWlsPositionY(wlspositiony);
+}
+
+void QGstreamerH264StreamingControl::setWlsOutWidth(int wlsoutwidth)
+{
+    m_session->setWlsOutWidth(wlsoutwidth);
+}
+
+void QGstreamerH264StreamingControl::setWlsOutHeight(int wlsoutheight)
+{
+    m_session->setWlsOutHeight(wlsoutheight);
+}
+
+void QGstreamerH264StreamingControl::componentComplete()
+{
+    m_session->componentComplete();
+    
+}
+
+QMediaPlayerResourceSetInterface* QGstreamerH264StreamingControl::resources() const
+{
+
+    return m_resources;
+}
+
+qint64 QGstreamerH264StreamingControl::position() const
+{
+
+    return m_session->position();
+}
+
+qint64 QGstreamerH264StreamingControl::duration() const
+{
+
+    return 0;
+}
+
+QH264Streaming::State QGstreamerH264StreamingControl::state() const
+{
+
+    return m_currentState;
+}
+
+QH264Streaming::MediaStatus QGstreamerH264StreamingControl::mediaStatus() const
+{
+
+    return m_mediaStatus;
+}
+
+int QGstreamerH264StreamingControl::bufferStatus() const
+{
+
+    if (m_bufferProgress == -1) {
+        return m_session->state() == QH264Streaming::StoppedState ? 0 : 100;
+    } else
+        return m_bufferProgress;
+}
+
+int QGstreamerH264StreamingControl::volume() const
+{
+
+    return 0;
+}
+
+bool QGstreamerH264StreamingControl::isMuted() const
+{
+
+    return FALSE;
+}
+
+bool QGstreamerH264StreamingControl::isSeekable() const
+{
+
+    return m_session->isSeekable();
+}
+
+QMediaTimeRange QGstreamerH264StreamingControl::availablePlaybackRanges() const
+{
+
+    QMediaTimeRange time;
+    return time;
+}
+
+qreal QGstreamerH264StreamingControl::playbackRate() const
+{
+
+    return 0.0;
+}
+
+void QGstreamerH264StreamingControl::setPlaybackRate(qreal rate)
+{
+
+}
+
+void QGstreamerH264StreamingControl::setPosition(qint64 pos)
+{
+
+}
+
+void QGstreamerH264StreamingControl::play()
+{
+
+#ifdef DEBUG_PLAYBIN
+    qDebug() << Q_FUNC_INFO;
+#endif
+
+    if(m_currentState == QH264Streaming::StoppedState && m_mediaStatus == QH264Streaming::BufferedMedia){
+        m_session->seek(0);
+        m_session->play();
+        m_currentState = QH264Streaming::PlayingState;
+        m_mediaStatus = QH264Streaming::BufferingMedia;
+        emit stateChanged(m_currentState);
+        emit mediaStatusChanged(m_mediaStatus);
+    }else if(m_currentState == QH264Streaming::PausedState && m_mediaStatus == QH264Streaming::BufferedMedia){
+        m_session->play();
+        m_currentState = QH264Streaming::PlayingState;
+        m_mediaStatus = QH264Streaming::BufferingMedia;
+        emit stateChanged(m_currentState);
+        emit mediaStatusChanged(m_mediaStatus);
+    }else{
+        playOrPause(QH264Streaming::PlayingState);
+    }
+    
+}
+
+void QGstreamerH264StreamingControl::pause()
+{
+
+#ifdef DEBUG_PLAYBIN
+    qDebug() << Q_FUNC_INFO;
+#endif
+    if (m_currentState != QH264Streaming::PausedState) {
+        m_currentState = QH264Streaming::PausedState;
+        m_mediaStatus = QH264Streaming::BufferedMedia;
+            m_session->pause();
+            emit stateChanged(m_currentState);
+            emit mediaStatusChanged(m_mediaStatus);
+    }
+
+}
+
+void QGstreamerH264StreamingControl::playOrPause(QH264Streaming::State newState)
+{
+
+    QH264Streaming::State oldState = m_currentState;
+
+    bool ok = false;
+
+    if (newState == QH264Streaming::PlayingState && m_pendingSeekPosition == -1){
+        ok = m_session->play();
+        m_mediaStatus = QH264Streaming::BufferingMedia;
+    }else{
+        ok = m_session->pause();
+    }
+
+    if (!ok)
+        newState = QH264Streaming::StoppedState;
+
+    m_currentState = newState;
+    
+    if(m_currentState != oldState){
+        emit stateChanged(m_currentState);
+        emit mediaStatusChanged(m_mediaStatus);
+    }
+
+}
+
+void QGstreamerH264StreamingControl::stop()
+{
+
+#ifdef DEBUG_PLAYBIN
+    qDebug() << Q_FUNC_INFO;
+#endif
+
+    if (m_currentState != QH264Streaming::StoppedState) {
+        m_currentState = QH264Streaming::StoppedState;
+        m_mediaStatus = QH264Streaming::BufferedMedia;
+            m_session->stop();
+            emit stateChanged(m_currentState);
+            emit mediaStatusChanged(m_mediaStatus);
+    }
+}
+
+void QGstreamerH264StreamingControl::setVolume(int volume)
+{
+
+}
+
+void QGstreamerH264StreamingControl::setMuted(bool muted)
+{
+
+}
+
+QMediaContent QGstreamerH264StreamingControl::media() const
+{
+
+    return m_currentResource;
+}
+
+const QIODevice *QGstreamerH264StreamingControl::mediaStream() const
+{
+
+    return m_stream;
+}
+
+void QGstreamerH264StreamingControl::setMedia(const QMediaContent &content, QIODevice *stream)
+{
+
+#ifdef DEBUG_PLAYBIN
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_currentState = QH264Streaming::StoppedState;
+    QMediaContent oldMedia = m_currentResource;
+    m_setMediaPending = false;
+    
+    QNetworkRequest request;
+    
+    m_currentResource = content;
+    request = content.canonicalRequest();
+    m_session->loadFromUri(request);
+    
+    if (!request.url().isEmpty()) {
+        m_mediaStatus = QH264Streaming::LoadingMedia;
+        // m_session->pause();
+    } else {
+        m_mediaStatus = QH264Streaming::NoMedia;
+    }
+}
+
+bool QGstreamerH264StreamingControl::isAudioAvailable() const
+{
+
+    return FALSE;
+}
+
+bool QGstreamerH264StreamingControl::isVideoAvailable() const
+{
+
+    return FALSE;
+}
+
+void QGstreamerH264StreamingControl::updateSessionState(QH264Streaming::State state)
+{
+
+    
+    if(state == QH264Streaming::PausedState && m_mediaStatus == QH264Streaming::LoadingMedia){
+        m_mediaStatus = QH264Streaming::LoadedMedia;
+    }
+    if (state == QH264Streaming::StoppedState) {
+        m_currentState = QH264Streaming::StoppedState;
+    }
+
+    if (state == QH264Streaming::PausedState && m_currentState != QH264Streaming::StoppedState && m_mediaStatus == QH264Streaming::EndOfMedia) {
+        if (m_pendingSeekPosition != -1 && m_session->isSeekable()) {
+            m_session->seek(0);
+        }
+    
+        if (m_currentState == QH264Streaming::PlayingState){
+            m_session->play();
+            m_currentState = QH264Streaming::PlayingState;
+            m_mediaStatus = QH264Streaming::BufferingMedia;
+            emit stateChanged(m_currentState);
+            emit mediaStatusChanged(m_mediaStatus);
+        }
+    }
+}
+
+void QGstreamerH264StreamingControl::updateVideoState(QH264Streaming::State state)
+{
+    if (state == QH264Streaming::VideoPlaying) {
+        m_VideoState = QH264Streaming::VideoPlaying;
+        emit stateChanged(m_VideoState);
+    }
+}
+
+void QGstreamerH264StreamingControl::processEOS()
+{
+
+    m_mediaStatus = QH264Streaming::EndOfMedia;
+    m_pendingSeekPosition = 0;
+    emit positionChanged(position());
+    m_session->endOfMediaReset();
+
+    if (m_currentState != QH264Streaming::StoppedState) {
+        m_currentState = QH264Streaming::StoppedState;
+    }
+
+    emit stateChanged(m_currentState);
+    emit mediaStatusChanged(m_mediaStatus);
+}
+
+void QGstreamerH264StreamingControl::handleInvalidMedia()
+{
+
+    m_mediaStatus = QH264Streaming::InvalidMedia;
+    m_currentState = QH264Streaming::StoppedState;
+    m_setMediaPending = true;
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingcontrol.h b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingcontrol.h
new file mode 100755
index 0000000..aee65d0
--- /dev/null
+++ b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingcontrol.h
@@ -0,0 +1,147 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGSTREAMERH264STREAMINGCONTROL_H
+#define QGSTREAMERH264STREAMINGCONTROL_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qstack.h>
+
+#include <qH264Streamingcontrol.h>
+#include <qH264Streaming.h>
+
+#include <limits.h>
+
+QT_BEGIN_NAMESPACE
+
+class QMediaPlayerResourceSetInterface;
+
+class QMediaPlaylist;
+class QMediaPlaylistNavigator;
+class QSocketNotifier;
+
+class QGstreamerH264StreamingSession;
+class QGstreamerH264StreamingService;
+
+class QGstreamerH264StreamingControl : public QH264StreamingControl
+{
+    Q_OBJECT
+
+public:
+    QGstreamerH264StreamingControl(QGstreamerH264StreamingSession *session, QObject *parent = 0);
+    ~QGstreamerH264StreamingControl();
+
+    QMediaTimeRange availablePlaybackRanges() const;
+    int bufferStatus() const;
+    qint64 duration() const;
+    bool isAudioAvailable() const;
+    bool isMuted() const;
+    bool isSeekable() const;
+    bool isVideoAvailable() const;
+    QMediaContent media() const;
+    QH264Streaming::MediaStatus mediaStatus() const;
+    const QIODevice *mediaStream() const;
+    void pause();
+    void play();
+    qreal playbackRate() const;
+    qint64 position() const;
+    void setMedia(const QMediaContent&, QIODevice *);
+    void setMuted(bool muted);
+    void setPlaybackRate(qreal rate);
+    void setPosition(qint64 pos);
+    void setVolume(int volume);
+    QH264Streaming::State state() const;
+    void stop();
+    int volume() const;
+    
+    
+    QMediaPlayerResourceSetInterface* resources() const;
+    
+    void setHdmiWidth(int hdmiwidth);
+    void setHdmiHeight(int hdmiheight);
+    void setHdmiFormat(QString hdmiformat);
+    void setEncBitrate(int encbitrate);
+    void setNumPframes(int numpframes);
+    void setNoReorder(bool noreorder);
+    void setUdpPort(QString udpport);
+    void setUdpHost(QString udphost);
+    void setTransmit(bool transmit);
+    void setVspm(bool vspm);
+    void setVspmDmabuf(bool vspmdmabuf);
+    void setVspmWidth1(int vspmwidth1);
+    void setVspmWidth(int vspmwidth);
+    void setVspmHeight(int vspmheight);
+    void setVspmHeight1(int vspmheight1);
+    void setVspmFormat(QString vspmformat);
+    void setWlsMaxLateness(int wlsmaxlateness);
+    void setWlsQos(bool wlsqos);
+    void setWlsPositionX(int wlspositionx);
+    void setWlsPositionY(int wlspositiony);
+    void setWlsOutWidth(int wlsoutwidth);
+    void setWlsOutHeight(int wlsoutheight);
+    void componentComplete();
+
+public Q_SLOTS:
+
+
+
+private Q_SLOTS:
+    void updateSessionState(QH264Streaming::State state);
+    void updateVideoState(QH264Streaming::State state);
+    void processEOS();
+    void handleInvalidMedia();
+
+private:
+    void playOrPause(QH264Streaming::State state);
+
+    bool m_ownStream;
+    QGstreamerH264StreamingSession *m_session;
+    QH264Streaming::State m_userRequestedState;
+    QH264Streaming::State m_currentState;
+    QH264Streaming::State m_VideoState;
+    QH264Streaming::MediaStatus m_mediaStatus;
+    QStack<QH264Streaming::State> m_stateStack;
+    QStack<QH264Streaming::MediaStatus> m_mediaStatusStack;
+
+    int m_bufferProgress;
+    qint64 m_pendingSeekPosition;
+    bool m_setMediaPending;
+    QMediaContent m_currentResource;
+    QIODevice *m_stream;
+
+    QMediaPlayerResourceSetInterface *m_resources;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingservice.cpp b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingservice.cpp
new file mode 100755
index 0000000..f4cff6e
--- /dev/null
+++ b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingservice.cpp
@@ -0,0 +1,73 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtCore/qvariant.h>
+#include <QtCore/qdebug.h>
+
+#include "qgstreamerH264Streamingservice.h"
+#include "qgstreamerH264Streamingcontrol.h"
+#include "qgstreamerH264Streamingsession.h"
+
+
+#include <private/qmediaplaylistnavigator_p.h>
+#include <qmediaplaylist.h>
+#include <private/qmediaresourceset_p.h>
+
+QT_BEGIN_NAMESPACE
+
+QGstreamerH264StreamingService::QGstreamerH264StreamingService(QObject *parent):
+     QMediaService(parent)
+{
+    m_session = new QGstreamerH264StreamingSession(this);
+    m_control = new QGstreamerH264StreamingControl(m_session, this);
+}
+
+QGstreamerH264StreamingService::~QGstreamerH264StreamingService()
+{
+}
+
+QMediaControl *QGstreamerH264StreamingService::requestControl(const char *name)
+{
+    if (qstrcmp(name,QH264StreamingControl_iid) == 0){
+        return m_control;
+    }
+
+    return 0;
+}
+
+void QGstreamerH264StreamingService::releaseControl(QMediaControl *control)
+{
+
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingservice.h b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingservice.h
new file mode 100755
index 0000000..1d4ba43
--- /dev/null
+++ b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingservice.h
@@ -0,0 +1,68 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGSTREAMERH264STREAMINGSERVICE_H
+#define QGSTREAMERH264STREAMINGSERVICE_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qiodevice.h>
+
+#include <qmediaservice.h>
+
+QT_BEGIN_NAMESPACE
+class QMediaPlayerControl;
+class QMediaPlaylist;
+class QMediaPlaylistNavigator;
+
+class QGstreamerMetaData;
+class QGstreamerH264StreamingControl;
+class QGstreamerH264StreamingSession;
+
+class QGstreamerH264StreamingService : public QMediaService
+{
+    Q_OBJECT
+public:
+    QGstreamerH264StreamingService(QObject *parent = 0);
+    ~QGstreamerH264StreamingService();
+
+    QMediaControl *requestControl(const char *name);
+    void releaseControl(QMediaControl *control);
+
+private:
+    QGstreamerH264StreamingControl *m_control;
+    QGstreamerH264StreamingSession *m_session;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingserviceplugin.cpp b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingserviceplugin.cpp
new file mode 100755
index 0000000..273811e
--- /dev/null
+++ b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingserviceplugin.cpp
@@ -0,0 +1,195 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtCore/qstring.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/QDir>
+#include <QtCore/QDebug>
+
+#include "qgstreamerH264Streamingserviceplugin.h"
+
+//#define QT_SUPPORTEDMIMETYPES_DEBUG
+
+#include "qgstreamerH264Streamingservice.h"
+#include <private/qgstutils_p.h>
+
+QMediaService* QGstreamerH264StreamingServicePlugin::create(const QString &key)
+{
+
+    QGstUtils::initializeGst();
+
+    if (key == QLatin1String(Q_MEDIASERVICE_H264STREAMING))
+        return new QGstreamerH264StreamingService;
+
+    qWarning() << "Gstreamer service plugin: unsupported key:" << key;
+    return 0;
+}
+
+void QGstreamerH264StreamingServicePlugin::release(QMediaService *service)
+{
+
+    delete service;
+}
+
+QMediaServiceProviderHint::Features QGstreamerH264StreamingServicePlugin::supportedFeatures(
+        const QByteArray &service) const
+{
+
+    if (service == Q_MEDIASERVICE_MEDIAPLAYER)
+        return
+#ifdef HAVE_GST_APPSRC
+                QMediaServiceProviderHint::StreamPlayback |
+#endif
+                QMediaServiceProviderHint::VideoSurface;
+    else
+        return QMediaServiceProviderHint::Features();
+}
+
+QMultimedia::SupportEstimate QGstreamerH264StreamingServicePlugin::hasSupport(const QString &mimeType,
+                                                                     const QStringList &codecs) const
+{
+
+    if (m_supportedMimeTypeSet.isEmpty())
+        updateSupportedMimeTypes();
+
+    return QGstUtils::hasSupport(mimeType, codecs, m_supportedMimeTypeSet);
+}
+
+void QGstreamerH264StreamingServicePlugin::updateSupportedMimeTypes() const
+{
+
+    //enumerate supported mime types
+    gst_init(NULL, NULL);
+
+    GList *plugins, *orig_plugins;
+#if GST_CHECK_VERSION(1,0,0)
+ orig_plugins = plugins = gst_registry_get_plugin_list (gst_registry_get());
+#else
+    orig_plugins = plugins = gst_default_registry_get_plugin_list ();
+#endif
+
+    while (plugins) {
+        GList *features, *orig_features;
+
+        GstPlugin *plugin = (GstPlugin *) (plugins->data);
+        plugins = g_list_next (plugins);
+
+#if GST_CHECK_VERSION(1,0,0)
+ if (GST_OBJECT_FLAG_IS_SET(plugin, GST_PLUGIN_FLAG_BLACKLISTED))
+ continue;
+#else
+        if (plugin->flags & (1<<1)) //GST_PLUGIN_FLAG_BLACKLISTED
+            continue;
+#endif
+
+        // orig_features = features = gst_registry_get_feature_list_by_plugin(gst_registry_get_default (),
+                                                                        // plugin->desc.name);
+  orig_features = features = gst_registry_get_feature_list_by_plugin(gst_registry_get(), gst_plugin_get_name(plugin));
+        while (features) {
+            if (!G_UNLIKELY(features->data == NULL)) {
+                GstPluginFeature *feature = GST_PLUGIN_FEATURE(features->data);
+                if (GST_IS_ELEMENT_FACTORY (feature)) {
+                    GstElementFactory *factory = GST_ELEMENT_FACTORY(gst_plugin_feature_load(feature));
+                    if (factory
+#if GST_CHECK_VERSION(1,0,0)
+ && (qstrcmp(gst_element_factory_get_metadata(factory, GST_ELEMENT_METADATA_KLASS), "Codec/Decoder/Audio") == 0
+ || qstrcmp(gst_element_factory_get_metadata(factory, GST_ELEMENT_METADATA_KLASS),"Codec/Decoder/Video") == 0
+ || qstrcmp(gst_element_factory_get_metadata(factory, GST_ELEMENT_METADATA_KLASS), "Codec/Demux") == 0 )
+#else
+ && (qstrcmp(factory->details.klass, "Codec/Decoder/Audio") == 0
+                          || qstrcmp(factory->details.klass, "Codec/Decoder/Video") == 0
+ || qstrcmp(factory->details.klass, "Codec/Demux") == 0 )
+#endif
+ ) {
+ const GList *pads = gst_element_factory_get_static_pad_templates(factory);
+                        while (pads) {
+                            GstStaticPadTemplate *padtemplate = (GstStaticPadTemplate*)(pads->data);
+                            pads = g_list_next (pads);
+                            if (padtemplate->direction != GST_PAD_SINK)
+                                continue;
+                            if (padtemplate->static_caps.string) {
+                                GstCaps *caps = gst_static_caps_get(&padtemplate->static_caps);
+                                if (!gst_caps_is_any (caps) && ! gst_caps_is_empty (caps)) {
+                                    for (guint i = 0; i < gst_caps_get_size(caps); i++) {
+                                        GstStructure *structure = gst_caps_get_structure(caps, i);
+                                        QString nameLowcase = QString(gst_structure_get_name (structure)).toLower();
+
+                                        m_supportedMimeTypeSet.insert(nameLowcase);
+                                        if (nameLowcase.contains("mpeg")) {
+                                            //Because mpeg version number is only included in the detail
+                                            //description,  it is necessary to manually extract this information
+                                            //in order to match the mime type of mpeg4.
+                                            const GValue *value = gst_structure_get_value(structure, "mpegversion");
+                                            if (value) {
+                                                gchar *str = gst_value_serialize (value);
+                                                QString versions(str);
+                                                QStringList elements = versions.split(QRegExp("\\D+"), QString::SkipEmptyParts);
+                                                foreach (const QString &e, elements)
+                                                    m_supportedMimeTypeSet.insert(nameLowcase + e);
+                                                g_free (str);
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        gst_object_unref (factory);
+                    }
+                } else if (GST_IS_TYPE_FIND_FACTORY(feature)) {
+                    QString name(gst_plugin_feature_get_name(feature));
+                    if (name.contains('/')) //filter out any string without '/' which is obviously not a mime type
+                        m_supportedMimeTypeSet.insert(name.toLower());
+                }
+            }
+            features = g_list_next (features);
+        }
+        gst_plugin_feature_list_free (orig_features);
+    }
+    gst_plugin_list_free (orig_plugins);
+
+#if defined QT_SUPPORTEDMIMETYPES_DEBUG
+    QStringList list = m_supportedMimeTypeSet.toList();
+    list.sort();
+    if (qgetenv("QT_DEBUG_PLUGINS").toInt() > 0) {
+        foreach (const QString &type, list)
+            qDebug() << type;
+    }
+#endif
+}
+
+QStringList QGstreamerH264StreamingServicePlugin::supportedMimeTypes() const
+{
+
+    return QStringList();
+}
+
diff --git a/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingserviceplugin.h b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingserviceplugin.h
new file mode 100755
index 0000000..37869ec
--- /dev/null
+++ b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingserviceplugin.h
@@ -0,0 +1,72 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#ifndef QGSTREAMERH264STREAMINGSERVICEPLUGIN_H
+#define QGSTREAMERH264STREAMINGSERVICEPLUGIN_H
+
+#include <qmediaserviceproviderplugin.h>
+#include <QtCore/qset.h>
+#include <QtCore/QObject>
+
+QT_BEGIN_NAMESPACE
+
+
+class QGstreamerH264StreamingServicePlugin
+    : public QMediaServiceProviderPlugin
+    , public QMediaServiceFeaturesInterface
+    , public QMediaServiceSupportedFormatsInterface
+{
+    Q_OBJECT
+    Q_INTERFACES(QMediaServiceFeaturesInterface)
+    Q_INTERFACES(QMediaServiceSupportedFormatsInterface)
+    Q_PLUGIN_METADATA(IID "org.qt-project.qt.mediaserviceproviderfactory/5.0" FILE "H264Streaming.json")
+public:
+    QMediaService* create(QString const& key);
+    void release(QMediaService *service);
+
+    QMediaServiceProviderHint::Features supportedFeatures(const QByteArray &service) const;
+
+    QMultimedia::SupportEstimate hasSupport(const QString &mimeType, const QStringList& codecs) const;
+    QStringList supportedMimeTypes() const;
+
+private:
+    void updateSupportedMimeTypes() const;
+
+    mutable QSet<QString> m_supportedMimeTypeSet; //for fast access
+};
+
+QT_END_NAMESPACE
+
+#endif // QGSTREAMERPLAYERSERVICEPLUGIN_H
+
diff --git a/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingsession.cpp b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingsession.cpp
new file mode 100755
index 0000000..cd12864
--- /dev/null
+++ b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingsession.cpp
@@ -0,0 +1,1271 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qgstreamerH264Streamingsession.h"
+#include <private/qgstreamerbushelper_p.h>
+
+#include <private/qgstreameraudioprobecontrol_p.h>
+#include <private/qgstreamervideoprobecontrol_p.h>
+#include <private/qgstreamervideorendererinterface_p.h>
+#include <private/gstvideoconnector_p.h>
+#include <private/qgstutils_p.h>
+#include <private/playlistfileparser_p.h>
+#include <private/qgstutils_p.h>
+
+#include <gst/gstvalue.h>
+#include <gst/base/gstbasesrc.h>
+
+#include <QtMultimedia/qmediametadata.h>
+#include <QtCore/qdatetime.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/qsize.h>
+#include <QtCore/qtimer.h>
+#include <QtCore/qbasictimer.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/qdir.h>
+#include <QtCore/qstandardpaths.h>
+#include <unistd.h>
+#define DEBUG_PLAYBIN
+#define DEBUG_VO_BIN_DUMP
+#define MODIFY_QT_FPS
+
+QT_BEGIN_NAMESPACE
+
+#ifdef MODIFY_QT_FPS
+#include <sys/time.h>
+#include "gst/gstelement.h"
+#include "gst/gstpad.h"
+
+int timeval_subtract (GTimeVal *, GTimeVal *, GTimeVal *);
+void alarm_handler (int);
+static gboolean cb_have_data_sink (GstPad *, GstBuffer *, gpointer);
+
+GTimeVal start_time;
+GTimeVal end_time;
+GTimeVal diff_time;
+
+gulong count=0;
+gulong past_count=0;
+struct itimerval val;
+
+QByteArray FPS_env;
+
+int
+timeval_subtract (GTimeVal *result,
+				  GTimeVal *x,
+				  GTimeVal *y)
+{
+	/* Perform the carry for the later subtraction by updating y. */
+	if (x->tv_usec < y->tv_usec) {
+		int nsec = (y->tv_usec - x->tv_usec) / 1000000 + 1;
+		y->tv_usec -= 1000000 * nsec;
+		y->tv_sec += nsec;
+	}
+	if (x->tv_usec - y->tv_usec > 1000000) {
+		int nsec = (x->tv_usec - y->tv_usec) / 1000000;
+		y->tv_usec += 1000000 * nsec;
+		y->tv_sec -= nsec;
+	}
+
+	/* Compute the time remaining to wait.
+	tv_usec is certainly positive. */
+	result->tv_sec = x->tv_sec - y->tv_sec;
+	result->tv_usec = x->tv_usec - y->tv_usec;
+
+	/* Return 1 if result is negative. */
+	return x->tv_sec < y->tv_sec;
+}
+
+void
+alarm_handler(int)
+{
+	guint framesinsec = count-past_count;
+	past_count = count;
+
+	qDebug() << "FPS:"
+			 << (float)(framesinsec/val.it_interval.tv_sec)
+			 << "fps";
+}
+
+static gboolean
+cb_have_data_sink (GstPad *,
+				   GstBuffer *,
+				   gpointer)
+{
+	count = count + 1;
+	return TRUE;
+}
+
+#endif	//MODIFY_QT_FPS
+
+GstElement *rtsp_bin;
+GstBus *rtsp_bus;
+
+static void on_pad_added (GstElement *element, GstPad *pad, gpointer data)
+{
+	GstPad *sinkpad;
+	GstElement *decoder = (GstElement *) data;
+	GstCaps *caps;
+	GstStructure *str;
+
+	/*link this pad with decoder sink pad*/
+
+	sinkpad = gst_element_get_static_pad (decoder, "sink");
+
+	if (GST_PAD_IS_LINKED(sinkpad))
+	{
+		g_object_unref(sinkpad);
+		return;
+	}
+
+	/*check media type*/
+	caps = gst_pad_query_caps (pad, NULL);
+	str = gst_caps_get_structure(caps, 0);
+	gst_caps_unref(caps);
+	gst_pad_link (pad, sinkpad);
+
+	gst_object_unref (sinkpad);
+}
+
+static gboolean
+timeout (GstRTSPServer * server, gboolean ignored)
+{
+    GstRTSPSessionPool *pool;
+
+    pool = gst_rtsp_server_get_session_pool (server);
+    gst_rtsp_session_pool_cleanup (pool);
+    g_object_unref (pool);
+
+    return TRUE;
+}
+
+gboolean rtsp_bus_cb(GstBus *bus, GstMessage *message, QObject* class_pointer)
+{
+	Q_UNUSED(bus);
+	QGstreamerMessage msg(message);
+	QMetaObject::invokeMethod(class_pointer, "processBusMessage1", Qt::QueuedConnection, Q_ARG(QGstreamerMessage, msg));
+}
+
+static void
+media_constructed (GstRTSPMediaFactory * factory, GstRTSPMedia * media,
+    QObject * class_pointer)
+{
+  guint i, n_streams;
+
+  /* Config for multicast */
+  n_streams = gst_rtsp_media_n_streams (media);
+
+  /* create the element from factorry */
+  rtsp_bin = GST_RTSP_MEDIA_FACTORY_GET_CLASS(factory)->create_pipeline (factory, media);
+
+  rtsp_bus = gst_element_get_bus (rtsp_bin);
+  guint ret = gst_bus_add_watch (rtsp_bus, (GstBusFunc) rtsp_bus_cb, class_pointer);
+  if (rtsp_bin && rtsp_bus && (ret > 0)) {
+	printf ("Connecting....\n");
+	QMetaObject::invokeMethod(class_pointer, "rtspConnected", Qt::AutoConnection);
+  }
+  
+  for (i = 0; i < n_streams; i++) {
+    GstRTSPAddressPool *pool;
+    GstRTSPStream *stream;
+    gchar *min, *max;
+
+    stream = gst_rtsp_media_get_stream (media, i);
+
+    /* make a new address pool */
+    pool = gst_rtsp_address_pool_new ();
+
+    min = g_strdup_printf ("192.168.1.%d", (2 * i) + 1);
+    max = g_strdup_printf ("192.168.1.%d", (2 * i) + 2);
+    gst_rtsp_address_pool_add_range (pool, min, max,
+        5000 + (10 * i), 5010 + (10 * i), 1);
+    g_free (min);
+    g_free (max);
+
+    gst_rtsp_stream_set_address_pool (stream, pool);
+    g_object_unref (pool);
+  }
+}
+
+QGstreamerH264StreamingSession::QGstreamerH264StreamingSession(QObject *parent)
+    :QObject(parent),
+     m_state(QH264Streaming::StoppedState),
+     m_videostate(QH264Streaming::StoppedState),
+     m_busHelper(0),
+     m_playbin(0),
+     m_bus(0),
+     m_playbackRate(1.0),
+     m_seekable(false),
+     m_lastPosition(0),
+     m_duration(-1),
+     m_durationQueries(0),
+     m_sourceType(UnknownSrc),
+     m_everPlayed(false),
+     m_isPlaylist(false),
+     m_hdmi_width(-1),
+     m_hdmi_height(-1),
+     m_hdmi_format("NV12"),
+     m_enc_bitrate(-1),
+     m_num_pframes(-1),
+     m_no_reorder(false),
+     m_udp_port("1234"),
+     m_udp_host("192.168.0.30"),
+     m_vspm(false),
+     m_vspm_dmabuf_use(false),
+     m_vspm_width(-1),
+     m_vspm_width1(-1),
+     m_vspm_height(-1),
+     m_vspm_height1(-1),
+     m_vspm_format("NV12"),
+     m_wls_max_lateness(0),
+     m_wls_qos(true),
+     m_wls_position_x(-1),
+     m_wls_position_y(-1),
+     m_wls_out_width(-1),
+     m_wls_out_height(-1),
+     notFirstRun(false),
+     isFirstRemove(false),
+     isTeePadAdd(false)
+{
+    count = 0 ;
+
+    m_playbin = gst_pipeline_new ("H264Streaming");
+    parser = gst_element_factory_make ("h264parse","h264-parse");
+    parser1 = gst_element_factory_make ("h264parse","h264-parse1");
+    filter = gst_element_factory_make ("vspmfilter","vspm-filter");
+    filter1 = gst_element_factory_make ("vspmfilter","vspm-filter1");
+    encoder = gst_element_factory_make ("omxh264enc","omx-encoder");
+    decoder = gst_element_factory_make ("omxh264dec","omx-decoder");
+    videosink = gst_element_factory_make ("waylandsink","video-output");
+    capfilter_vspm = gst_element_factory_make("capsfilter", "caps-filter");
+    capfilter_vspm1 = gst_element_factory_make("capsfilter", "caps-filter1");
+    videoIdentity_parse = gst_element_factory_make("capsfilter", NULL);
+    videoIdentity_depay = gst_element_factory_make("capsfilter", "caps-filter2");
+    depay = gst_element_factory_make("rtph264depay", "rtp-depay");
+    pay = gst_element_factory_make("rtph264pay", "rtp-pay");
+    udp_src = gst_element_factory_make("udpsrc", "udp-src");
+    udp_sink = gst_element_factory_make("udpsink", "udp-sink");
+    tee = gst_element_factory_make ("tee", "video-tee");
+
+    g_object_set (G_OBJECT (pay), "pt", 96, NULL);
+    g_object_set (G_OBJECT (pay), "config-interval", 3, NULL);
+    g_object_set (G_OBJECT (pay), "mtu", 9000, NULL);
+    filtercaps_depay = gst_caps_new_simple ("video/x-h264",
+                        "framerate", GST_TYPE_FRACTION, 30, 1,
+                        NULL);
+    g_object_set (G_OBJECT (videoIdentity_depay), "caps", filtercaps_depay, NULL);
+    g_object_set (G_OBJECT (encoder), "target-bitrate", m_enc_bitrate, NULL);
+    g_object_set (G_OBJECT (encoder), "num-p-frames", m_num_pframes, NULL);
+    filtercaps_parse = gst_caps_new_simple ("video/x-h264",
+                        "stream-format", G_TYPE_STRING, "avc",
+                        "alignment", G_TYPE_STRING, "au",
+                        NULL);
+    g_object_set (G_OBJECT (videoIdentity_parse), "caps", filtercaps_parse, NULL);
+    g_object_set (G_OBJECT (udp_sink), "port", 5000, NULL);
+    g_object_set (G_OBJECT (udp_sink), "async", FALSE, NULL);
+
+    m_bus = gst_element_get_bus(m_playbin);
+    m_busHelper = new QGstreamerBusHelper(m_bus, this);
+    m_busHelper->installMessageFilter(this);
+}
+
+QGstreamerH264StreamingSession::~QGstreamerH264StreamingSession()
+{
+    if (m_playbin) {
+		gst_element_send_event (m_playbin, gst_event_new_eos ());
+        stop();
+
+            delete m_busHelper;
+            gst_object_unref(GST_OBJECT(m_bus));
+            gst_object_unref(GST_OBJECT(m_playbin));
+    }
+
+	if (rtsp_bin) {
+		gst_element_send_event (rtsp_bin, gst_event_new_eos ());
+		gst_object_unref(GST_OBJECT(rtsp_bus));
+        gst_element_set_state(rtsp_bin, GST_STATE_NULL);
+		gst_object_unref(GST_OBJECT(rtsp_bin));
+	}
+}
+
+void QGstreamerH264StreamingSession::setHdmiWidth(int hdmiwidth)
+{
+    m_hdmi_width = hdmiwidth;
+}
+
+void QGstreamerH264StreamingSession::setHdmiHeight(int hdmiheight)
+{
+    m_hdmi_height = hdmiheight;
+}
+
+void QGstreamerH264StreamingSession::setHdmiFormat(QString hdmiformat)
+{
+    m_hdmi_format = hdmiformat;
+}
+
+void QGstreamerH264StreamingSession::setEncBitrate(int encbitrate)
+{
+    m_enc_bitrate = encbitrate;
+    g_object_set (G_OBJECT (encoder), "target-bitrate", m_enc_bitrate, NULL);
+}
+
+void QGstreamerH264StreamingSession::setNumPframes(int numpframes)
+{
+    m_num_pframes = numpframes;
+    g_object_set (G_OBJECT (encoder), "num-p-frames", m_num_pframes, NULL);
+}
+
+void QGstreamerH264StreamingSession::setNoReorder(bool noreorder)
+{
+    m_no_reorder = noreorder;
+}
+
+void QGstreamerH264StreamingSession::setUdpPort(QString udpport)
+{
+    m_udp_port = udpport;
+    GstStateChangeReturn state;
+    
+    QByteArray p = m_udp_port.toLocal8Bit();
+    char *udpsrc_port = p.data();
+    streaming_src_cap = gst_caps_new_simple ("application/x-rtp", NULL);
+
+	state = gst_element_get_state(m_playbin, &currentState, &pending, GST_CLOCK_TIME_NONE);	
+	if (currentState == GST_STATE_PLAYING) {
+		gst_element_set_state (udp_src, GST_STATE_PAUSED);
+		gst_element_set_state (udp_src, GST_STATE_NULL);
+
+		g_object_set (G_OBJECT (udp_src), "port",atoi(udpsrc_port), NULL);
+		g_object_set (G_OBJECT (udp_src), "caps", streaming_src_cap, NULL);
+		gst_element_set_state (udp_src, GST_STATE_PLAYING);
+	} else {
+		g_object_set (G_OBJECT (udp_src), "port",atoi(udpsrc_port), NULL);
+		g_object_set (G_OBJECT (udp_src), "caps", streaming_src_cap, NULL);
+	}
+}
+
+void QGstreamerH264StreamingSession::setUdpHost(QString udphost)
+{
+    //m_udp_host = udphost;
+    //QByteArray h = m_udp_host.toLocal8Bit();
+    //char *udpsink_host = h.data();
+	// For PC streaming
+    // g_object_set (G_OBJECT (udp_sink), "host", udpsink_host, NULL);
+	// For RTSP_SERVER
+    g_object_set (G_OBJECT (udp_sink), "host", "127.0.0.1", NULL);
+}
+
+void QGstreamerH264StreamingSession::setTransmit(bool transmit)
+{
+    m_transmit = transmit;
+    if (m_transmit)
+        g_object_set (G_OBJECT (decoder), "no-copy", TRUE ,NULL);
+}
+
+void QGstreamerH264StreamingSession::setVspm(bool vspm)
+{
+    m_vspm = vspm;
+}
+
+void QGstreamerH264StreamingSession::setVspmDmabuf(bool vspmdmabuf)
+{
+    m_vspm_dmabuf_use = vspmdmabuf;
+    if(m_vspm_dmabuf_use)
+        g_object_set (G_OBJECT (filter), "dmabuf-use", TRUE, NULL);
+    else
+        g_object_set (G_OBJECT (filter), "dmabuf-use", FALSE, NULL);
+}
+
+void QGstreamerH264StreamingSession::setVspmWidth(int vspmwidth)
+{
+    m_vspm_width = vspmwidth;
+    QByteArray f = m_vspm_format.toLocal8Bit();
+    char *vspm_format = f.data();
+    filtercaps_vspm = gst_caps_new_simple ("video/x-raw",
+                                "width", G_TYPE_INT, m_vspm_width,
+                                "height", G_TYPE_INT, m_vspm_height,
+                                "format", G_TYPE_STRING, vspm_format,
+                                NULL);
+    g_object_set (G_OBJECT (capfilter_vspm), "caps", filtercaps_vspm, NULL);
+}
+
+void QGstreamerH264StreamingSession::setVspmWidth1(int vspmwidth1)
+{
+    m_vspm_width1 = vspmwidth1;
+    QByteArray f = m_vspm_format.toLocal8Bit();
+    char *vspm_format = f.data();
+    filtercaps_vspm1 = gst_caps_new_simple ("video/x-raw",
+                                "width", G_TYPE_INT, m_vspm_width1,
+                                "height", G_TYPE_INT, m_vspm_height1,
+                                "format", G_TYPE_STRING, "NV12",
+                                NULL);
+    g_object_set (G_OBJECT (capfilter_vspm1), "caps", filtercaps_vspm1, NULL);
+    g_object_set (G_OBJECT(filter1), "outbuf-alloc", TRUE, NULL);
+}
+
+void QGstreamerH264StreamingSession::setVspmHeight(int vspmheight)
+{
+    m_vspm_height = vspmheight;
+}
+
+void QGstreamerH264StreamingSession::setVspmHeight1(int vspmheight1)
+{
+    m_vspm_height1 = vspmheight1;
+}
+
+void QGstreamerH264StreamingSession::setVspmFormat(QString vspmformat)
+{
+    m_vspm_format = vspmformat;
+}
+
+void QGstreamerH264StreamingSession::setWlsMaxLateness(qint64 wlsmaxlateness)
+{
+    m_wls_max_lateness = wlsmaxlateness;
+    g_object_set (G_OBJECT (videosink), "max-lateness", m_wls_max_lateness, NULL);
+}
+
+void QGstreamerH264StreamingSession::setWlsQos(bool wlsqos)
+{
+    m_wls_qos = wlsqos;
+    g_object_set (G_OBJECT (videosink), "qos", m_wls_qos, NULL);
+}
+
+void QGstreamerH264StreamingSession::setWlsPositionX(int wlspositionx)
+{
+    m_wls_position_x = wlspositionx;
+    g_object_set (G_OBJECT (videosink), "position_x", m_wls_position_x, NULL);
+}
+
+void QGstreamerH264StreamingSession::setWlsPositionY(int wlspositiony)
+{
+    m_wls_position_y = wlspositiony;
+    g_object_set (G_OBJECT (videosink), "position_y", m_wls_position_y, NULL);
+}
+
+void QGstreamerH264StreamingSession::setWlsOutWidth(int wlsoutwidth)
+{
+    m_wls_out_width = wlsoutwidth;
+    g_object_set (G_OBJECT (videosink), "out_width", m_wls_out_width, NULL);
+}
+
+void QGstreamerH264StreamingSession::setWlsOutHeight(int wlsoutheight)
+{
+    m_wls_out_height = wlsoutheight;
+    g_object_set (G_OBJECT (videosink), "out_height", m_wls_out_height, NULL);
+}
+
+void QGstreamerH264StreamingSession::componentComplete()
+{
+    #ifdef MODIFY_QT_FPS
+    static guint id;
+
+    id++;
+
+    FPS_env = qgetenv("QT_SHOW_FPS");
+    if (FPS_env.isEmpty() == false && id == atoi (FPS_env))
+    {
+    	GstPad *probePad = gst_element_get_static_pad (videosink, "sink");
+    	if (probePad) {
+    		gst_pad_add_probe (probePad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) cb_have_data_sink, NULL, NULL);
+    		// gst_object_unref (videosink);
+    	}
+    	else {
+    		qDebug() <<"Can NOT get videosink sink pad";
+    		exit (EXIT_FAILURE);
+    	}
+    	if (FPS_env != "0")
+    	{
+    		val.it_interval.tv_sec = 1; /* ie. every second */
+    		val.it_interval.tv_usec = 0;
+    		val.it_value.tv_sec = 1; /* initialise counter */
+    		val.it_value.tv_usec = 0;
+    	}
+    }
+
+    signal (SIGALRM, alarm_handler);
+    setitimer (ITIMER_REAL, &val, 0);
+    g_get_current_time (&start_time);
+    #endif	//MODIFY_QT_FPS
+
+    if( !m_transmit)//Receiver
+    {
+            g_object_set (G_OBJECT (videosink), "async", FALSE, NULL);
+            gst_bin_add_many (GST_BIN (m_playbin), udp_src, depay, videoIdentity_depay, parser, decoder, videosink, NULL);
+            gst_element_link_many(udp_src, depay, videoIdentity_depay, parser, decoder, videosink, NULL);
+
+    }
+    else {
+		{
+			/* Pipeline 1:
+			udpsrc port=${main_display_port} caps="application/x-rtp" !
+				rtph264depay ! video/x-h264,framerate=30/1 ! h264parse !
+				omxh264dec ! tee
+
+				# REVIEW #
+				tee0. ! vspmfilter !
+				video/x-raw,width=${m_vspm_width},height=${m_vspm_height},format=${m_vspm_format} !
+				queue ! waylandsink max-lateness=-1 qos=false
+
+				# TRANSMIT to RTSP_SERVER (then RTSP_SERVER will forward to external device) #
+				tee0. ! vspmfilter outbuf-alloc=TRUE !
+				video/x-raw,width=${m_vspm_width1},height=${m_vspm_height1},format=NV12 !
+				queue !
+				omxh264enc target-bitrate=${m_enc_bitrate} num-p-frames=0 !
+				appsink
+			*/
+
+			g_object_set (G_OBJECT (filter1), "outbuf-alloc", true, NULL);
+			g_object_set (G_OBJECT (videosink), "async", FALSE, NULL);
+			
+			gst_bin_add_many (GST_BIN (m_playbin), udp_src, depay,
+				videoIdentity_depay, parser, decoder, tee, filter,
+				capfilter_vspm , videosink, NULL);
+
+			if ( !gst_element_link_many(udp_src, depay, videoIdentity_depay, parser, decoder, tee, NULL) ||
+			     !gst_element_link_many(filter, capfilter_vspm , videosink, NULL)) {
+				g_critical ("Fail to link elements");
+				return ;
+			}
+			
+			teeSetting(); // Create link from tee
+			rtspConnected(); // Calling to create the original link
+		}
+
+		/* RTSP server pipeline */
+		{
+			/* Pipeline 3:
+				udpsrc port=5110  caps=\"application/x-rtp\" !
+                    rtph264depay ! queue ! rtph264pay name=pay0 pt=96 !
+                    RTSPSever
+			*/
+			GstRTSPServer *server;
+			GstRTSPMountPoints *mounts;
+			GstRTSPMediaFactory *factory1;
+			gchar *str1;
+
+
+			/* create a server instance */
+			server = gst_rtsp_server_new ();
+
+			/* get the mount points for this server, every server has a default object
+			* that be used to map uri mount points to media factories */
+			mounts = gst_rtsp_server_get_mount_points (server);
+
+			str1 = g_strdup_printf ("( "
+				"udpsrc port=5000 caps=\"application/x-rtp\" ! "
+				"rtph264depay ! h264parse ! "
+				"video/x-h264,stream-format=avc,alignment=au ! "
+				"queue leaky=2 ! rtph264pay name=pay0 pt=96 config-interval=3 mtu=9000 "
+				")"
+			);
+
+			/* make a media factory for a test stream. The default media factory can use
+			* gst-launch syntax to create pipelines.
+			* any launch line works as long as it contains elements named pay%d. Each
+			* element with pay%d names will be a stream */
+			factory1 = gst_rtsp_media_factory_new ();
+			gst_rtsp_media_factory_set_launch (factory1, str1);
+			g_free (str1);
+
+			gst_rtsp_media_factory_set_shared (factory1, TRUE);
+
+			/* Notify when our media is ready. This is called whenever
+			 * someone asks for the media and a new pipeline is created. */
+			g_signal_connect (factory1, "media-constructed", (GCallback) media_constructed, this);
+
+			/* attach the test factory to the /test url */
+			gst_rtsp_mount_points_add_factory (mounts, "/rtsp", factory1);
+
+			/* don't need the ref to the mapper anymore */
+			g_object_unref (mounts);
+
+			/* attach the server to the default maincontext */
+			if (gst_rtsp_server_attach (server, NULL) == 0) {
+				g_print ("failed to attach the server\n");
+				return;
+			}
+
+			g_timeout_add_seconds (2, (GSourceFunc) timeout, server);
+
+			/* start serving */
+			g_print ("stream ready at rtsp://<board wireless ip>:8554/rtsp\n");
+		}
+    }
+}
+
+void QGstreamerH264StreamingSession::loadFromUri(const QNetworkRequest &request)
+{
+
+#ifdef DEBUG_PLAYBIN
+#endif
+    m_request = request;
+    m_duration = -1;
+    m_lastPosition = 0;
+}
+
+
+qint64 QGstreamerH264StreamingSession::position() const
+{
+
+    GstFormat   format = GST_FORMAT_TIME;
+    gint64      position = 0;
+
+#if GST_CHECK_VERSION(1,0,0)
+ if ( m_playbin && gst_element_query_position(m_playbin, format, &position))
+ m_lastPosition = position / 1000000;
+#else
+    if ( m_playbin && gst_element_query_position(m_playbin, &format, &position))
+        m_lastPosition = position / 1000000;
+#endif
+    return m_lastPosition;
+}
+
+bool QGstreamerH264StreamingSession::isSeekable() const
+{
+
+    return m_seekable;
+}
+
+bool QGstreamerH264StreamingSession::play()
+{
+
+#ifdef DEBUG_PLAYBIN
+#endif
+    if (m_playbin) {
+        if (gst_element_set_state(m_playbin, GST_STATE_PLAYING) == GST_STATE_CHANGE_FAILURE) {
+                qWarning() << "GStreamer; Unable to play -" << m_request.url().toString();
+                m_state = QH264Streaming::StoppedState;
+                emit stateChanged(m_state);
+        } else {
+			while(gst_element_get_state(m_playbin, NULL, NULL, GST_CLOCK_TIME_NONE) == GST_STATE_CHANGE_ASYNC) {
+			    g_print ("QGstreamerH264StreamingSession::play -> wait async \n "); 
+			    sleep(1);
+			}
+
+			if (m_transmit == false) notFirstRun = true;
+			return true;
+		}
+    }
+
+    return false;
+}
+
+bool QGstreamerH264StreamingSession::pause()
+{
+
+#ifdef DEBUG_PLAYBIN
+#endif
+    if (m_playbin) {
+        if (gst_element_set_state(m_playbin, GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE) {
+                qWarning() << "GStreamer; Unable to pause -" << m_request.url().toString();
+                m_state = QH264Streaming::StoppedState;
+                emit stateChanged(m_state);
+        } else {
+			while(gst_element_get_state(m_playbin, NULL, NULL, GST_CLOCK_TIME_NONE) == GST_STATE_CHANGE_ASYNC) {
+			    g_print ("QGstreamerH264StreamingSession::pause ->wait async \n "); 
+			    sleep(1);
+			}
+
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void QGstreamerH264StreamingSession::stop()
+{
+
+#ifdef DEBUG_PLAYBIN
+#endif
+
+    if (m_playbin) {
+
+        gst_element_set_state(m_playbin, GST_STATE_NULL);
+
+        m_lastPosition = 0;
+        QH264Streaming::State oldState = m_state;
+        m_state = QH264Streaming::StoppedState;
+
+        setSeekable(false);
+        if (oldState != m_state)
+            emit stateChanged(m_state);
+    }
+}
+
+void QGstreamerH264StreamingSession::rtspConnected()
+{
+	if (!isTeePadAdd) {
+		if (notFirstRun) {
+			filter1 = gst_element_factory_make ("vspmfilter","vspm-filter1");
+			g_object_set (G_OBJECT (filter1), "outbuf-alloc", true, NULL);
+			
+			encoder = gst_element_factory_make ("omxh264enc","omx-encoder");
+			g_object_set (G_OBJECT (encoder), "target-bitrate", m_enc_bitrate, NULL);
+			g_object_set (G_OBJECT (encoder), "num-p-frames", m_num_pframes, NULL);
+			
+			parser1 = gst_element_factory_make ("h264parse","h264-parse1");
+			
+			videoIdentity_parse = gst_element_factory_make("capsfilter", NULL);
+			g_object_set (G_OBJECT (videoIdentity_parse), "caps", filtercaps_parse, NULL);
+			
+			pay = gst_element_factory_make("rtph264pay", "rtp-pay");
+			g_object_set (G_OBJECT (pay), "pt", 96, NULL);
+			g_object_set (G_OBJECT (pay), "config-interval", 3, NULL);
+			
+			udp_sink = gst_element_factory_make("udpsink", "udp-sink");
+			g_object_set (G_OBJECT (udp_sink), "port", 5000, NULL);
+			g_object_set (G_OBJECT (udp_sink), "host", "127.0.0.1", NULL);
+			
+			gst_bin_add_many (GST_BIN (m_playbin), filter1, encoder, parser1,
+								videoIdentity_parse, pay, udp_sink, NULL);
+		} else gst_bin_add_many (GST_BIN (m_playbin), filter1, capfilter_vspm1, encoder, parser1,
+									videoIdentity_parse, pay, udp_sink, NULL);
+
+		gst_element_link_many (filter1, capfilter_vspm1, encoder, parser1,
+								videoIdentity_parse, pay, udp_sink, NULL);
+		
+		gst_element_sync_state_with_parent (filter1);
+		gst_element_sync_state_with_parent (capfilter_vspm1);
+		gst_element_sync_state_with_parent (encoder);
+		gst_element_sync_state_with_parent (parser1);
+		gst_element_sync_state_with_parent (videoIdentity_parse);
+		gst_element_sync_state_with_parent (pay);
+		gst_element_sync_state_with_parent (udp_sink);
+		
+		if ( !(tee_src_pad_template = gst_element_class_get_pad_template (GST_ELEMENT_GET_CLASS (tee), "src_%u"))) {
+			g_critical ("Unable to get pad template");
+			gst_object_unref (tee_src_pad_template);
+			return ;
+		}
+		tee_q2_pad = gst_element_request_pad (tee, tee_src_pad_template, NULL, NULL);
+		q2_pad = gst_element_get_static_pad (filter1, "sink");
+		if (gst_pad_link (tee_q2_pad, q2_pad) != GST_PAD_LINK_OK) {
+			g_critical ("Tee2 for brand2 could not be linked.\n");
+			gst_object_unref (q2_pad);
+			return ;
+		}
+		gst_object_unref (q2_pad);
+		
+		notFirstRun = true;	
+		isTeePadAdd = true;
+	}
+}
+
+void QGstreamerH264StreamingSession::rtspDisConnected()
+{
+	if (isTeePadAdd) {
+		if ( !(tee_src_pad_template = gst_element_class_get_pad_template (GST_ELEMENT_GET_CLASS (tee), "src_%u"))) {
+			g_critical ("Unable to get pad template");
+			return ;
+		}
+		q2_pad = gst_element_get_static_pad (filter1, "sink");
+		gst_pad_unlink (tee_q2_pad, q2_pad);
+		
+		gst_element_release_request_pad (tee, tee_q2_pad);
+		gst_object_unref (q2_pad);
+		gst_object_unref (tee_q2_pad);
+		
+		gst_element_unlink_many (filter1, capfilter_vspm1, encoder, parser1,
+									videoIdentity_parse, pay, udp_sink, NULL);
+		
+		gst_element_set_state (filter1, GST_STATE_NULL);
+		gst_element_set_state (encoder, GST_STATE_NULL);
+		gst_element_set_state (parser1, GST_STATE_NULL);
+		gst_element_set_state (videoIdentity_parse, GST_STATE_NULL);
+		gst_element_set_state (pay, GST_STATE_NULL);
+		gst_element_set_state (udp_sink, GST_STATE_NULL);
+		
+		gst_bin_remove_many (GST_BIN (m_playbin), filter1, encoder, parser1,
+										videoIdentity_parse, pay, udp_sink, NULL);
+		
+		filter1 = NULL;
+		encoder = NULL;
+		parser1 = NULL;
+		videoIdentity_parse = NULL;
+		pay = NULL;
+		udp_sink = NULL;
+		
+		isTeePadAdd = false;
+	}
+}
+
+void QGstreamerH264StreamingSession::timerEvent(QTimerEvent *event)
+{
+	timer.stop();
+	
+	if (isFirstRemove == false) {
+		printf ("Ready to connect external device\n");
+		isFirstRemove = true;
+		rtspDisConnected();
+	}
+}
+
+bool QGstreamerH264StreamingSession::seek(qint64 ms)
+{
+
+#ifdef DEBUG_PLAYBIN
+#endif
+    //seek locks when the video output sink is changing and pad is blocked
+    // if (m_playbin && !m_pendingVideoSink && m_state != QMediaPlayer::StoppedState && m_seekable) {
+    if (m_playbin && m_state != QH264Streaming::StoppedState && m_seekable) {
+        ms = qMax(ms,qint64(0));
+        gint64  position = ms * 1000000;
+        bool isSeeking = gst_element_seek(m_playbin,
+                                          m_playbackRate,
+                                          GST_FORMAT_TIME,
+                                          GstSeekFlags(GST_SEEK_FLAG_FLUSH),
+                                          GST_SEEK_TYPE_SET,
+                                          position,
+                                          GST_SEEK_TYPE_NONE,
+                                          0);
+        if (isSeeking)
+            m_lastPosition = ms;
+
+        return isSeeking;
+    }
+
+    return false;
+}
+
+void QGstreamerH264StreamingSession::setSeekable(bool seekable)
+{
+
+#ifdef DEBUG_PLAYBIN
+#endif
+    if (seekable != m_seekable) {
+        m_seekable = seekable;
+        emit seekableChanged(m_seekable);
+    }
+}
+
+bool QGstreamerH264StreamingSession::processBusMessage(const QGstreamerMessage &message)
+{
+
+    GstMessage* gm = message.rawMessage();
+    if (gm) {
+
+        bool handlePlaybin2 = false;
+        if (GST_MESSAGE_SRC(gm) == GST_OBJECT_CAST(m_playbin)) {
+            switch (GST_MESSAGE_TYPE(gm))  {
+            case GST_MESSAGE_STATE_CHANGED:
+                {
+
+                    GstState    oldState;
+                    GstState    newState;
+                    GstState    pending;
+
+                    gst_message_parse_state_changed(gm, &oldState, &newState, &pending);
+
+                    switch (newState) {
+                    case GST_STATE_VOID_PENDING:
+                    case GST_STATE_NULL:
+
+                        setSeekable(false);
+                        if (m_state != QH264Streaming::StoppedState)
+                            emit stateChanged(m_state = QH264Streaming::StoppedState);
+                        break;
+                    case GST_STATE_READY:
+
+                        setSeekable(false);
+                        if (m_state != QH264Streaming::StoppedState)
+                            emit stateChanged(m_state = QH264Streaming::StoppedState);
+                        break;
+                    case GST_STATE_PAUSED:
+                    {
+
+                        if (m_state != QH264Streaming::PausedState) {
+                            emit stateChanged(m_state = QH264Streaming::PausedState);
+						}
+
+                        break;
+                    }
+                    case GST_STATE_PLAYING:
+                        if (m_transmit && !isFirstRemove) {
+							printf ("Please wait til already for external device connection...\n");
+							timer.start(3000, this);
+						}
+                        // m_everPlayed = true;
+                        if (m_state != QH264Streaming::PlayingState) {
+                            emit stateChanged(m_state = QH264Streaming::PlayingState);
+                            emit videostateChanged(m_videostate = QH264Streaming::VideoPlaying);
+
+
+                            // For rtsp streams duration information might not be available
+                            // until playback starts.
+                            if (m_duration <= 0) {
+                                m_durationQueries = 5;
+                                updateDuration();
+                            }
+                        }
+
+                        break;
+                    }
+                }
+                break;
+
+            case GST_MESSAGE_EOS:
+#ifdef MODIFY_QT_FPS
+				if (FPS_env.isEmpty() == false)
+				{
+					if (FPS_env != "0")
+					{
+						signal (SIGALRM, SIG_IGN); // add fps
+					}
+					g_get_current_time (&end_time); // add fps
+					timeval_subtract (&diff_time, &end_time, &start_time);
+					qDebug() << "Total time:"<< ((float)diff_time.tv_sec + (float) diff_time.tv_usec / G_USEC_PER_SEC) << "seconds";
+					qDebug() << "Frames:" << (int)count << "processed";
+					qDebug() << "Avg. FPS:" << ((float) ((gulong)count / (float)(diff_time.tv_sec * G_USEC_PER_SEC + diff_time.tv_usec) * G_USEC_PER_SEC));
+					count = 0;
+					past_count = 0;
+				}
+#endif	//MODIFY_QT_FPS
+                emit playbackFinished();
+                break;
+
+            case GST_MESSAGE_TAG:
+            case GST_MESSAGE_STREAM_STATUS:
+            case GST_MESSAGE_UNKNOWN:
+                break;
+            case GST_MESSAGE_ERROR: {
+
+                    GError *err;
+                    gchar *debug;
+                    gst_message_parse_error(gm, &err, &debug);
+                    if (err->domain == GST_STREAM_ERROR && err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND)
+                        processInvalidMedia(QH264Streaming::FormatError, tr("Cannot play stream of type: <unknown>"));
+                    else
+                        processInvalidMedia(QH264Streaming::ResourceError, QString::fromUtf8(err->message));
+                    qWarning() << "Error:" << QString::fromUtf8(err->message);
+                    g_error_free(err);
+                    g_free(debug);
+                }
+                break;
+            case GST_MESSAGE_WARNING:
+                {
+
+                    GError *err;
+                    gchar *debug;
+                    gst_message_parse_warning (gm, &err, &debug);
+                    qWarning() << "Warning:" << QString::fromUtf8(err->message);
+                    g_error_free (err);
+                    g_free (debug);
+                }
+                break;
+            case GST_MESSAGE_INFO:
+
+#ifdef DEBUG_PLAYBIN
+                {
+                    GError *err;
+                    gchar *debug;
+                    gst_message_parse_info (gm, &err, &debug);
+                    g_error_free (err);
+                    g_free (debug);
+                }
+#endif
+                break;
+            case GST_MESSAGE_BUFFERING:
+            case GST_MESSAGE_STATE_DIRTY:
+            case GST_MESSAGE_STEP_DONE:
+            case GST_MESSAGE_CLOCK_PROVIDE:
+            case GST_MESSAGE_CLOCK_LOST:
+            case GST_MESSAGE_NEW_CLOCK:
+            case GST_MESSAGE_STRUCTURE_CHANGE:
+            case GST_MESSAGE_APPLICATION:
+            case GST_MESSAGE_ELEMENT:
+                break;
+            case GST_MESSAGE_SEGMENT_START:
+                break;
+            case GST_MESSAGE_SEGMENT_DONE:
+                break;
+            case GST_MESSAGE_LATENCY:
+#if (GST_VERSION_MAJOR >= 0) &&  (GST_VERSION_MINOR >= 10) && (GST_VERSION_MICRO >= 13)
+            case GST_MESSAGE_ASYNC_START:
+                break;
+            case GST_MESSAGE_ASYNC_DONE:
+            {
+
+                GstFormat   format = GST_FORMAT_TIME;
+                gint64      position = 0;
+                if (gst_element_query_position(m_playbin, &format, &position)) {
+                    position /= 1000000;
+                    m_lastPosition = position;
+                    emit positionChanged(position);
+                }
+                break;
+            }
+#if GST_VERSION_MICRO >= 23
+            case GST_MESSAGE_REQUEST_STATE:
+#endif
+#endif
+            case GST_MESSAGE_ANY:
+                break;
+            default:
+                break;
+            }
+        } else if (GST_MESSAGE_TYPE(gm) == GST_MESSAGE_ERROR) {
+
+            GError *err;
+            gchar *debug;
+            gst_message_parse_error(gm, &err, &debug);
+            // If the source has given up, so do we.
+            if (qstrcmp(GST_OBJECT_NAME(GST_MESSAGE_SRC(gm)), "source") == 0) {
+                // Try and differentiate network related resource errors from the others
+                if (!m_request.url().isRelative() && m_request.url().scheme().compare(QLatin1String("file"), Qt::CaseInsensitive) != 0 ) {
+                    if ((err->domain == GST_RESOURCE_ERROR && (
+                         err->code == GST_RESOURCE_ERROR_BUSY ||
+                         err->code == GST_RESOURCE_ERROR_OPEN_READ ||
+                         err->code == GST_RESOURCE_ERROR_READ ||
+                         err->code == GST_RESOURCE_ERROR_SEEK ||
+                         err->code == GST_RESOURCE_ERROR_SYNC))) {
+                        processInvalidMedia(QH264Streaming::NetworkError, QString::fromUtf8(err->message));
+                    } else {
+                        processInvalidMedia(QH264Streaming::ResourceError, QString::fromUtf8(err->message));
+                    }
+                }
+                else
+                    processInvalidMedia(QH264Streaming::ResourceError, QString::fromUtf8(err->message));
+            } else if (err->domain == GST_STREAM_ERROR
+                       && (err->code == GST_STREAM_ERROR_DECRYPT || err->code == GST_STREAM_ERROR_DECRYPT_NOKEY)) {
+                processInvalidMedia(QH264Streaming::AccessDeniedError, QString::fromUtf8(err->message));
+            } else {
+                handlePlaybin2 = true;
+            }
+            if (!handlePlaybin2)
+                qWarning() << "Error:" << QString::fromUtf8(err->message);
+            g_error_free(err);
+            g_free(debug);
+        } else if (GST_MESSAGE_TYPE(gm) == GST_MESSAGE_ELEMENT
+                   && qstrcmp(GST_OBJECT_NAME(GST_MESSAGE_SRC(gm)), "source") == 0
+                   && m_sourceType == UDPSrc
+                   && gst_structure_has_name(gst_message_get_structure(gm), "GstUDPSrcTimeout")) {
+            //since udpsrc will not generate an error for the timeout event,
+            //we need to process its element message here and treat it as an error.
+            processInvalidMedia(m_everPlayed ? QH264Streaming::NetworkError : QH264Streaming::ResourceError,
+                                tr("UDP source timeout"));
+        } else {
+            handlePlaybin2 = true;
+        }
+
+    }
+
+    return false;
+}
+
+bool QGstreamerH264StreamingSession::processBusMessage1(const QGstreamerMessage &message)
+{
+	GstMessage* msg = message.rawMessage();
+	switch (GST_MESSAGE_TYPE(msg))
+	{
+		/* Stream-status */
+		case GST_MESSAGE_STREAM_STATUS:
+		{
+			GstStreamStatusType type;
+			GstElement *owner;
+			gst_message_parse_stream_status (msg, &type, &owner);
+			/*g_print("[Player][Event] %s: %s stream-status=%s\n",
+			GST_MESSAGE_TYPE_NAME(msg),
+			GST_ELEMENT_NAME(owner),
+			type == GST_STREAM_STATUS_TYPE_CREATE ? "CREATE" :
+			type == GST_STREAM_STATUS_TYPE_ENTER  ? "ENTER" :
+			type == GST_STREAM_STATUS_TYPE_LEAVE  ? "LEAVE" :
+			type == GST_STREAM_STATUS_TYPE_DESTROY ? "DESTORY" :
+			type == GST_STREAM_STATUS_TYPE_START  ? "START" :
+			type == GST_STREAM_STATUS_TYPE_PAUSE  ? "PAUSE" :
+			type == GST_STREAM_STATUS_TYPE_STOP   ? "STOP" : "NONE");*/
+			
+			if ((type == GST_STREAM_STATUS_TYPE_LEAVE) && isTeePadAdd) {
+				rtspDisConnected();
+				printf ("Disconnected/Connecting fail\n");
+			}
+		}
+		break;
+
+		/* State-changed */
+		case GST_MESSAGE_STATE_CHANGED:
+		{
+			GstState oldSt, newSt, targetSt;
+			gst_message_parse_state_changed (msg, &oldSt, &newSt, &targetSt);
+			/*g_print("[Player][Event] %s: %s %s => %s (target:%s)\n",
+			GST_MESSAGE_TYPE_NAME(msg),
+			GST_OBJECT_NAME(msg->src),
+			gst_element_state_get_name(oldSt),
+			gst_element_state_get_name(newSt),
+			gst_element_state_get_name(targetSt));*/
+			
+			if ((oldSt == GST_STATE_PLAYING) && (newSt == GST_STATE_PAUSED) && isTeePadAdd) {
+				rtspDisConnected();
+				printf ("Disconnected/Connecting fail\n");
+			}
+		}
+		break;
+
+		/* New-clock */
+		case GST_MESSAGE_NEW_CLOCK:
+		{
+			GstClock *clock = NULL;
+			gst_message_parse_new_clock (msg, &clock);
+			g_print("[Player][Event] %s: clock=%" GST_TIME_FORMAT "\n",
+			GST_MESSAGE_TYPE_NAME(msg),
+			GST_TIME_ARGS(clock));
+		}
+		break;
+
+		/* Error */
+		case GST_MESSAGE_ERROR:
+		{
+			gchar *debug;
+			GError *error;
+			gst_message_parse_error(msg, &error, &debug);
+			g_print("[Player][Event] %s: %s err=[%s] debug=[%s]\n",
+			GST_MESSAGE_TYPE_NAME(msg),
+			GST_OBJECT_NAME(msg->src),
+			error->message,
+			debug ? debug : "none");
+			g_error_free(error);
+			g_free(debug);
+		}
+		break;
+
+		/* Quality of Service */
+		case GST_MESSAGE_QOS:
+		{
+			gboolean live;
+			guint64 running_time, stream_time, timestamp, duration;
+			gst_message_parse_qos(msg, &live, &running_time, &stream_time, 
+			&timestamp, &duration);
+			g_print("[Player][Event] %s:"
+				" live=%d"
+				" running_time=%" G_GUINT64_FORMAT
+				" stream_time=%" G_GUINT64_FORMAT
+				" timestamp=%" G_GUINT64_FORMAT
+				" duration=%" G_GUINT64_FORMAT
+				"\n",
+			GST_MESSAGE_TYPE_NAME(msg),
+			live, running_time, stream_time, timestamp, duration);
+		}
+		break;
+
+		/* Other message */
+		default:
+			g_print("[Player][Event] %s\n", GST_MESSAGE_TYPE_NAME(msg));
+		break;
+	}
+
+	return true;
+}
+
+void QGstreamerH264StreamingSession::teeSetting()
+{
+	/* tee setting */
+	if ( !(tee_src_pad_template = gst_element_class_get_pad_template (GST_ELEMENT_GET_CLASS (tee), "src_%u"))) {
+		g_critical ("Unable to get pad template");
+		return ;
+	}
+
+	/* Obtaining request pads for the tee2 elements*/
+	tee_q1_pad = gst_element_request_pad (tee, tee_src_pad_template, NULL, NULL);
+	q1_pad = gst_element_get_static_pad (filter, "sink");
+
+	/* Link tee2 to the REVIEW */
+	if (gst_pad_link (tee_q1_pad, q1_pad) != GST_PAD_LINK_OK ){
+		g_critical ("Tee2 for brand1 could not be linked.\n");
+		return ;
+	}
+
+	gst_object_unref (q1_pad);
+}
+
+void QGstreamerH264StreamingSession::updateDuration()
+{
+
+    GstFormat format = GST_FORMAT_TIME;
+    gint64 gstDuration = 0;
+    int duration = -1;
+
+#if GST_CHECK_VERSION(1,0,0)
+ if (m_playbin && gst_element_query_duration(m_playbin, format, &gstDuration))
+#else
+    if (m_playbin && gst_element_query_duration(m_playbin, &format, &gstDuration))
+#endif
+        duration = gstDuration / 1000000;
+
+    if (m_duration != duration) {
+        m_duration = duration;
+        emit durationChanged(m_duration);
+    }
+
+    gboolean seekable = false;
+    if (m_duration > 0) {
+        m_durationQueries = 0;
+        GstQuery *query = gst_query_new_seeking(GST_FORMAT_TIME);
+        if (gst_element_query(m_playbin, query))
+            gst_query_parse_seeking(query, 0, &seekable, 0, 0);
+        gst_query_unref(query);
+    }
+
+    setSeekable(seekable);
+
+#ifdef DEBUG_PLAYBIN
+#endif
+}
+
+
+//doing proper operations when detecting an invalidMedia: change media status before signal the erorr
+void QGstreamerH264StreamingSession::processInvalidMedia(QH264Streaming::Error errorCode, const QString& errorString)
+{
+
+#ifdef DEBUG_PLAYBIN
+#endif
+    if (m_isPlaylist) {
+        stop();
+        emit error(int(QH264Streaming::MediaIsPlaylist), tr("Media is loaded as a playlist"));
+    } else {
+        emit invalidMedia();
+        stop();
+        emit error(int(errorCode), errorString);
+    }
+}
+
+void QGstreamerH264StreamingSession::endOfMediaReset()
+{
+
+
+    QH264Streaming::State oldState = m_state;
+    m_state = QH264Streaming::StoppedState;
+
+    if (oldState != m_state)
+        emit stateChanged(m_state);
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingsession.h b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingsession.h
new file mode 100755
index 0000000..b7219dd
--- /dev/null
+++ b/src/plugins/gstreamer/H264Streaming/qgstreamerH264Streamingsession.h
@@ -0,0 +1,341 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGSTREAMERH264STREAMINGSESSION_H
+#define QGSTREAMERH264STREAMINGSESSION_H
+
+#include <QObject>
+#include <QtCore/qmutex.h>
+#include <QtNetwork/qnetworkrequest.h>
+#include "qgstreamerH264Streamingcontrol.h"
+#include <private/qgstreamerbushelper_p.h>
+#include <qH264Streaming.h>
+#include <qmediastreamscontrol.h>
+#include <qaudioformat.h>
+#include <QtCore>
+#include <QBasicTimer>
+
+#include <gst/app/gstappsink.h>
+#include <gst/app/gstappsrc.h>
+
+
+#if defined(HAVE_GST_APPSRC)
+#include <private/qgstappsrc_p.h>
+#endif
+
+#include <gst/gst.h>
+#include <gst/rtsp-server/rtsp-server.h>
+
+QT_BEGIN_NAMESPACE
+
+class QGstreamerBusHelper;
+class QGstreamerMessage;
+
+class QGstreamerVideoRendererInterface;
+class QGstreamerVideoProbeControl;
+class QGstreamerAudioProbeControl;
+
+class QBasicTimer;
+
+typedef enum {
+  GST_AUTOPLUG_SELECT_TRY,
+  GST_AUTOPLUG_SELECT_EXPOSE,
+  GST_AUTOPLUG_SELECT_SKIP
+} GstAutoplugSelectResult;
+
+class QGstreamerH264StreamingSession : public QObject,
+                                public QGstreamerBusMessageFilter
+{
+Q_OBJECT
+Q_INTERFACES(QGstreamerBusMessageFilter)
+
+public:
+    QGstreamerH264StreamingSession(QObject *parent);
+    virtual ~QGstreamerH264StreamingSession();
+
+    void setHdmiWidth(int hdmiwidth);
+    void setHdmiHeight(int hdmiheight);
+    void setHdmiFormat(QString hdmiformat);
+    void setEncBitrate(int encbitrate);
+    void setNumPframes(int numpframes);
+    void setNoReorder(bool noreoder);
+    void setUdpPort(QString udpport);
+    void setUdpHost(QString udphost);
+    void setTransmit(bool transmit);
+    void setVspm(bool vspm);
+    void setVspmDmabuf(bool vspmdmabuf);
+    void setVspmWidth(int vspmwidth);
+    void setVspmWidth1(int vspmwidth1);
+    void setVspmHeight(int vspmheight);
+    void setVspmHeight1(int vspmheight1);
+    void setVspmFormat(QString vspmformat);
+    void setWlsMaxLateness(qint64 wlsmaxlateness);
+    void setWlsQos(bool wlsqos);
+    void setWlsPositionX(int wlspositionx);
+    void setWlsPositionY(int wlspositiony);
+    void setWlsOutWidth(int wlsoutwidth);
+    void setWlsOutHeight(int wlsoutheight);
+    void componentComplete();
+
+    GstElement *playbin() const;
+    QGstreamerBusHelper *bus() const { return m_busHelper; }
+
+    QNetworkRequest request() const;
+
+    QH264Streaming::State state() const { return m_state; }
+    QH264Streaming::State pendingState() const { return m_pendingState; }
+
+    qint64 duration() const;
+    qint64 position() const;
+
+    int volume() const;
+    bool isMuted() const;
+
+    bool isAudioAvailable() const;
+
+    void setVideoRenderer(QObject *renderer);
+    bool isVideoAvailable() const;
+
+    bool isSeekable() const;
+
+    qreal playbackRate() const;
+    void setPlaybackRate(qreal rate);
+
+    QMediaTimeRange availablePlaybackRanges() const;
+
+    QMap<QByteArray ,QVariant> tags() const { return m_tags; }
+    QMap<QString,QVariant> streamProperties(int streamNumber) const { return m_streamProperties[streamNumber]; }
+    int streamCount() const { return m_streamProperties.count(); }
+    QMediaStreamsControl::StreamType streamType(int streamNumber) { return m_streamTypes.value(streamNumber, QMediaStreamsControl::UnknownStream); }
+
+    int activeStream(QMediaStreamsControl::StreamType streamType) const;
+    void setActiveStream(QMediaStreamsControl::StreamType streamType, int streamNumber);
+
+    bool processBusMessage(const QGstreamerMessage &message);
+
+    // bool isLiveSource() const;
+
+    void addProbe(QGstreamerVideoProbeControl* probe);
+    void removeProbe(QGstreamerVideoProbeControl* probe);
+#if GST_CHECK_VERSION(1,0,0)
+ static GstPadProbeReturn padVideoBufferProbe(GstPad *pad, GstPadProbeInfo *info, gpointer user_data);
+#else
+    static gboolean padVideoBufferProbe(GstPad *pad, GstBuffer *buffer, gpointer user_data);
+#endif
+
+    void addProbe(QGstreamerAudioProbeControl* probe);
+    void removeProbe(QGstreamerAudioProbeControl* probe);
+#if GST_CHECK_VERSION(1,0,0)
+ static GstPadProbeReturn padAudioBufferProbe(GstPad *pad, GstPadProbeInfo* info, gpointer user_data);
+#else
+    static gboolean padAudioBufferProbe(GstPad *pad, GstBuffer *buffer, gpointer user_data);
+#endif
+
+    void endOfMediaReset();
+
+public slots:
+    void loadFromUri(const QNetworkRequest &url);
+    bool play();
+    bool pause();
+    void stop();
+
+    bool seek(qint64 pos);
+
+    // void setVolume(int volume);
+    // void setMuted(bool muted);
+
+    // void showPrerollFrames(bool enabled);
+
+signals:
+    void durationChanged(qint64 duration);
+    void positionChanged(qint64 position);
+    void stateChanged(QH264Streaming::State state);
+    void videostateChanged(QH264Streaming::State state);
+    void volumeChanged(int volume);
+    void mutedStateChanged(bool muted);
+    void audioAvailableChanged(bool audioAvailable);
+    void videoAvailableChanged(bool videoAvailable);
+    void bufferingProgressChanged(int percentFilled);
+    void playbackFinished();
+    void tagsChanged();
+    void streamsChanged();
+    void seekableChanged(bool);
+    void error(int error, const QString &errorString);
+    void invalidMedia();
+    void playbackRateChanged(qreal);
+
+private slots:
+    // void getStreamsInfo();
+    void setSeekable(bool);
+    // void finishVideoOutputChange();
+    // void updateVideoRenderer();
+    // void updateVideoResolutionTag();
+    // void updateVolume();
+    // void updateMuted();
+    void updateDuration();
+    
+    bool processBusMessage1(const QGstreamerMessage &message);
+    void rtspConnected();
+
+private:
+    // static void playbinNotifySource(GObject *o, GParamSpec *p, gpointer d);
+    // static void handleVolumeChange(GObject *o, GParamSpec *p, gpointer d);
+    // static void handleMutedChange(GObject *o, GParamSpec *p, gpointer d);
+    static void insertColorSpaceElement(GstElement *element, gpointer data);
+    static void handleElementAdded(GstBin *bin, GstElement *element, QGstreamerH264StreamingSession *session);
+    static void handleStreamsChange(GstBin *bin, gpointer user_data);
+    static GstAutoplugSelectResult handleAutoplugSelect(GstBin *bin, GstPad *pad, GstCaps *caps, GstElementFactory *factory, QGstreamerH264StreamingSession *session);
+
+    void processInvalidMedia(QH264Streaming::Error errorCode, const QString& errorString);
+    
+    void teeSetting();
+    void rtspDisConnected();
+    void timerEvent(QTimerEvent *event);
+
+    // void removeVideoBufferProbe();
+    // void addVideoBufferProbe();
+    // void removeAudioBufferProbe();
+    // void addAudioBufferProbe();
+    // void flushVideoProbes();
+    // void resumeVideoProbes();
+
+    // static void playlistTypeFindFunction(GstTypeFind *find, gpointer userData);
+
+    QNetworkRequest m_request;
+    QH264Streaming::State m_state;
+    QH264Streaming::State m_videostate;
+    QH264Streaming::State m_pendingState;
+    QGstreamerBusHelper* m_busHelper;
+    GstElement *m_playbin;
+    
+    QBasicTimer timer;
+    GstPadTemplate *tee_src_pad_template;
+    GstPad *tee_q1_pad, *tee_q2_pad;
+	GstPad *q1_pad, *q2_pad;
+
+    GstElement* m_videoOutputBin;
+    GstElement* m_videoIdentity;
+    GstElement* m_colorSpace;
+    bool m_usingColorspaceElement;
+    GstElement* m_videoSink;
+    GstElement* m_pendingVideoSink;
+    GstElement* m_nullVideoSink;
+
+    GstElement* m_audioSink;
+    GstElement* m_volumeElement;
+
+    GstBus* m_bus;
+    QObject *m_videoOutput;
+    QGstreamerVideoRendererInterface *m_renderer;
+
+#if defined(HAVE_GST_APPSRC)
+    QGstAppSrc *m_appSrc;
+#endif
+
+    QMap<QByteArray, QVariant> m_tags;
+    QList< QMap<QString,QVariant> > m_streamProperties;
+    QList<QMediaStreamsControl::StreamType> m_streamTypes;
+    QMap<QMediaStreamsControl::StreamType, int> m_playbin2StreamOffset;
+
+    QList<QGstreamerVideoProbeControl*> m_videoProbes;
+    QMutex m_videoProbeMutex;
+    int m_videoBufferProbeId;
+
+    QList<QGstreamerAudioProbeControl*> m_audioProbes;
+    QMutex m_audioProbeMutex;
+    int m_audioBufferProbeId;
+
+    int m_volume;
+    qreal m_playbackRate;
+    bool m_muted;
+    bool m_audioAvailable;
+    bool m_videoAvailable;
+    bool m_seekable;
+
+    mutable qint64 m_lastPosition;
+    qint64 m_duration;
+    int m_durationQueries;
+
+    bool m_displayPrerolledFrame;
+
+    enum SourceType
+    {
+        UnknownSrc,
+        SoupHTTPSrc,
+        UDPSrc,
+        MMSSrc,
+        RTSPSrc,
+    };
+    SourceType m_sourceType;
+    bool m_everPlayed;
+    bool m_isLiveSource;
+
+    bool m_isPlaylist;
+    gulong pad_probe_id;
+
+    GstCaps *filtercaps_vspm, *filtercaps_vspm1, *filtercaps_depay, *filtercaps_parse, *streaming_src_cap, *filtercaps_dec;
+    GstElement *udp_src, *udp_sink, *pay, *depay, *parser, *encoder, *decoder, *filter, *capfilter_vspm, *videoIdentity_depay, *videoIdentity_parse, *videosink, *tee, *filter1, *capfilter_vspm1, *parser1;
+    GstStateChangeReturn ret;
+    GstState currentState, newState;
+    GstState pending;
+    int m_hdmi_width;
+    int m_hdmi_height;
+    QString m_hdmi_format;
+    int m_enc_bitrate;
+    int m_num_pframes;
+    bool m_no_reorder;
+    QString m_udp_port;
+    QString m_udp_host;
+    bool m_transmit;
+    bool m_vspm;
+    bool m_vspm_dmabuf_use;
+    int m_vspm_width;
+    int m_vspm_width1;
+    int m_vspm_height;
+    int m_vspm_height1;
+    QString m_vspm_format;
+    qint64 m_wls_max_lateness;
+    bool m_wls_qos;
+    int m_wls_position_x;
+    int m_wls_position_y;
+    int m_wls_out_width;
+    int m_wls_out_height;
+    int count;
+    bool notFirstRun;
+    bool isFirstRemove;
+    bool isTeePadAdd;
+};
+
+QT_END_NAMESPACE
+
+#endif // QGSTREAMERPLAYERSESSION_H
diff --git a/src/plugins/gstreamer/MP4Playback/MP4Playback.json b/src/plugins/gstreamer/MP4Playback/MP4Playback.json
new file mode 100755
index 0000000..8a55a14
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Playback/MP4Playback.json
@@ -0,0 +1,4 @@
+{
+    "Keys": ["gstreamerMP4Playback"],
+    "Services": ["org.qt-project.qt.mp4playback"]
+}
diff --git a/src/plugins/gstreamer/MP4Playback/MP4Playback.pro b/src/plugins/gstreamer/MP4Playback/MP4Playback.pro
new file mode 100755
index 0000000..25a44b1
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Playback/MP4Playback.pro
@@ -0,0 +1,25 @@
+TARGET = gstMP4Playback
+
+PLUGIN_TYPE = mediaservice
+PLUGIN_CLASS_NAME = QGstreamerPlayerServicePlugin
+load(qt_plugin)
+
+include(../common.pri)
+
+INCLUDEPATH += $$PWD
+
+HEADERS += \
+    $$PWD/qgstreamerMP4Playbackcontrol.h \
+    $$PWD/qgstreamerMP4Playbackservice.h \
+    $$PWD/qgstreamerMP4Playbacksession.h \
+    $$PWD/qgstreamerMP4Playbackserviceplugin.h
+
+SOURCES += \
+    $$PWD/qgstreamerMP4Playbackcontrol.cpp \
+    $$PWD/qgstreamerMP4Playbackservice.cpp \
+    $$PWD/qgstreamerMP4Playbacksession.cpp \
+    $$PWD/qgstreamerMP4Playbackserviceplugin.cpp
+
+OTHER_FILES += \
+    MP4Playback.json
+
diff --git a/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackcontrol.cpp b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackcontrol.cpp
new file mode 100755
index 0000000..d196d6c
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackcontrol.cpp
@@ -0,0 +1,79 @@
+#include "qgstreamerMP4Playbackcontrol.h"
+#include "qgstreamerMP4Playbacksession.h"
+
+// #define DEBUG_MP4PLAYBACK
+QT_BEGIN_NAMESPACE
+
+QGstreamerMP4PlaybackControl::QGstreamerMP4PlaybackControl(QGstreamerMP4PlaybackSession *session, QObject *parent)
+    : QMP4PlaybackControl(parent)
+    , m_session(session)
+    , m_currentState(QMP4Playback::StoppedState)
+    , m_currentStatus(QMP4Playback::NoMedia)
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    connect(m_session, SIGNAL(signal_Session_StateStatusChanged(QMP4Playback::State, QMP4Playback::Status)), this, 
+                        SLOT(slot_Control_StateStatusChanged(QMP4Playback::State, QMP4Playback::Status)));
+}
+
+QGstreamerMP4PlaybackControl::~QGstreamerMP4PlaybackControl()
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+}
+
+void QGstreamerMP4PlaybackControl::play()
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->play();
+}
+
+void QGstreamerMP4PlaybackControl::stop()
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->stop();
+}
+
+void QGstreamerMP4PlaybackControl::pause()
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->pause();
+}
+
+void QGstreamerMP4PlaybackControl::setSource(QString source)
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->setSource(source);
+}
+
+void QGstreamerMP4PlaybackControl::componentComplete()
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->componentComplete();
+}
+
+void QGstreamerMP4PlaybackControl::slot_Control_StateStatusChanged(QMP4Playback::State newstate, QMP4Playback::Status newstatus)
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+    QMP4Playback::printState(newstate);
+    QMP4Playback::printStatus(newstatus);
+#endif
+    m_currentState = newstate;
+    m_currentStatus = newstatus;
+    emit statestatusChanged(m_currentState, m_currentStatus);
+}
+
+QT_END_NAMESPACE
\ No newline at end of file
diff --git a/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackcontrol.h b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackcontrol.h
new file mode 100755
index 0000000..35b9619
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackcontrol.h
@@ -0,0 +1,39 @@
+#ifndef QGSTREAMERMP4PLAYBACKCONTROL_H
+#define QGSTREAMERMP4PLAYBACKCONTROL_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qstack.h>
+#include <qMP4Playbackcontrol.h>
+#include <qMP4Playback.h>
+#include <limits.h>
+
+QT_BEGIN_NAMESPACE
+
+class QGstreamerMP4PlaybackService;
+class QGstreamerMP4PlaybackSession;
+
+class QGstreamerMP4PlaybackControl : public QMP4PlaybackControl
+{
+    Q_OBJECT
+
+public:
+    QGstreamerMP4PlaybackControl(QGstreamerMP4PlaybackSession *session, QObject *parent = 0);
+    ~QGstreamerMP4PlaybackControl();
+    
+    void play();
+    void stop();
+    void pause();
+    void setSource(QString source);
+    void componentComplete();
+    
+public slots:
+    void slot_Control_StateStatusChanged(QMP4Playback::State, QMP4Playback::Status);
+    
+private:
+    QGstreamerMP4PlaybackSession *m_session;
+    QMP4Playback::State m_currentState;
+    QMP4Playback::Status m_currentStatus;
+};
+
+QT_END_NAMESPACE
+#endif
\ No newline at end of file
diff --git a/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackservice.cpp b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackservice.cpp
new file mode 100755
index 0000000..fc59b9c
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackservice.cpp
@@ -0,0 +1,54 @@
+#include <QtCore/qvariant.h>
+#include <QtCore/qdebug.h>
+
+#include "qgstreamerMP4Playbackservice.h"
+#include "qgstreamerMP4Playbackcontrol.h"
+#include "qgstreamerMP4Playbacksession.h"
+
+
+#include <private/qmediaplaylistnavigator_p.h>
+#include <qmediaplaylist.h>
+#include <private/qmediaresourceset_p.h>
+
+// #define DEBUG_QMP4PLAYBACK
+
+QT_BEGIN_NAMESPACE
+
+QGstreamerMP4PlaybackService::QGstreamerMP4PlaybackService(QObject *parent):
+     QMediaService(parent)
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session = new QGstreamerMP4PlaybackSession(this);
+    m_control = new QGstreamerMP4PlaybackControl(m_session, this);
+}
+
+QGstreamerMP4PlaybackService::~QGstreamerMP4PlaybackService()
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+QMediaControl *QGstreamerMP4PlaybackService::requestControl(const char *name)
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    if (qstrcmp(name, QMP4PlaybackControl_iid) == 0){
+        return m_control;
+    }
+
+    return 0;
+}
+
+void QGstreamerMP4PlaybackService::releaseControl(QMediaControl *control)
+{
+#ifdef DEBUG_QMP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackservice.h b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackservice.h
new file mode 100755
index 0000000..3e6f6b3
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackservice.h
@@ -0,0 +1,35 @@
+#ifndef QGSTREAMERMP4PLAYBACKSERVICE_H
+#define QGSTREAMERMP4PLAYBACKSERVICE_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qiodevice.h>
+
+#include <qmediaservice.h>
+
+QT_BEGIN_NAMESPACE
+class QMediaPlayerControl;
+class QMediaPlaylist;
+class QMediaPlaylistNavigator;
+
+class QGstreamerMetaData;
+class QGstreamerMP4PlaybackControl;
+class QGstreamerMP4PlaybackSession;
+
+class QGstreamerMP4PlaybackService : public QMediaService
+{
+    Q_OBJECT
+public:
+    QGstreamerMP4PlaybackService(QObject *parent = 0);
+    ~QGstreamerMP4PlaybackService();
+
+    QMediaControl *requestControl(const char *name);
+    void releaseControl(QMediaControl *control);
+
+private:
+    QGstreamerMP4PlaybackControl *m_control;
+    QGstreamerMP4PlaybackSession *m_session;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackserviceplugin.cpp b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackserviceplugin.cpp
new file mode 100755
index 0000000..2f9b46f
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackserviceplugin.cpp
@@ -0,0 +1,32 @@
+#include <QtCore/qstring.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/QDir>
+#include <QtCore/QDebug>
+
+#include "qgstreamerMP4Playbackserviceplugin.h"
+#include "qgstreamerMP4Playbackservice.h"
+#include <private/qgstutils_p.h>
+
+// #define DEBUG_MP4PLAYBACK
+
+QMediaService* QGstreamerMP4PlaybackServicePlugin::create(const QString &key)
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    QGstUtils::initializeGst();
+
+    if (key == QLatin1String(Q_MEDIASERVICE_MP4PLAYBACK))
+        return new QGstreamerMP4PlaybackService;
+
+    qWarning() << "Gstreamer service plugin: unsupported key:" << key;
+    return 0;
+}
+
+void QGstreamerMP4PlaybackServicePlugin::release(QMediaService *service)
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    delete service;
+}
diff --git a/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackserviceplugin.h b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackserviceplugin.h
new file mode 100755
index 0000000..e25adbc
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbackserviceplugin.h
@@ -0,0 +1,26 @@
+#ifndef QGSTREAMERMP4PLAYBACKSERVICEPLUGIN_H
+#define QGSTREAMERMP4PLAYBACKSERVICEPLUGIN_H
+
+#include <qmediaserviceproviderplugin.h>
+#include <QtCore/qset.h>
+#include <QtCore/QObject>
+
+QT_BEGIN_NAMESPACE
+
+
+class QGstreamerMP4PlaybackServicePlugin
+    : public QMediaServiceProviderPlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.qt.mediaserviceproviderfactory/5.0" FILE "MP4Playback.json")
+public:
+    QMediaService* create(QString const& key);
+    void release(QMediaService *service);
+
+private:
+};
+
+QT_END_NAMESPACE
+
+#endif // QGSTREAMERMP4PLAYBACKSERVICEPLUGIN_H
+
diff --git a/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbacksession.cpp b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbacksession.cpp
new file mode 100755
index 0000000..57f85b7
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbacksession.cpp
@@ -0,0 +1,223 @@
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <stdio.h>
+#include "qgstreamerMP4Playbacksession.h"
+#include <private/qgstreamerbushelper_p.h>
+
+// #define DEBUG_MP4PLAYBACK
+QT_BEGIN_NAMESPACE
+
+static void on_pad_added (GstElement *element, GstPad *pad, gpointer data)
+{
+    GstCaps *caps;
+    GstStructure *str;
+    GstElement *decoder_temp = (GstElement *) data;
+    
+    caps = gst_pad_get_current_caps (pad);
+    str = gst_caps_get_structure (caps, 0);
+    
+    const gchar *c = gst_structure_get_name(str);
+    if (g_strrstr (c, "video") || g_strrstr (c, "image")) {
+        // Link it actually
+        GstPad *targetsink = gst_element_get_static_pad (decoder_temp, "sink");
+        gst_pad_link (pad, targetsink);
+        gst_object_unref (targetsink);
+    }
+}
+
+QGstreamerMP4PlaybackSession::QGstreamerMP4PlaybackSession(QObject *parent)
+    :QObject(parent)
+    , m_source("\0")
+    , m_state(QMP4Playback::StoppedState)
+    , m_status(QMP4Playback::NoMedia)
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+}
+
+QGstreamerMP4PlaybackSession::~QGstreamerMP4PlaybackSession()
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    if (m_pipeline) {
+        stop();
+        delete m_busHelper;
+        gst_object_unref(GST_OBJECT(m_bus));
+        gst_object_unref(GST_OBJECT(m_pipeline));
+    }
+}
+
+bool QGstreamerMP4PlaybackSession::processBusMessage(const QGstreamerMessage &message)
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    GstMessage* gm = message.rawMessage();
+    if (gm) {
+        if (GST_MESSAGE_SRC(gm) == GST_OBJECT_CAST(m_pipeline)) {
+            switch (GST_MESSAGE_TYPE(gm))  {
+                case GST_MESSAGE_STATE_CHANGED:
+                {
+
+                    GstState    oldState;
+                    GstState    newState;
+                    GstState    pending;
+
+                    gst_message_parse_state_changed(gm, &oldState, &newState, &pending);
+
+                    switch (newState) {
+                    case GST_STATE_VOID_PENDING:
+                    case GST_STATE_NULL:
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_NULL";
+#endif
+                        break;
+                    case GST_STATE_READY:
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_READY";
+#endif
+						m_state = QMP4Playback::ReadyState;
+						m_status = QMP4Playback::LoadedMedia;
+						emit signal_Session_StateStatusChanged(m_state, m_status);
+                        break;
+                    case GST_STATE_PAUSED:
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_PAUSED";
+#endif
+                        if((m_state != QMP4Playback::StoppedState) && (m_status != QMP4Playback::EndOfMedia))
+                        {
+                            m_state = QMP4Playback::PausedState;
+                            m_status = QMP4Playback::BufferedMedia;
+                            emit signal_Session_StateStatusChanged(m_state, m_status);
+                        }
+                        break;
+                    case GST_STATE_PLAYING:
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_PLAYING";
+#endif
+                        m_state = QMP4Playback::PlayingState;
+                        m_status = QMP4Playback::BufferingMedia;
+                        emit signal_Session_StateStatusChanged(m_state, m_status);
+                        break;
+                    }
+                    break;
+                }
+                case GST_MESSAGE_EOS:{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO << "Change to GST_MESSAGE_EOS";
+#endif
+                    m_state = QMP4Playback::StoppedState;
+                    m_status = QMP4Playback::EndOfMedia;
+                    emit signal_Session_StateStatusChanged(m_state, m_status);
+                    break;
+                }
+            }
+        }
+    }
+    
+    return true;
+}
+
+void QGstreamerMP4PlaybackSession::play()
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    if((m_state == QMP4Playback::StoppedState) && (m_status == QMP4Playback::EndOfMedia)){
+
+        gst_element_set_state(m_pipeline, GST_STATE_PAUSED);
+        gst_element_seek(   m_pipeline, 
+                            1.0,
+                            GST_FORMAT_TIME,
+                            GstSeekFlags(GST_SEEK_FLAG_FLUSH),
+                            GST_SEEK_TYPE_SET,
+                            0,
+                            GST_SEEK_TYPE_NONE,
+                            0);
+        gst_element_set_state(m_pipeline, GST_STATE_PLAYING);
+    }else{
+      if ((1 != paused_state) && (1 != playing_state)) {
+        m_pipeline = gst_pipeline_new ("MP4Playback");
+        m_bus = gst_element_get_bus(m_pipeline);
+        m_busHelper = new QGstreamerBusHelper(m_bus, this);
+        m_busHelper->installMessageFilter(this);
+        
+        m_filesrc = gst_element_factory_make("filesrc", "Input-File");
+        m_demux = gst_element_factory_make("qtdemux", "Demuxer");
+        m_dec = gst_element_factory_make("omxh264dec", "Decoder");
+        m_queue = gst_element_factory_make("queue", "Queue");
+        m_display = gst_element_factory_make("waylandsink", "Display");
+        
+        gst_bin_add_many (GST_BIN (m_pipeline), m_filesrc, m_demux, m_dec, m_queue, m_display, NULL);
+        gst_element_link (m_filesrc, m_demux);
+        gst_element_link (m_dec, m_display);
+        //gst_element_link (m_dec, m_queue, m_display);
+        g_signal_connect (m_demux, "pad-added", G_CALLBACK (on_pad_added), m_dec);
+        
+        g_object_set (G_OBJECT (m_filesrc), "location", m_source.toLatin1().constData(), NULL);
+        g_object_set (G_OBJECT (m_dec), "use-dmabuf", true, NULL);
+        g_object_set (G_OBJECT (m_display), "out-width", 960, NULL);
+        g_object_set (G_OBJECT (m_display), "out-height", 540, NULL);
+        g_object_set (G_OBJECT (m_display), "position-x", 0, NULL);
+        g_object_set (G_OBJECT (m_display), "position-y", 0, NULL);
+        g_object_set (G_OBJECT (m_display), "max-lateness", -1, NULL);
+        
+        m_state = QMP4Playback::StoppedState;
+        m_status = QMP4Playback::LoadedMedia;
+      }
+      gst_element_set_state(m_pipeline, GST_STATE_PLAYING);
+    }
+
+    playing_state = 1;
+    paused_state = 0;
+}
+
+void QGstreamerMP4PlaybackSession::stop()
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    gst_element_set_state(m_pipeline, GST_STATE_NULL);
+    m_state = QMP4Playback::StoppedState;
+    m_status = QMP4Playback::NoMedia;
+    emit signal_Session_StateStatusChanged(m_state, m_status);
+    gst_pipeline_set_auto_flush_bus((GstPipeline*)m_pipeline,FALSE);
+
+    if (m_pipeline) {
+        delete m_busHelper;
+        gst_object_unref(GST_OBJECT(m_bus));
+        gst_object_unref(GST_OBJECT(m_pipeline));
+    }
+    playing_state = 0;
+    paused_state = 0;
+}
+
+void QGstreamerMP4PlaybackSession::pause()
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+    gst_element_set_state(m_pipeline, GST_STATE_PAUSED);
+    paused_state = 1;
+}
+
+void QGstreamerMP4PlaybackSession::setSource(QString source)
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO << source;
+#endif
+    m_source = source;
+}
+
+void QGstreamerMP4PlaybackSession::componentComplete()
+{
+#ifdef DEBUG_MP4PLAYBACK
+    qDebug() << Q_FUNC_INFO;
+#endif
+}
+
+
+QT_END_NAMESPACE
\ No newline at end of file
diff --git a/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbacksession.h b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbacksession.h
new file mode 100755
index 0000000..8ed2bd2
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Playback/qgstreamerMP4Playbacksession.h
@@ -0,0 +1,55 @@
+#ifndef QGSTREAMERMP4PLAYBACKSESSION_H
+#define QGSTREAMERMP4PLAYBACKSESSION_H
+
+#include <QObject>
+#include <QtCore/qmutex.h>
+#include <QtNetwork/qnetworkrequest.h>
+#include "qgstreamerMP4Playbackcontrol.h"
+#include <private/qgstreamerbushelper_p.h>
+#include <qmediastreamscontrol.h>
+#include <qaudioformat.h>
+#include <gst/gst.h>
+
+QT_BEGIN_NAMESPACE
+class QGstreamerBusHelper;
+class QGstreamerMessage;
+
+class QGstreamerMP4PlaybackSession : public QObject,
+                                public QGstreamerBusMessageFilter
+{
+Q_OBJECT
+Q_INTERFACES(QGstreamerBusMessageFilter)
+public:
+    QGstreamerMP4PlaybackSession(QObject *parent);
+    virtual ~QGstreamerMP4PlaybackSession();
+    
+    bool processBusMessage(const QGstreamerMessage &message);
+    QGstreamerBusHelper *bus() const { return m_busHelper; }
+    
+    void play();
+    void stop();
+    void pause();
+    void setSource(QString source);
+    void componentComplete();
+    
+signals:
+    void signal_Session_StateStatusChanged(QMP4Playback::State, QMP4Playback::Status);
+    
+private:
+    GstBus* m_bus;
+    QGstreamerBusHelper* m_busHelper;
+    QMP4Playback::State m_state;
+    QMP4Playback::Status m_status;
+    int paused_state;
+    int playing_state;
+    
+    QString m_source;
+    
+    GstElement *m_pipeline;
+    GstElement *m_filesrc, *m_demux, *m_dec, *m_display, *m_queue;
+
+};
+
+QT_END_NAMESPACE
+
+#endif
\ No newline at end of file
diff --git a/src/plugins/gstreamer/MP4Recorder/MP4Recorder.json b/src/plugins/gstreamer/MP4Recorder/MP4Recorder.json
new file mode 100755
index 0000000..d3f88e8
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Recorder/MP4Recorder.json
@@ -0,0 +1,4 @@
+{
+    "Keys": ["gstreamerMP4Recorder"],
+    "Services": ["org.qt-project.qt.MP4Recorder"]
+}
diff --git a/src/plugins/gstreamer/MP4Recorder/MP4Recorder.pro b/src/plugins/gstreamer/MP4Recorder/MP4Recorder.pro
new file mode 100755
index 0000000..e2a8b89
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Recorder/MP4Recorder.pro
@@ -0,0 +1,25 @@
+TARGET = gstMP4Recorder
+
+PLUGIN_TYPE = mediaservice
+PLUGIN_CLASS_NAME = QGstreamerPlayerServicePlugin
+load(qt_plugin)
+
+include(../common.pri)
+
+INCLUDEPATH += $$PWD
+
+HEADERS += \
+    $$PWD/qgstreamerMP4Recordercontrol.h \
+    $$PWD/qgstreamerMP4Recorderservice.h \
+    $$PWD/qgstreamerMP4Recordersession.h \
+    $$PWD/qgstreamerMP4Recorderserviceplugin.h
+
+SOURCES += \
+    $$PWD/qgstreamerMP4Recordercontrol.cpp \
+    $$PWD/qgstreamerMP4Recorderservice.cpp \
+    $$PWD/qgstreamerMP4Recordersession.cpp \
+    $$PWD/qgstreamerMP4Recorderserviceplugin.cpp
+
+OTHER_FILES += \
+    MP4Recorder.json
+
diff --git a/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordercontrol.cpp b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordercontrol.cpp
new file mode 100755
index 0000000..97904ca
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordercontrol.cpp
@@ -0,0 +1,173 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qgstreamerMP4Recordercontrol.h"
+#include "qgstreamerMP4Recordersession.h"
+
+#include <private/qmediaplaylistnavigator_p.h>
+#include <private/qmediaresourcepolicy_p.h>
+#include <private/qmediaresourceset_p.h>
+
+#include <QtCore/qdir.h>
+#include <QtCore/qsocketnotifier.h>
+#include <QtCore/qurl.h>
+#include <QtCore/qdebug.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+// #define DEBUG_ENCODER
+//#define DEBUG_PLAYBIN
+
+QT_BEGIN_NAMESPACE
+
+QGstreamerMP4RecorderControl::QGstreamerMP4RecorderControl(QGstreamerMP4RecorderSession *session, QObject *parent)
+    : QMP4RecorderControl(parent)
+    , m_session(session)
+    , m_currentState(QMP4Recorder::StoppedState)
+    , m_mediaStatus(QMP4Recorder::NoMedia)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    connect(m_session, SIGNAL(encodeFinished()), this, SLOT(processEOS()));
+    
+}
+
+QGstreamerMP4RecorderControl::~QGstreamerMP4RecorderControl()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+}
+
+void QGstreamerMP4RecorderControl::setUsrcPort(int usrcport)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->setUsrcPort(usrcport);
+}
+
+void QGstreamerMP4RecorderControl::setFSinkLocation(QString fsinkloc)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->setFSinkLocation(fsinkloc);
+}
+
+void QGstreamerMP4RecorderControl::componentComplete()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->componentComplete();
+    
+}
+
+void QGstreamerMP4RecorderControl::start()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->start();
+}
+
+void QGstreamerMP4RecorderControl::stop()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->stop();
+}
+
+void QGstreamerMP4RecorderControl::pause()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->pause();
+}
+
+QMediaPlayerResourceSetInterface* QGstreamerMP4RecorderControl::resources() const
+{
+
+    return m_resources;
+}
+
+
+QMP4Recorder::State QGstreamerMP4RecorderControl::state() const
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_currentState;
+}
+
+QMP4Recorder::MediaStatus QGstreamerMP4RecorderControl::mediaStatus() const
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_mediaStatus;
+}
+
+void QGstreamerMP4RecorderControl::updateSessionState(QMP4Recorder::State state)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+}
+
+void QGstreamerMP4RecorderControl::processEOS()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_mediaStatus = QMP4Recorder::EndOfMedia;
+    
+    emit mediaStatusChanged(m_mediaStatus);
+}
+
+void QGstreamerMP4RecorderControl::handleInvalidMedia()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_mediaStatus = QMP4Recorder::InvalidMedia;
+    m_currentState = QMP4Recorder::StoppedState;
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordercontrol.h b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordercontrol.h
new file mode 100755
index 0000000..956f193
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordercontrol.h
@@ -0,0 +1,63 @@
+#ifndef QGSTREAMERMP4RECORDERCONTROL_H
+#define QGSTREAMERMP4RECORDERCONTROL_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qstack.h>
+
+#include <qMP4Recordercontrol.h>
+#include <qMP4Recorder.h>
+
+#include <limits.h>
+
+QT_BEGIN_NAMESPACE
+
+class QMediaPlayerResourceSetInterface;
+
+class QMediaPlaylist;
+class QMediaPlaylistNavigator;
+class QSocketNotifier;
+
+class QGstreamerMP4RecorderSession;
+class QGstreamerMP4RecorderService;
+
+class QGstreamerMP4RecorderControl : public QMP4RecorderControl
+{
+    Q_OBJECT
+
+public:
+    QGstreamerMP4RecorderControl(QGstreamerMP4RecorderSession *session, QObject *parent = 0);
+    ~QGstreamerMP4RecorderControl();
+
+    QMP4Recorder::MediaStatus mediaStatus() const;
+    QMP4Recorder::State state() const;    
+    
+    QMediaPlayerResourceSetInterface* resources() const;
+    
+    void setUsrcPort(int);
+    void setFSinkLocation(QString);
+    void componentComplete();
+    void start();
+    void stop();
+    void pause();
+
+public Q_SLOTS:
+
+private Q_SLOTS:
+    void updateSessionState(QMP4Recorder::State state);
+    // void updateMediaStatus();
+    void processEOS();
+    void handleInvalidMedia();
+
+private:
+    void playOrPause(QMP4Recorder::State state);
+
+    QGstreamerMP4RecorderSession *m_session;
+    QMP4Recorder::State m_currentState;
+    QMP4Recorder::MediaStatus m_mediaStatus;
+    QMediaPlayerResourceSetInterface *m_resources;
+    
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderservice.cpp b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderservice.cpp
new file mode 100755
index 0000000..d75797e
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderservice.cpp
@@ -0,0 +1,76 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtCore/qvariant.h>
+#include <QtCore/qdebug.h>
+
+#include "qgstreamerMP4Recorderservice.h"
+#include "qgstreamerMP4Recordercontrol.h"
+#include "qgstreamerMP4Recordersession.h"
+
+
+#include <private/qmediaplaylistnavigator_p.h>
+#include <qmediaplaylist.h>
+#include <private/qmediaresourceset_p.h>
+
+QT_BEGIN_NAMESPACE
+
+QGstreamerMP4RecorderService::QGstreamerMP4RecorderService(QObject *parent):
+     QMediaService(parent)
+{
+    // qDebug() << Q_FUNC_INFO;
+    m_session = new QGstreamerMP4RecorderSession(this);
+    m_control = new QGstreamerMP4RecorderControl(m_session, this);
+}
+
+QGstreamerMP4RecorderService::~QGstreamerMP4RecorderService()
+{
+    // qDebug() << Q_FUNC_INFO;
+}
+
+QMediaControl *QGstreamerMP4RecorderService::requestControl(const char *name)
+{
+    // qDebug() << Q_FUNC_INFO;
+    if (qstrcmp(name, QMP4RecorderControl_iid) == 0){
+        return m_control;
+    }
+
+    return 0;
+}
+
+void QGstreamerMP4RecorderService::releaseControl(QMediaControl *control)
+{
+    // qDebug() << Q_FUNC_INFO;
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderservice.h b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderservice.h
new file mode 100755
index 0000000..da946a0
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderservice.h
@@ -0,0 +1,68 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGSTREAMERMP4RECORDERSERVICE_H
+#define QGSTREAMERMP4RECORDERSERVICE_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qiodevice.h>
+
+#include <qmediaservice.h>
+
+QT_BEGIN_NAMESPACE
+class QMediaPlayerControl;
+class QMediaPlaylist;
+class QMediaPlaylistNavigator;
+
+class QGstreamerMetaData;
+class QGstreamerMP4RecorderControl;
+class QGstreamerMP4RecorderSession;
+
+class QGstreamerMP4RecorderService : public QMediaService
+{
+    Q_OBJECT
+public:
+    QGstreamerMP4RecorderService(QObject *parent = 0);
+    ~QGstreamerMP4RecorderService();
+
+    QMediaControl *requestControl(const char *name);
+    void releaseControl(QMediaControl *control);
+
+private:
+    QGstreamerMP4RecorderControl *m_control;
+    QGstreamerMP4RecorderSession *m_session;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderserviceplugin.cpp b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderserviceplugin.cpp
new file mode 100755
index 0000000..8106237
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderserviceplugin.cpp
@@ -0,0 +1,62 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtCore/qstring.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/QDir>
+#include <QtCore/QDebug>
+
+#include "qgstreamerMP4Recorderserviceplugin.h"
+
+//#define QT_SUPPORTEDMIMETYPES_DEBUG
+
+#include "qgstreamerMP4Recorderservice.h"
+#include <private/qgstutils_p.h>
+
+QMediaService* QGstreamerMP4RecorderServicePlugin::create(const QString &key)
+{
+    // qDebug() << Q_FUNC_INFO;
+    QGstUtils::initializeGst();
+
+    if (key == QLatin1String(Q_MEDIASERVICE_MP4RECORDER))
+        return new QGstreamerMP4RecorderService;
+
+    qWarning() << "Gstreamer service plugin: unsupported key:" << key;
+    return 0;
+}
+
+void QGstreamerMP4RecorderServicePlugin::release(QMediaService *service)
+{
+    // qDebug() << Q_FUNC_INFO;
+    delete service;
+}
diff --git a/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderserviceplugin.h b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderserviceplugin.h
new file mode 100755
index 0000000..0a5b6a3
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recorderserviceplugin.h
@@ -0,0 +1,60 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#ifndef QGSTREAMERMP4RECORDERSERVICEPLUGIN_H
+#define QGSTREAMERMP4RECORDERSERVICEPLUGIN_H
+
+#include <qmediaserviceproviderplugin.h>
+#include <QtCore/qset.h>
+#include <QtCore/QObject>
+
+QT_BEGIN_NAMESPACE
+
+
+class QGstreamerMP4RecorderServicePlugin
+    : public QMediaServiceProviderPlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.qt.mediaserviceproviderfactory/5.0" FILE "MP4Recorder.json")
+public:
+    QMediaService* create(QString const& key);
+    void release(QMediaService *service);
+
+private:
+};
+
+QT_END_NAMESPACE
+
+#endif // QGSTREAMERMP4RECORDERSERVICEPLUGIN_H
+
diff --git a/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordersession.cpp b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordersession.cpp
new file mode 100755
index 0000000..212b074
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordersession.cpp
@@ -0,0 +1,225 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <stdio.h>
+#include "qgstreamerMP4Recordersession.h"
+#include <private/qgstreamerbushelper_p.h>
+
+#include <private/qgstreameraudioprobecontrol_p.h>
+#include <private/qgstreamervideoprobecontrol_p.h>
+#include <private/qgstreamervideorendererinterface_p.h>
+#include <private/gstvideoconnector_p.h>
+#include <private/qgstutils_p.h>
+#include <private/playlistfileparser_p.h>
+#include <private/qgstutils_p.h>
+
+#include <gst/gstvalue.h>
+#include <gst/base/gstbasesrc.h>
+
+#include <QtMultimedia/qmediametadata.h>
+#include <QtCore/qdatetime.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/qsize.h>
+#include <QtCore/qtimer.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/qdir.h>
+#include <QtCore/qstandardpaths.h>
+
+// #define DEBUG_ENCODER
+// #define DEBUG_VO_BIN_DUMP
+
+QT_BEGIN_NAMESPACE
+
+QGstreamerMP4RecorderSession::QGstreamerMP4RecorderSession(QObject *parent)
+    :QObject(parent)
+    , m_fsinklocation("\0")
+    , m_usrcport(0)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_recorder = gst_pipeline_new ("MP4Recorder");
+    
+    m_bus = gst_element_get_bus(m_recorder);
+    m_busHelper = new QGstreamerBusHelper(m_bus, this);
+    m_busHelper->installMessageFilter(this);
+    
+}
+
+QGstreamerMP4RecorderSession::~QGstreamerMP4RecorderSession()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    if (m_recorder) {
+            gst_element_set_state(m_recorder, GST_STATE_NULL);
+
+            delete m_busHelper;
+            gst_object_unref(GST_OBJECT(m_bus));
+            gst_object_unref(GST_OBJECT(m_recorder));
+    }
+}
+
+bool QGstreamerMP4RecorderSession::processBusMessage(const QGstreamerMessage &message)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    GstMessage* gm = message.rawMessage();
+    if (gm) {
+        if (GST_MESSAGE_SRC(gm) == GST_OBJECT_CAST(m_recorder)) {
+            switch (GST_MESSAGE_TYPE(gm))  {
+                case GST_MESSAGE_STATE_CHANGED:
+                {
+
+                    GstState    oldState;
+                    GstState    newState;
+                    GstState    pending;
+
+                    gst_message_parse_state_changed(gm, &oldState, &newState, &pending);
+
+                    switch (newState) {
+                    case GST_STATE_VOID_PENDING:
+                    case GST_STATE_NULL:
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_NULL";
+#endif
+                        break;
+                    case GST_STATE_READY:
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_READY";
+#endif
+                        break;
+                    case GST_STATE_PAUSED:
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_PAUSED";
+#endif
+                        break;
+                    case GST_STATE_PLAYING:
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_PLAYING";
+#endif
+                        break;
+                    }
+                }
+                    break;
+                
+                case GST_MESSAGE_EOS:{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO << "Change to GST_MESSAGE_EOS";
+#endif
+                    gst_element_set_state(m_recorder, GST_STATE_NULL);
+                    emit encodeFinished();
+                    break;
+                }
+            }
+        }
+    }
+    return true;
+}
+
+void QGstreamerMP4RecorderSession::setFSinkLocation(QString fsinkloc)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO << fsinkloc;
+#endif
+    m_fsinklocation = fsinkloc;
+}
+
+
+void QGstreamerMP4RecorderSession::setUsrcPort(int usrcport)
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO << usrcport;
+#endif
+    m_usrcport = usrcport;
+}
+
+void QGstreamerMP4RecorderSession::componentComplete()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_udpsrc = gst_element_factory_make("udpsrc", "Video-input");
+    m_rtph264depay = gst_element_factory_make("rtph264depay", "Rtp-h264depay");
+    m_rtpcapsfilter = gst_element_factory_make("capsfilter", "Caps-filter");
+    m_queue = gst_element_factory_make("queue", "Queue");
+    m_h264parse = gst_element_factory_make("h264parse", "H264-parse");
+    m_qtmux = gst_element_factory_make("qtmux", "Qt-mux");
+    m_filesink = gst_element_factory_make("filesink", "File-sink");
+    
+    gst_bin_add_many (GST_BIN (m_recorder), m_udpsrc, m_rtph264depay, m_rtpcapsfilter, m_queue, m_h264parse, m_qtmux, m_filesink, NULL);
+    gst_element_link_many (m_udpsrc, m_rtph264depay, m_rtpcapsfilter, m_queue, m_h264parse, m_qtmux, m_filesink, NULL);
+    
+    m_udpcaps = gst_caps_new_simple ("application/x-rtp", NULL);
+    g_object_set (G_OBJECT (m_udpsrc), "caps", m_udpcaps, NULL);
+    gst_caps_unref (m_udpcaps);
+    
+    m_rtpcaps  = gst_caps_new_simple ("video/x-h264",
+                                        "framerate", GST_TYPE_FRACTION, 30, 1,
+                                        NULL);
+    g_object_set (G_OBJECT (m_rtpcapsfilter), "caps", m_rtpcaps, NULL);
+    gst_caps_unref (m_rtpcaps);
+}
+// gst-launch-1.0 -e udpsrc port=1234 caps="application/x-rtp" ! rtph264depay ! video/x-h264,framerate=30/1 ! queue ! h264parse ! qtmux ! filesink location=/record.mp4
+void QGstreamerMP4RecorderSession::start()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+	 g_object_set (G_OBJECT (m_filesink), "location", m_fsinklocation.toLatin1().constData(), NULL);
+    g_object_set (G_OBJECT (m_udpsrc), "port", m_usrcport, NULL);
+    gst_element_set_state(m_recorder, GST_STATE_PLAYING);
+    // gst_element_set_state(m_recorder, GST_STATE_PAUSED);
+}
+
+void QGstreamerMP4RecorderSession::stop()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    gst_element_send_event (m_recorder, gst_event_new_eos ());
+    // gst_element_set_state(m_recorder, GST_STATE_NULL);
+}
+
+void QGstreamerMP4RecorderSession::pause()
+{
+#ifdef DEBUG_ENCODER
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordersession.h b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordersession.h
new file mode 100755
index 0000000..b181da5
--- /dev/null
+++ b/src/plugins/gstreamer/MP4Recorder/qgstreamerMP4Recordersession.h
@@ -0,0 +1,112 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGSTREAMERMP4RECORDERSESSION_H
+#define QGSTREAMERMP4RECORDERSESSION_H
+
+#include <QObject>
+#include <QtCore/qmutex.h>
+#include <QtNetwork/qnetworkrequest.h>
+#include "qgstreamerMP4Recordercontrol.h"
+#include <private/qgstreamerbushelper_p.h>
+#include <qmediastreamscontrol.h>
+#include <qaudioformat.h>
+
+#if defined(HAVE_GST_APPSRC)
+#include <private/qgstappsrc_p.h>
+#endif
+
+#include <gst/gst.h>
+
+QT_BEGIN_NAMESPACE
+
+class QGstreamerBusHelper;
+class QGstreamerMessage;
+
+class QGstreamerVideoRendererInterface;
+class QGstreamerVideoProbeControl;
+class QGstreamerAudioProbeControl;
+
+typedef enum {
+  GST_AUTOPLUG_SELECT_TRY,
+  GST_AUTOPLUG_SELECT_EXPOSE,
+  GST_AUTOPLUG_SELECT_SKIP
+} GstAutoplugSelectResult;
+
+class QGstreamerMP4RecorderSession : public QObject,
+                                public QGstreamerBusMessageFilter
+{
+Q_OBJECT
+Q_INTERFACES(QGstreamerBusMessageFilter)
+
+public:
+    QGstreamerMP4RecorderSession(QObject *parent);
+    virtual ~QGstreamerMP4RecorderSession();
+    
+    bool processBusMessage(const QGstreamerMessage &message);
+    QGstreamerBusHelper *bus() const { return m_busHelper; }
+    
+    void setUsrcPort(int);
+    void setFSinkLocation(QString);
+    void componentComplete();
+
+public slots:
+    void start();
+    void stop();
+    void pause();
+
+signals:
+    void encodeFinished();
+
+private:
+    
+    QString m_fsinklocation;
+    int m_usrcport;
+    
+    GstBus* m_bus;
+    QGstreamerBusHelper* m_busHelper;
+    GstElement* m_recorder;
+    
+    GstElement* m_udpsrc; GstCaps* m_udpcaps;
+    GstElement* m_rtph264depay;
+    GstElement* m_rtpcapsfilter; GstCaps* m_rtpcaps;
+    GstElement* m_queue;
+    GstElement* m_h264parse;
+    GstElement* m_qtmux;
+    GstElement* m_filesink;
+
+};
+
+QT_END_NAMESPACE
+
+#endif // QGSTREAMERMP4RECORDERSESSION_H
diff --git a/src/plugins/gstreamer/audiostreaming/audiostreaming.json b/src/plugins/gstreamer/audiostreaming/audiostreaming.json
new file mode 100755
index 0000000..5b766fd
--- /dev/null
+++ b/src/plugins/gstreamer/audiostreaming/audiostreaming.json
@@ -0,0 +1,4 @@
+{
+    "Keys": ["gstreameraudiostreaming"],
+    "Services": ["org.qt-project.qt.audiostreaming"]
+}
diff --git a/src/plugins/gstreamer/audiostreaming/audiostreaming.pro b/src/plugins/gstreamer/audiostreaming/audiostreaming.pro
new file mode 100755
index 0000000..cfdd6c8
--- /dev/null
+++ b/src/plugins/gstreamer/audiostreaming/audiostreaming.pro
@@ -0,0 +1,25 @@
+TARGET = gstaudiostreaming
+
+PLUGIN_TYPE = mediaservice
+PLUGIN_CLASS_NAME = QGstreamerPlayerServicePlugin
+load(qt_plugin)
+
+include(../common.pri)
+
+INCLUDEPATH += $$PWD
+
+HEADERS += \
+    $$PWD/qgstreameraudiostreamingcontrol.h \
+    $$PWD/qgstreameraudiostreamingservice.h \
+    $$PWD/qgstreameraudiostreamingsession.h \
+    $$PWD/qgstreameraudiostreamingserviceplugin.h
+
+SOURCES += \
+    $$PWD/qgstreameraudiostreamingcontrol.cpp \
+    $$PWD/qgstreameraudiostreamingservice.cpp \
+    $$PWD/qgstreameraudiostreamingsession.cpp \
+    $$PWD/qgstreameraudiostreamingserviceplugin.cpp
+
+OTHER_FILES += \
+    audiostreaming.json
+
diff --git a/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingcontrol.cpp b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingcontrol.cpp
new file mode 100755
index 0000000..8a3edf1
--- /dev/null
+++ b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingcontrol.cpp
@@ -0,0 +1,149 @@
+#include "qgstreameraudiostreamingcontrol.h"
+#include "qgstreameraudiostreamingsession.h"
+
+// #define DEBUG_AUDIOSTREAMING
+QT_BEGIN_NAMESPACE
+
+QGstreamerAudioStreamingControl::QGstreamerAudioStreamingControl(QGstreamerAudioStreamingSession *session, QObject *parent)
+    : QAudioStreamingControl(parent)
+    , m_session(session)
+    , m_currentState(QAudioStreaming::StoppedState)
+    , m_status(QAudioStreaming::NoMedia)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    connect(m_session, SIGNAL(signal_Session_StateStatusChanged(QAudioStreaming::State, QAudioStreaming::Status)), this, 
+                        SLOT(slot_Control_StateStatusChanged(QAudioStreaming::State, QAudioStreaming::Status)));
+}
+
+QGstreamerAudioStreamingControl::~QGstreamerAudioStreamingControl()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+}
+
+QAudioStreaming::State QGstreamerAudioStreamingControl::state() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_session->state();
+}
+
+QAudioStreaming::Status QGstreamerAudioStreamingControl::status() const
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_session->status();
+}
+
+void QGstreamerAudioStreamingControl::talk()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->talk();
+}
+
+void QGstreamerAudioStreamingControl::mute()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->mute();
+}
+
+void QGstreamerAudioStreamingControl::stop()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->stop();
+}
+
+void QGstreamerAudioStreamingControl::setType(QString type)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->setType(type);
+}
+
+void QGstreamerAudioStreamingControl::setAudioPlugin(QString audioplugin)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->setAudioPlugin(audioplugin);
+}
+
+void QGstreamerAudioStreamingControl::setAsrcDevice(QString device)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << device;
+#endif
+    m_session->setAsrcDevice(device);
+}
+
+void QGstreamerAudioStreamingControl::setAsinkSync(bool sync)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << sync;
+#endif
+    m_session->setAsinkSync(sync);
+}
+
+void QGstreamerAudioStreamingControl::setUsrcPort(int port)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << port;
+#endif
+    m_session->setUsrcPort(port);
+}
+
+void QGstreamerAudioStreamingControl::setUsinkHost(QString host)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << host;
+#endif
+    m_session->setUsinkHost(host);
+}
+
+void QGstreamerAudioStreamingControl::setUsinkPort(int port)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << port;
+#endif
+    m_session->setUsinkPort(port);
+}
+
+void QGstreamerAudioStreamingControl::setUsinkSync(bool sync)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << sync;
+#endif
+    m_session->setUsinkSync(sync);
+}
+
+void QGstreamerAudioStreamingControl::componentComplete()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session->componentComplete();
+}
+
+void QGstreamerAudioStreamingControl::slot_Control_StateStatusChanged(QAudioStreaming::State newstate, QAudioStreaming::Status newstatus)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_currentState = newstate;
+    m_status = newstatus;
+    emit statestatusChanged(m_currentState, m_status);
+}
+
+QT_END_NAMESPACE
\ No newline at end of file
diff --git a/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingcontrol.h b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingcontrol.h
new file mode 100755
index 0000000..59c473f
--- /dev/null
+++ b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingcontrol.h
@@ -0,0 +1,50 @@
+#ifndef QGSTREAMERAUDIOSTREAMINGCONTROL_H
+#define QGSTREAMERAUDIOSTREAMINGCONTROL_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qstack.h>
+#include <qaudiostreamingcontrol.h>
+#include <qaudiostreaming.h>
+#include <limits.h>
+
+QT_BEGIN_NAMESPACE
+
+class QGstreamerAudioStreamingService;
+class QGstreamerAudioStreamingSession;
+
+class QGstreamerAudioStreamingControl : public QAudioStreamingControl
+{
+    Q_OBJECT
+
+public:
+    QGstreamerAudioStreamingControl(QGstreamerAudioStreamingSession *session, QObject *parent = 0);
+    ~QGstreamerAudioStreamingControl();
+    
+    QAudioStreaming::State state() const;
+    QAudioStreaming::Status status() const;
+    
+    void talk();
+    void mute();
+    void stop();
+    
+    void setType(QString type);
+    void setAudioPlugin(QString audioplugin);
+    void setAsrcDevice(QString device);
+    void setAsinkSync(bool sync);
+    void setUsrcPort(int port);
+    void setUsinkHost(QString host);
+    void setUsinkPort(int port);
+    void setUsinkSync(bool sync);
+    void componentComplete();
+    
+public slots:
+    void slot_Control_StateStatusChanged(QAudioStreaming::State, QAudioStreaming::Status);
+    
+private:
+    QGstreamerAudioStreamingSession *m_session;
+    QAudioStreaming::State m_currentState;
+    QAudioStreaming::Status m_status;
+};
+
+QT_END_NAMESPACE
+#endif
\ No newline at end of file
diff --git a/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingservice.cpp b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingservice.cpp
new file mode 100755
index 0000000..2b7abfa
--- /dev/null
+++ b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingservice.cpp
@@ -0,0 +1,87 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtCore/qvariant.h>
+#include <QtCore/qdebug.h>
+
+#include "qgstreameraudiostreamingservice.h"
+#include "qgstreameraudiostreamingcontrol.h"
+#include "qgstreameraudiostreamingsession.h"
+
+
+#include <private/qmediaplaylistnavigator_p.h>
+#include <qmediaplaylist.h>
+#include <private/qmediaresourceset_p.h>
+
+// #define DEBUG_AUDIOSTREAMING
+
+QT_BEGIN_NAMESPACE
+
+QGstreamerAudioStreamingService::QGstreamerAudioStreamingService(QObject *parent):
+     QMediaService(parent)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_session = new QGstreamerAudioStreamingSession(this);
+    m_control = new QGstreamerAudioStreamingControl(m_session, this);
+}
+
+QGstreamerAudioStreamingService::~QGstreamerAudioStreamingService()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    
+}
+
+QMediaControl *QGstreamerAudioStreamingService::requestControl(const char *name)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    if (qstrcmp(name, QAudioStreamingControl_iid) == 0){
+        return m_control;
+    }
+
+    return 0;
+}
+
+void QGstreamerAudioStreamingService::releaseControl(QMediaControl *control)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingservice.h b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingservice.h
new file mode 100755
index 0000000..bdd2957
--- /dev/null
+++ b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingservice.h
@@ -0,0 +1,68 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QGSTREAMERAUDIOSTREAMINGSERVICE_H
+#define QGSTREAMERAUDIOSTREAMINGSERVICE_H
+
+#include <QtCore/qobject.h>
+#include <QtCore/qiodevice.h>
+
+#include <qmediaservice.h>
+
+QT_BEGIN_NAMESPACE
+class QMediaPlayerControl;
+class QMediaPlaylist;
+class QMediaPlaylistNavigator;
+
+class QGstreamerMetaData;
+class QGstreamerAudioStreamingControl;
+class QGstreamerAudioStreamingSession;
+
+class QGstreamerAudioStreamingService : public QMediaService
+{
+    Q_OBJECT
+public:
+    QGstreamerAudioStreamingService(QObject *parent = 0);
+    ~QGstreamerAudioStreamingService();
+
+    QMediaControl *requestControl(const char *name);
+    void releaseControl(QMediaControl *control);
+
+private:
+    QGstreamerAudioStreamingControl *m_control;
+    QGstreamerAudioStreamingSession *m_session;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingserviceplugin.cpp b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingserviceplugin.cpp
new file mode 100755
index 0000000..e81385b
--- /dev/null
+++ b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingserviceplugin.cpp
@@ -0,0 +1,65 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <QtCore/qstring.h>
+#include <QtCore/qdebug.h>
+#include <QtCore/QDir>
+#include <QtCore/QDebug>
+
+#include "qgstreameraudiostreamingserviceplugin.h"
+#include "qgstreameraudiostreamingservice.h"
+#include <private/qgstutils_p.h>
+
+// #define DEBUG_AUDIOSTREAMING
+
+QMediaService* QGstreamerAudioStreamingServicePlugin::create(const QString &key)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    QGstUtils::initializeGst();
+
+    if (key == QLatin1String(Q_MEDIASERVICE_AUDIOSTREAMING))
+        return new QGstreamerAudioStreamingService;
+
+    qWarning() << "Gstreamer service plugin: unsupported key:" << key;
+    return 0;
+}
+
+void QGstreamerAudioStreamingServicePlugin::release(QMediaService *service)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    delete service;
+}
diff --git a/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingserviceplugin.h b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingserviceplugin.h
new file mode 100755
index 0000000..b939cfa
--- /dev/null
+++ b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingserviceplugin.h
@@ -0,0 +1,60 @@
+/****************************************************************************
+**
+** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/legal
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and Digia. For licensing terms and
+** conditions see http://qt.digia.com/licensing. For further information
+** use the contact form at http://qt.digia.com/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Digia gives you certain additional
+** rights. These rights are described in the Digia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+
+#ifndef QGSTREAMERAUDIOSTREAMINGSERVICEPLUGIN_H
+#define QGSTREAMERAUDIOSTREAMINGSERVICEPLUGIN_H
+
+#include <qmediaserviceproviderplugin.h>
+#include <QtCore/qset.h>
+#include <QtCore/QObject>
+
+QT_BEGIN_NAMESPACE
+
+
+class QGstreamerAudioStreamingServicePlugin
+    : public QMediaServiceProviderPlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.qt.mediaserviceproviderfactory/5.0" FILE "audiostreaming.json")
+public:
+    QMediaService* create(QString const& key);
+    void release(QMediaService *service);
+
+private:
+};
+
+QT_END_NAMESPACE
+
+#endif // QGSTREAMERAUDIOSTREAMINGSERVICEPLUGIN_H
+
diff --git a/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingsession.cpp b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingsession.cpp
new file mode 100755
index 0000000..f851144
--- /dev/null
+++ b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingsession.cpp
@@ -0,0 +1,299 @@
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <stdio.h>
+#include "qgstreameraudiostreamingsession.h"
+#include <private/qgstreamerbushelper_p.h>
+
+// #define DEBUG_AUDIOSTREAMING
+QT_BEGIN_NAMESPACE
+
+QGstreamerAudioStreamingSession::QGstreamerAudioStreamingSession(QObject *parent)
+    :QObject(parent)
+    , m_type("\0")
+    , m_asrcdevice("hw:0,0")
+    , m_asinksync(true)
+    , m_usrcport(5004)
+    , m_usinkhost("localhost")
+    , m_usinkport(5004)
+    , m_usinksync(true)
+    , m_state(QAudioStreaming::StoppedState)
+    , m_status(QAudioStreaming::UnActive)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    m_pipeline = gst_pipeline_new ("AudioStreaming");
+    m_bus = gst_element_get_bus(m_pipeline);
+    m_busHelper = new QGstreamerBusHelper(m_bus, this);
+    m_busHelper->installMessageFilter(this);
+}
+
+QGstreamerAudioStreamingSession::~QGstreamerAudioStreamingSession()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    if (m_pipeline) {
+        stop();
+        delete m_busHelper;
+        gst_object_unref(GST_OBJECT(m_bus));
+        gst_object_unref(GST_OBJECT(m_pipeline));
+    }
+}
+
+bool QGstreamerAudioStreamingSession::processBusMessage(const QGstreamerMessage &message)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    // qDebug() << Q_FUNC_INFO;
+#endif
+    GstMessage* gm = message.rawMessage();
+    if (gm) {
+        if (GST_MESSAGE_SRC(gm) == GST_OBJECT_CAST(m_pipeline)) {
+            switch (GST_MESSAGE_TYPE(gm))  {
+                case GST_MESSAGE_STATE_CHANGED:
+                {
+
+                    GstState    oldState;
+                    GstState    newState;
+                    GstState    pending;
+
+                    gst_message_parse_state_changed(gm, &oldState, &newState, &pending);
+
+                    switch (newState) {
+                    case GST_STATE_VOID_PENDING:
+                    case GST_STATE_NULL:
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_NULL";
+#endif
+                        break;
+                    case GST_STATE_READY:
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_READY";
+#endif
+                        break;
+                    case GST_STATE_PAUSED:
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_PAUSED";
+#endif
+                        m_state = QAudioStreaming::MutedState;
+                        m_status = QAudioStreaming::LoadedMedia;
+                        emit signal_Session_StateStatusChanged(m_state, m_status);
+                        break;
+                    case GST_STATE_PLAYING:
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << "Change to GST_STATE_PLAYING";
+#endif
+                        m_state = QAudioStreaming::TalkedState;
+                        m_status = QAudioStreaming::Active;
+                        emit signal_Session_StateStatusChanged(m_state, m_status);
+                        break;
+                    }
+                }
+                    break;
+                
+                case GST_MESSAGE_EOS:{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << "Change to GST_MESSAGE_EOS";
+#endif
+                    break;
+                }
+            }
+        }
+    }
+    
+    return true;
+}
+
+QAudioStreaming::State QGstreamerAudioStreamingSession::state()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_state;
+}
+
+QAudioStreaming::Status QGstreamerAudioStreamingSession::status()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    return m_status;
+}
+
+void QGstreamerAudioStreamingSession::talk()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    gst_element_set_state(m_pipeline, GST_STATE_PLAYING);
+}
+
+void QGstreamerAudioStreamingSession::mute()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    gst_element_set_state(m_pipeline, GST_STATE_PAUSED);
+}
+
+void QGstreamerAudioStreamingSession::stop()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    gst_element_set_state(m_pipeline, GST_STATE_NULL);
+}
+
+void QGstreamerAudioStreamingSession::setType(QString type)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << type;
+#endif
+    m_type = type;
+}
+
+void QGstreamerAudioStreamingSession::setAudioPlugin(QString audioplugin)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << audioplugin;
+#endif
+    m_audioplugin = audioplugin;
+}
+
+void QGstreamerAudioStreamingSession::setAsrcDevice(QString device)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << device;
+#endif
+    m_asrcdevice = device;
+}
+
+void QGstreamerAudioStreamingSession::setAsinkSync(bool sync)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << sync;
+#endif
+    m_asinksync = sync;
+}
+
+void QGstreamerAudioStreamingSession::setUsrcPort(int port)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << port;
+#endif
+    m_usrcport = port;
+}
+
+void QGstreamerAudioStreamingSession::setUsinkHost(QString host)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << host;
+#endif
+    m_usinkhost = host;
+}
+
+void QGstreamerAudioStreamingSession::setUsinkPort(int port)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << port;
+#endif
+    m_usinkport = port;
+}
+
+void QGstreamerAudioStreamingSession::setUsinkSync(bool sync)
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO << sync;
+#endif
+    m_usinksync = sync;
+}
+
+void QGstreamerAudioStreamingSession::componentComplete()
+{
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << Q_FUNC_INFO;
+#endif
+    if(m_type == "Send"){
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << "Send Side";
+#endif
+        if(m_audioplugin == "Alsa GST"){
+            m_alsasrc = gst_element_factory_make("alsasrc", "Audio-output");
+            m_aconvert = gst_element_factory_make("audioconvert", "audioconvert");
+            m_aacenc = gst_element_factory_make("avenc_aac", "avenc_aac");
+            m_rtpmp4apay = gst_element_factory_make("rtpmp4apay", "rtpmp4apay");
+            m_udpsink = gst_element_factory_make("udpsink", "udpsink");
+            
+            gst_bin_add_many (GST_BIN (m_pipeline), m_alsasrc, m_aconvert, m_aacenc, m_rtpmp4apay, m_udpsink, NULL);
+            gst_element_link_many(m_alsasrc, m_aconvert, m_aacenc, m_rtpmp4apay, m_udpsink, NULL);
+
+            g_object_set (G_OBJECT (m_alsasrc), "device", m_asrcdevice.toLatin1().constData(), NULL);
+            g_object_set (G_OBJECT (m_aacenc), "compliance", -2, NULL);
+            g_object_set (G_OBJECT (m_udpsink), "host", m_usinkhost.toLatin1().constData(), NULL);
+            g_object_set (G_OBJECT (m_udpsink), "port", m_usinkport, NULL);
+            g_object_set (G_OBJECT (m_udpsink), "sync", m_usinksync, NULL);
+        }else if(m_audioplugin == "Pulse GST"){
+             qDebug() << "Pulse GST";
+            m_pulsesrc = gst_element_factory_make("pulsesrc", "Audio-output");
+            m_aconvert = gst_element_factory_make("audioconvert", "audioconvert");
+            m_aacenc = gst_element_factory_make("avenc_aac", "avenc_aac");
+            m_rtpmp4apay = gst_element_factory_make("rtpmp4apay", "rtpmp4apay");
+            m_udpsink = gst_element_factory_make("udpsink", "udpsink");
+            
+            gst_bin_add_many (GST_BIN (m_pipeline), m_pulsesrc, m_aconvert, m_aacenc, m_rtpmp4apay, m_udpsink, NULL);
+            gst_element_link_many(m_pulsesrc, m_aconvert, m_aacenc, m_rtpmp4apay, m_udpsink, NULL);
+            
+            g_object_set (G_OBJECT (m_pulsesrc), "provide-clock", false, NULL);
+            g_object_set (G_OBJECT (m_aacenc), "compliance", -2, NULL);
+            GstStructure *props;
+            props = gst_structure_from_string ("props,media.role=phone,filter.want=echo-cancel", NULL);
+            g_object_set (G_OBJECT (m_pulsesrc), "stream-properties", props, NULL);
+            gst_structure_free (props);
+        }
+    }else if(m_type == "Receive"){
+#ifdef DEBUG_AUDIOSTREAMING
+    qDebug() << "Receive Side";
+#endif
+        if(m_audioplugin == "Alsa GST"){
+            m_udpsrc = gst_element_factory_make("udpsrc", "Audio-input");
+            m_rtpjitterbuffer = gst_element_factory_make("rtpjitterbuffer", "rtpjitterbuffer");
+            m_queue = gst_element_factory_make("queue", "queue");
+            m_rtpmp4adepay = gst_element_factory_make("rtpmp4adepay", "rtpmp4adepay");
+            m_aacdec = gst_element_factory_make("avdec_aac", "avdec_aac");
+            m_aconvert = gst_element_factory_make("audioconvert", "audioconvert");
+            m_alsasink = gst_element_factory_make("alsasink", "Audio-Display");
+            
+            gst_bin_add_many (GST_BIN (m_pipeline), m_udpsrc, m_rtpjitterbuffer, m_queue, m_rtpmp4adepay, m_aacdec, m_aconvert, m_alsasink, NULL);
+            gst_element_link_many (m_udpsrc, m_rtpjitterbuffer, m_queue, m_rtpmp4adepay, m_aacdec, m_aconvert, m_alsasink, NULL);
+
+            g_object_set (G_OBJECT (m_udpsrc), "port", m_usrcport, NULL);
+            m_capsfilter = gst_caps_new_simple ("application/x-rtp",
+                                                "config", G_TYPE_STRING, "40002420",
+                                                NULL);
+            g_object_set (G_OBJECT (m_udpsrc), "caps", m_capsfilter, NULL);
+            gst_caps_unref (m_capsfilter);
+        }else if(m_audioplugin == "Pulse GST"){
+            m_udpsrc = gst_element_factory_make("udpsrc", "Audio-input");
+            m_rtpjitterbuffer = gst_element_factory_make("rtpjitterbuffer", "rtpjitterbuffer");
+            m_queue = gst_element_factory_make("queue", "queue");
+            m_rtpmp4adepay = gst_element_factory_make("rtpmp4adepay", "rtpmp4adepay");
+            m_aacdec = gst_element_factory_make("avdec_aac", "avdec_aac");
+            m_aconvert = gst_element_factory_make("audioconvert", "audioconvert");
+            m_pulsesink = gst_element_factory_make("pulsesink", "Audio-Display");
+            
+            gst_bin_add_many (GST_BIN (m_pipeline), m_udpsrc, m_rtpjitterbuffer, m_queue, m_rtpmp4adepay, m_aacdec, m_aconvert, m_pulsesink, NULL);
+            gst_element_link_many (m_udpsrc, m_rtpjitterbuffer, m_queue, m_rtpmp4adepay, m_aacdec, m_aconvert, m_pulsesink, NULL);
+
+            g_object_set (G_OBJECT (m_udpsrc), "port", m_usrcport, NULL);
+            m_capsfilter = gst_caps_new_simple ("application/x-rtp",
+                                                "config", G_TYPE_STRING, "40002420",
+                                                NULL);
+            g_object_set (G_OBJECT (m_udpsrc), "caps", m_capsfilter, NULL);
+            gst_caps_unref (m_capsfilter);
+        }
+    }
+}
+
+
+QT_END_NAMESPACE
diff --git a/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingsession.h b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingsession.h
new file mode 100755
index 0000000..973ba2a
--- /dev/null
+++ b/src/plugins/gstreamer/audiostreaming/qgstreameraudiostreamingsession.h
@@ -0,0 +1,73 @@
+#ifndef QGSTREAMERAUDIOSTREAMINGSESSION_H
+#define QGSTREAMERAUDIOSTREAMINGSESSION_H
+
+#include <QObject>
+#include <QtCore/qmutex.h>
+#include <QtNetwork/qnetworkrequest.h>
+#include "qgstreameraudiostreamingcontrol.h"
+#include <private/qgstreamerbushelper_p.h>
+#include <qmediastreamscontrol.h>
+#include <qaudioformat.h>
+#include <gst/gst.h>
+
+QT_BEGIN_NAMESPACE
+class QGstreamerBusHelper;
+class QGstreamerMessage;
+
+class QGstreamerAudioStreamingSession : public QObject,
+                                public QGstreamerBusMessageFilter
+{
+Q_OBJECT
+Q_INTERFACES(QGstreamerBusMessageFilter)
+public:
+    QGstreamerAudioStreamingSession(QObject *parent);
+    virtual ~QGstreamerAudioStreamingSession();
+    
+    bool processBusMessage(const QGstreamerMessage &message);
+    QGstreamerBusHelper *bus() const { return m_busHelper; }
+    
+    QAudioStreaming::State state();
+    QAudioStreaming::Status status();
+    
+    void talk();
+    void mute();
+    void stop();
+    
+    void setType(QString type);
+    void setAudioPlugin(QString audioplugin);
+    void setAsrcDevice(QString device);
+    void setAsinkSync(bool sync);
+    void setUsrcPort(int port);
+    void setUsinkHost(QString host);
+    void setUsinkPort(int port);
+    void setUsinkSync(bool sync);
+    void componentComplete();
+    
+signals:
+    void signal_Session_StateStatusChanged(QAudioStreaming::State, QAudioStreaming::Status);
+    
+private:
+    GstBus* m_bus;
+    QGstreamerBusHelper* m_busHelper;
+    QAudioStreaming::State m_state;
+    QAudioStreaming::Status m_status;
+    
+    QString m_type;
+    QString m_audioplugin;
+    QString m_asrcdevice;
+    bool m_asinksync;
+    int m_usrcport;
+    QString m_usinkhost;
+    int m_usinkport;
+    bool m_usinksync;
+    
+    GstElement *m_pipeline;
+    GstElement *m_alsasrc, *m_aconvert, *m_aacenc, *m_rtpmp4apay, *m_udpsink;
+    GstElement *m_udpsrc, *m_rtpjitterbuffer, *m_queue, *m_rtpmp4adepay, *m_alsasink, *m_aacdec;
+    GstCaps *m_capsfilter;
+    GstElement *m_pulsesrc, *m_pulsesink;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/plugins/gstreamer/common.pri b/src/plugins/gstreamer/common.pri
index eb6a299..61f56d6 100644
--- a/src/plugins/gstreamer/common.pri
+++ b/src/plugins/gstreamer/common.pri
@@ -34,5 +34,6 @@ config_gstreamer_appsrc {
     PKGCONFIG += gstreamer-app-$$GST_VERSION
     DEFINES += HAVE_GST_APPSRC
     LIBS += -lgstapp-$$GST_VERSION
+	 LIBS += -lgstrtspserver-$$GST_VERSION
 }
 
diff --git a/src/plugins/gstreamer/gstreamer.json b/src/plugins/gstreamer/gstreamer.json
index 0656cce..baf5f57 100644
--- a/src/plugins/gstreamer/gstreamer.json
+++ b/src/plugins/gstreamer/gstreamer.json
@@ -1,4 +1,4 @@
 {
     "Keys": ["gstreamer"],
-    "Services": ["org.qt-project.qt.mediaplayer", "org.qt-project.qt.audiosource", "org.qt-project.qt.camera", "org.qt-project.qt.audiodecode"]
+    "Services": ["org.qt-project.qt.MP4Recorder", "org.qt-project.qt.mp4playback", "org.qt-project.qt.audiostreaming", "org.qt-project.qt.H264Streaming", "org.qt-project.qt.mediaplayer", "org.qt-project.qt.audiosource", "org.qt-project.qt.camera", "org.qt-project.qt.audiodecode"]
 }
diff --git a/src/plugins/gstreamer/gstreamer.pro b/src/plugins/gstreamer/gstreamer.pro
index 0ff3510..e10cc3b 100644
--- a/src/plugins/gstreamer/gstreamer.pro
+++ b/src/plugins/gstreamer/gstreamer.pro
@@ -3,7 +3,11 @@ TEMPLATE = subdirs
 SUBDIRS += \
     audiodecoder \
     mediaplayer \
-    mediacapture
+    mediacapture \
+    H264Streaming \
+    audiostreaming \
+    MP4Playback \
+    MP4Recorder
 
 config_gstreamer_encodingprofiles {
     SUBDIRS += camerabin
-- 
1.9.1

